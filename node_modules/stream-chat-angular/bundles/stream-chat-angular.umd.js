(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('stream-chat'), require('rxjs/operators'), require('uuid'), require('@ngx-translate/core'), require('@angular/common'), require('pretty-bytes'), require('dayjs'), require('dayjs/plugin/calendar'), require('dayjs/plugin/relativeTime'), require('emoji-regex'), require('ngx-popperjs'), require('@stream-io/transliterate'), require('angular-mentions')) :
    typeof define === 'function' && define.amd ? define('stream-chat-angular', ['exports', '@angular/core', 'rxjs', 'stream-chat', 'rxjs/operators', 'uuid', '@ngx-translate/core', '@angular/common', 'pretty-bytes', 'dayjs', 'dayjs/plugin/calendar', 'dayjs/plugin/relativeTime', 'emoji-regex', 'ngx-popperjs', '@stream-io/transliterate', 'angular-mentions'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['stream-chat-angular'] = {}, global.ng.core, global.rxjs, global.streamChat, global.rxjs.operators, global.uuid, global.i9, global.ng.common, global.prettybytes, global.Dayjs, global.calendar, global.relativeTime, global.emojiRegex, global.i9$1, global.transliterate, global.i8$1));
}(this, (function (exports, i0, rxjs, streamChat, operators, uuid, i9, i8, prettybytes, Dayjs, calendar, relativeTime, emojiRegex, i9$1, transliterate, i8$1) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i9__namespace = /*#__PURE__*/_interopNamespace(i9);
    var i8__namespace = /*#__PURE__*/_interopNamespace(i8);
    var prettybytes__default = /*#__PURE__*/_interopDefaultLegacy(prettybytes);
    var Dayjs__default = /*#__PURE__*/_interopDefaultLegacy(Dayjs);
    var calendar__default = /*#__PURE__*/_interopDefaultLegacy(calendar);
    var relativeTime__default = /*#__PURE__*/_interopDefaultLegacy(relativeTime);
    var emojiRegex__default = /*#__PURE__*/_interopDefaultLegacy(emojiRegex);
    var i9__namespace$1 = /*#__PURE__*/_interopNamespace(i9$1);
    var transliterate__default = /*#__PURE__*/_interopDefaultLegacy(transliterate);
    var i8__namespace$1 = /*#__PURE__*/_interopNamespace(i8$1);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var version = '4.66.5';

    /**
     * The `NotificationService` can be used to add or remove notifications. By default the [`NotificationList`](../components/NotificationListComponent.mdx) component displays the currently active notifications.
     */
    var NotificationService = /** @class */ (function () {
        function NotificationService() {
            this.notificationsSubject = new rxjs.BehaviorSubject([]);
            this.notifications$ = this.notificationsSubject.asObservable();
        }
        /**
         * Displays a notification for the given amount of time.
         * @param content The text of the notification or the HTML template for the notification
         * @param type The type of the notification
         * @param timeout The number of milliseconds while the notification should be visible
         * @param translateParams Translation parameters for the `content` (for text notifications)
         * @param templateContext The input of the notification template (for HTML notifications)
         * @returns A method to clear the notification (before the timeout).
         */
        NotificationService.prototype.addTemporaryNotification = function (content, type, timeout, translateParams, templateContext) {
            var _this = this;
            if (type === void 0) { type = 'error'; }
            if (timeout === void 0) { timeout = 5000; }
            var notification = this.createNotification(content, type, translateParams, templateContext);
            var id = setTimeout(function () { return _this.removeNotification(notification.id); }, timeout);
            notification.dismissFn = function () {
                clearTimeout(id);
                _this.removeNotification(notification.id);
            };
            this.notificationsSubject.next(__spreadArray(__spreadArray([], __read(this.notificationsSubject.getValue())), [
                notification,
            ]));
            return notification.dismissFn;
        };
        /**
         * Displays a notification, that will be visible until it's removed.
         * @param content The text of the notification or the HTML template for the notification
         * @param type The type of the notification
         * @param translateParams Translation parameters for the `content` (for text notifications)
         * @param templateContext The input of the notification template (for HTML notifications)
         * @returns A method to clear the notification.
         */
        NotificationService.prototype.addPermanentNotification = function (content, type, translateParams, templateContext) {
            if (type === void 0) { type = 'error'; }
            var notification = this.createNotification(content, type, translateParams, templateContext);
            this.notificationsSubject.next(__spreadArray(__spreadArray([], __read(this.notificationsSubject.getValue())), [
                notification,
            ]));
            return notification.dismissFn;
        };
        NotificationService.prototype.createNotification = function (content, type, translateParams, templateContext) {
            var _a;
            var _this = this;
            var id = new Date().getTime().toString() + Math.random().toString();
            return _a = {
                    id: id
                },
                _a[typeof content === 'string' ? 'text' : 'template'] = content,
                _a.type = type,
                _a.translateParams = translateParams,
                _a.templateContext = templateContext,
                _a.dismissFn = function () { return _this.removeNotification(id); },
                _a;
        };
        NotificationService.prototype.removeNotification = function (id) {
            var notifications = this.notificationsSubject.getValue();
            var index = notifications.findIndex(function (n) { return n.id === id; });
            if (index === -1) {
                return;
            }
            notifications.splice(index, 1);
            this.notificationsSubject.next(__spreadArray([], __read(notifications)));
        };
        return NotificationService;
    }());
    NotificationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: NotificationService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NotificationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: NotificationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: NotificationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    /**
     * The `ChatClient` service connects the user to the Stream chat.
     */
    var ChatClientService = /** @class */ (function () {
        function ChatClientService(ngZone, notificationService) {
            this.ngZone = ngZone;
            this.notificationService = notificationService;
            this.notificationSubject = new rxjs.ReplaySubject(1);
            this.connectionStateSubject = new rxjs.ReplaySubject(1);
            this.appSettingsSubject = new rxjs.BehaviorSubject(undefined);
            this.pendingInvitesSubject = new rxjs.BehaviorSubject([]);
            this.userSubject = new rxjs.ReplaySubject(1);
            this.subscriptions = [];
            this.events$ = this.notificationSubject.asObservable();
            this.connectionState$ = this.connectionStateSubject.asObservable();
            this.appSettings$ = this.appSettingsSubject.asObservable();
            this.pendingInvites$ = this.pendingInvitesSubject.asObservable();
            this.user$ = this.userSubject.asObservable();
        }
        /**
         * Creates a [`StreamChat`](https://github.com/GetStream/stream-chat-js/blob/668b3e5521339f4e14fc657834531b4c8bf8176b/src/client.ts#L124) instance using the provided `apiKey`, and connects a user with the given meta data and token. More info about [connecting users](https://getstream.io/chat/docs/javascript/init_and_users/?language=javascript) can be found in the platform documentation.
         * @param apiKey
         * @param userOrId you can emit this for anonymous logins
         * @param userTokenOrProvider You can provide:<ul>
         *  <li> a token, </li>
         *  <li> a token provider, a method that returns `Promise<string>`, which can be called when the previous token expires (recommended setup for production applications)</li>
         *  <li> the keyword 'guest' to connect as [guest user](https://getstream.io/chat/docs/javascript/authless_users/?language=javascript#guest-users) </li>
         *  <li> the keyword 'anonymous' to connect as [anonymous user](https://getstream.io/chat/docs/javascript/authless_users/?language=javascript#anonymous-users) </li>
         *  </ul>
         * @param clientOptions Setting to provide to the Stream client instance
         */
        ChatClientService.prototype.init = function (apiKey, userOrId, userTokenOrProvider, clientOptions) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var result, channels, removeNotification;
                var _this = this;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            this.chatClient = streamChat.StreamChat.getInstance(apiKey, clientOptions);
                            this.chatClient.recoverStateOnReconnect = false;
                            this.chatClient.devToken;
                            return [4 /*yield*/, this.ngZone.runOutsideAngular(function () { return __awaiter(_this, void 0, void 0, function () {
                                    var _b, user, error_1, sdkPrefix;
                                    var _this = this;
                                    return __generator(this, function (_d) {
                                        switch (_d.label) {
                                            case 0:
                                                user = typeof userOrId === 'string' ? { id: userOrId } : userOrId;
                                                _d.label = 1;
                                            case 1:
                                                _d.trys.push([1, 3, , 4]);
                                                return [4 /*yield*/, ((_b = {
                                                        guest: function () { return _this.chatClient.setGuestUser(user); },
                                                        anonymous: function () { return _this.chatClient.connectAnonymousUser(); },
                                                        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                                                    }["" + userTokenOrProvider]) !== null && _b !== void 0 ? _b : (function () { return _this.chatClient.connectUser(user, userTokenOrProvider); }))()];
                                            case 2:
                                                result = _d.sent();
                                                return [3 /*break*/, 4];
                                            case 3:
                                                error_1 = _d.sent();
                                                this.notificationService.addPermanentNotification('streamChat.Error connecting to chat, refresh the page to try again.', 'error');
                                                throw error_1;
                                            case 4:
                                                this.userSubject.next(this.chatClient.user ? Object.assign({}, this.chatClient.user) : undefined);
                                                sdkPrefix = 'stream-chat-angular';
                                                if (!this.chatClient.getUserAgent().includes(sdkPrefix)) {
                                                    this.chatClient.setUserAgent(sdkPrefix + "-" + version + "-" + this.chatClient.getUserAgent());
                                                }
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _d.sent();
                            return [4 /*yield*/, this.chatClient.queryChannels({ invite: 'pending' }, // TODO: find out why we need this typecast
                                {}, { user_id: (_a = this.chatClient.user) === null || _a === void 0 ? void 0 : _a.id })];
                        case 2:
                            channels = _d.sent();
                            this.pendingInvitesSubject.next(channels);
                            this.appSettingsSubject.next(undefined);
                            this.subscriptions.push(this.chatClient.on(function (e) {
                                _this.updateUser(e);
                                _this.updatePendingInvites(e);
                                _this.notificationSubject.next({
                                    eventType: e.type,
                                    event: e,
                                });
                            }));
                            this.subscriptions.push(this.chatClient.on('connection.changed', function (e) {
                                _this.ngZone.run(function () {
                                    var isOnline = e.online;
                                    if (isOnline) {
                                        if (removeNotification) {
                                            removeNotification();
                                        }
                                    }
                                    else {
                                        removeNotification =
                                            _this.notificationService.addPermanentNotification('streamChat.Connection failure, reconnecting now...');
                                    }
                                    _this.connectionStateSubject.next(isOnline ? 'online' : 'offline');
                                });
                            }));
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        /**
         * Disconnects the current user, and closes the WebSocket connection. Useful when disconnecting a chat user, use in combination with [`reset`](./ChannelService.mdx/#reset).
         */
        ChatClientService.prototype.disconnectUser = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            this.pendingInvitesSubject.next([]);
                            return [4 /*yield*/, this.chatClient.disconnectUser()];
                        case 1:
                            _d.sent();
                            this.userSubject.next(undefined);
                            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Loads the current [application settings](https://getstream.io/chat/docs/javascript/app_setting_overview/?language=javascript), if the application settings have already been loaded, it does nothing.
         */
        ChatClientService.prototype.getAppSettings = function () {
            return __awaiter(this, void 0, void 0, function () {
                var settings;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (this.appSettingsSubject.getValue()) {
                                return [2 /*return*/];
                            }
                            return [4 /*yield*/, this.chatClient.getAppSettings()];
                        case 1:
                            settings = _d.sent();
                            this.appSettingsSubject.next(settings.app || {});
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Flag the message with the given ID. If you want to know [more about flags](https://getstream.io/chat/docs/javascript/moderation/?language=javascript) check out the platform documentation.
         * @param messageId
         */
        ChatClientService.prototype.flagMessage = function (messageId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, this.chatClient.flagMessage(messageId)];
                        case 1:
                            _d.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Searches for users in the application that have ID or name matching the provided search term
         * @param searchTerm
         * @returns The users matching the search
         */
        ChatClientService.prototype.autocompleteUsers = function (searchTerm) {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (!searchTerm) {
                                return [2 /*return*/, []];
                            }
                            return [4 /*yield*/, this.chatClient.queryUsers({
                                    $or: [
                                        { id: { $autocomplete: searchTerm } },
                                        { name: { $autocomplete: searchTerm } },
                                    ],
                                    id: { $ne: this.chatClient.userID },
                                })];
                        case 1:
                            result = _d.sent();
                            return [2 /*return*/, result.users];
                    }
                });
            });
        };
        ChatClientService.prototype.updatePendingInvites = function (e) {
            var _a, _b, _c;
            if (((_b = (_a = e.member) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.id) === ((_c = this.chatClient.user) === null || _c === void 0 ? void 0 : _c.id) && e.channel) {
                var pendingInvites = this.pendingInvitesSubject.getValue();
                if (e.type === 'notification.invited') {
                    this.pendingInvitesSubject.next(__spreadArray(__spreadArray([], __read(pendingInvites)), [e.channel]));
                }
                else if (e.type === 'notification.invite_accepted' ||
                    e.type === 'notification.invite_rejected') {
                    var index = pendingInvites.findIndex(function (i) { var _a; return (i === null || i === void 0 ? void 0 : i.cid) === ((_a = e.channel) === null || _a === void 0 ? void 0 : _a.cid); });
                    if (index !== -1) {
                        pendingInvites.splice(index, 1);
                        this.pendingInvitesSubject.next(__spreadArray([], __read(pendingInvites)));
                    }
                }
            }
        };
        ChatClientService.prototype.updateUser = function (e) {
            var _a;
            if (typeof e.total_unread_count !== 'undefined') {
                var user_1;
                this.userSubject.pipe(operators.take(1)).subscribe(function (u) {
                    user_1 = u;
                });
                if (user_1 && user_1.total_unread_count !== e.total_unread_count) {
                    this.userSubject.next(Object.assign(Object.assign({}, user_1), { total_unread_count: e.total_unread_count }));
                }
            }
            if (typeof e.unread_channels !== 'undefined') {
                var user_2;
                this.userSubject.pipe(operators.take(1)).subscribe(function (u) {
                    user_2 = u;
                });
                if (user_2 && user_2.unread_channels !== e.unread_channels) {
                    this.userSubject.next(Object.assign(Object.assign({}, user_2), { unread_channels: e.unread_channels }));
                }
            }
            if (typeof e.unread_count !== 'undefined') {
                var user_3;
                this.userSubject.pipe(operators.take(1)).subscribe(function (u) {
                    user_3 = u;
                });
                if (user_3 && user_3.unread_count !== e.unread_count) {
                    this.userSubject.next(Object.assign(Object.assign({}, user_3), { unread_count: e.unread_count }));
                }
            }
            if (e.type === 'user.updated' &&
                this.chatClient.user &&
                ((_a = e.user) === null || _a === void 0 ? void 0 : _a.id) === this.chatClient.user.id) {
                this.userSubject.next(Object.assign({}, this.chatClient.user));
            }
        };
        return ChatClientService;
    }());
    ChatClientService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChatClientService, deps: [{ token: i0__namespace.NgZone }, { token: NotificationService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ChatClientService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChatClientService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChatClientService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.NgZone }, { type: NotificationService }]; } });

    var getMessageTranslation = function (message, channel, user) {
        var _a, _b;
        var language = (user === null || user === void 0 ? void 0 : user.language) ||
            ((_a = channel === null || channel === void 0 ? void 0 : channel.data) === null || _a === void 0 ? void 0 : _a.auto_translation_language);
        if (language && (message === null || message === void 0 ? void 0 : message.i18n) && ((_b = message === null || message === void 0 ? void 0 : message.user) === null || _b === void 0 ? void 0 : _b.id) !== (user === null || user === void 0 ? void 0 : user.id)) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            return message.i18n[language + "_text"];
        }
        else {
            return undefined;
        }
    };

    var createMessagePreview = function (user, text, attachments, mentionedUsers, parentId, quotedMessageId, customData) {
        if (attachments === void 0) { attachments = []; }
        if (mentionedUsers === void 0) { mentionedUsers = []; }
        if (parentId === void 0) { parentId = undefined; }
        if (quotedMessageId === void 0) { quotedMessageId = undefined; }
        var clientSideId = user.id + "-" + uuid.v4();
        return Object.assign({ __html: text, created_at: new Date(), html: text, id: clientSideId, reactions: [], status: 'sending', text: text, type: 'regular', user: user, attachments: attachments, mentioned_users: mentionedUsers, parent_id: parentId, quoted_message_id: quotedMessageId }, customData);
    };

    var getReadBy = function (message, channel) {
        var readBy = [];
        Object.keys(channel.state.read).forEach(function (key) {
            var _a;
            if (channel.state.read[key].last_read.getTime() >=
                message.created_at.getTime() &&
                ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) !== key) {
                readBy.push(channel.state.read[key].user);
            }
        });
        return readBy;
    };

    /**
     * The `ChannelService` provides data and interaction for the channel list and message list.
     */
    var ChannelService = /** @class */ (function () {
        function ChannelService(chatClientService, ngZone, notificationService) {
            var _this = this;
            this.chatClientService = chatClientService;
            this.ngZone = ngZone;
            this.notificationService = notificationService;
            this.channelsSubject = new rxjs.BehaviorSubject(undefined);
            this.activeChannelSubject = new rxjs.BehaviorSubject(undefined);
            this.activeChannelMessagesSubject = new rxjs.BehaviorSubject([]);
            this.activeChannelPinnedMessagesSubject = new rxjs.BehaviorSubject([]);
            this.hasMoreChannelsSubject = new rxjs.ReplaySubject(1);
            this.activeChannelSubscriptions = [];
            this.channelSubscriptions = {};
            this.activeParentMessageIdSubject = new rxjs.BehaviorSubject(undefined);
            this.activeThreadMessagesSubject = new rxjs.BehaviorSubject([]);
            this.jumpToMessageSubject = new rxjs.BehaviorSubject({ id: undefined, parentId: undefined });
            this.latestMessageDateByUserByChannelsSubject = new rxjs.BehaviorSubject({});
            this.messagePageSize = 25;
            this.messageToQuoteSubject = new rxjs.BehaviorSubject(undefined);
            this.usersTypingInChannelSubject = new rxjs.BehaviorSubject([]);
            this.usersTypingInThreadSubject = new rxjs.BehaviorSubject([]);
            this._shouldMarkActiveChannelAsRead = true;
            this.isStateRecoveryInProgress = false;
            this.channelQueryStateSubject = new rxjs.BehaviorSubject(undefined);
            this.channelListSetter = function (channels, shouldStopWatchingRemovedChannels) {
                if (shouldStopWatchingRemovedChannels === void 0) { shouldStopWatchingRemovedChannels = true; }
                var currentChannels = _this.channelsSubject.getValue() || [];
                var newChannels = channels.filter(function (c) { return !currentChannels.find(function (channel) { return channel.cid === c.cid; }); });
                var deletedChannels = currentChannels.filter(function (c) { return !(channels === null || channels === void 0 ? void 0 : channels.find(function (channel) { return channel.cid === c.cid; })); });
                void _this.addChannelsFromNotification(newChannels);
                _this.removeChannelsFromChannelList(deletedChannels.map(function (c) { return c.cid; }), shouldStopWatchingRemovedChannels);
            };
            this.messageListSetter = function (messages) {
                _this.activeChannelMessagesSubject.next(messages);
            };
            this.threadListSetter = function (messages) {
                _this.activeThreadMessagesSubject.next(messages);
            };
            this.parentMessageSetter = function (message) {
                _this.activeParentMessageIdSubject.next(message === null || message === void 0 ? void 0 : message.id);
            };
            this.areReadEventsPaused = false;
            this.channels$ = this.channelsSubject.asObservable().pipe(operators.shareReplay(1));
            this.activeChannel$ = this.activeChannelSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
            this.activeChannelMessages$ = this.activeChannelMessagesSubject.pipe(operators.map(function (messages) {
                var channel = _this.activeChannelSubject.getValue();
                return messages.map(function (message) { return _this.transformToStreamMessage(message, channel); });
            }), operators.shareReplay(1));
            this.bouncedMessage$ = new rxjs.BehaviorSubject(undefined);
            this.hasMoreChannels$ = this.hasMoreChannelsSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
            this.activeParentMessageId$ = this.activeParentMessageIdSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
            this.activeThreadMessages$ = this.activeThreadMessagesSubject.pipe(operators.map(function (messages) {
                var channel = _this.activeChannelSubject.getValue();
                return messages.map(function (message) { return _this.transformToStreamMessage(message, channel); });
            }), operators.shareReplay(1));
            this.activeParentMessage$ = rxjs.combineLatest([
                this.activeChannelMessages$,
                this.activeParentMessageId$,
            ]).pipe(operators.map(function (_h) {
                var _j = __read(_h, 2), messages = _j[0], parentMessageId = _j[1];
                if (!parentMessageId) {
                    return undefined;
                }
                else {
                    var message = messages.find(function (m) { return m.id === parentMessageId; });
                    if (!message) {
                        void _this.setAsActiveParentMessage(undefined);
                        return undefined;
                    }
                    else {
                        return message;
                    }
                }
            }), operators.shareReplay(1));
            this.messageToQuote$ = this.messageToQuoteSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
            this.jumpToMessage$ = this.jumpToMessageSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
            this.usersTypingInChannel$ = this.usersTypingInChannelSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
            this.usersTypingInThread$ = this.usersTypingInThreadSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
            this.latestMessageDateByUserByChannels$ =
                this.latestMessageDateByUserByChannelsSubject
                    .asObservable()
                    .pipe(operators.shareReplay(1));
            this.activeChannelPinnedMessages$ = this.activeChannelPinnedMessagesSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
            this.channelQueryState$ = this.channelQueryStateSubject
                .asObservable()
                .pipe(operators.shareReplay(1));
        }
        Object.defineProperty(ChannelService.prototype, "shouldMarkActiveChannelAsRead", {
            /**
             * If set to false, read events won't be sent as new messages are received. If set to true active channel (if any) will immediately be marked as read.
             */
            get: function () {
                return this._shouldMarkActiveChannelAsRead;
            },
            /**
             * If set to false, read events won't be sent as new messages are received. If set to true active channel (if any) will immediately be marked as read.
             */
            set: function (shouldMarkActiveChannelAsRead) {
                if (!this._shouldMarkActiveChannelAsRead && shouldMarkActiveChannelAsRead) {
                    var activeChannel = this.activeChannelSubject.getValue();
                    if (activeChannel && this.canSendReadEvents) {
                        void activeChannel.markRead();
                    }
                }
                this._shouldMarkActiveChannelAsRead = shouldMarkActiveChannelAsRead;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Sets the given `channel` as active and marks it as read.
         * If the channel wasn't previously part of the channel, it will be added to the beginning of the list.
         *
         * @param channel
         */
        ChannelService.prototype.setAsActiveChannel = function (channel) {
            var _a, _b;
            var prevActiveChannel = this.activeChannelSubject.getValue();
            if ((prevActiveChannel === null || prevActiveChannel === void 0 ? void 0 : prevActiveChannel.cid) === channel.cid) {
                return;
            }
            this.stopWatchForActiveChannelEvents(prevActiveChannel);
            this.areReadEventsPaused = false;
            var readState = channel.state.read[((_a = this.chatClientService.chatClient.user) === null || _a === void 0 ? void 0 : _a.id) || ''];
            this.activeChannelLastReadMessageId = readState === null || readState === void 0 ? void 0 : readState.last_read_message_id;
            if (((_b = channel.state.latestMessages[channel.state.latestMessages.length - 1]) === null || _b === void 0 ? void 0 : _b.id) === this.activeChannelLastReadMessageId) {
                this.activeChannelLastReadMessageId = undefined;
            }
            this.activeChannelUnreadCount = (readState === null || readState === void 0 ? void 0 : readState.unread_messages) || 0;
            this.watchForActiveChannelEvents(channel);
            this.addChannel(channel);
            this.activeChannelSubject.next(channel);
            var channelStateLength = channel.state.latestMessages.length;
            if (channelStateLength > 2 * this.messagePageSize) {
                channel.state.latestMessages = channel.state.latestMessages.slice(channelStateLength - 2 * this.messagePageSize);
            }
            this.setChannelState(channel);
        };
        /**
         * Deselects the currently active (if any) channel
         */
        ChannelService.prototype.deselectActiveChannel = function () {
            var activeChannel = this.activeChannelSubject.getValue();
            if (!activeChannel) {
                return;
            }
            this.stopWatchForActiveChannelEvents(activeChannel);
            this.activeChannelMessagesSubject.next([]);
            this.activeChannelSubject.next(undefined);
            this.activeParentMessageIdSubject.next(undefined);
            this.activeThreadMessagesSubject.next([]);
            this.latestMessageDateByUserByChannelsSubject.next({});
            this.selectMessageToQuote(undefined);
            this.jumpToMessageSubject.next({ id: undefined, parentId: undefined });
            this.activeChannelPinnedMessagesSubject.next([]);
            this.usersTypingInChannelSubject.next([]);
            this.usersTypingInThreadSubject.next([]);
            this.activeChannelLastReadMessageId = undefined;
            this.activeChannelUnreadCount = undefined;
            this.areReadEventsPaused = false;
        };
        /**
         * Sets the given `message` as an active parent message. If `undefined` is provided, it will deleselect the current parent message.
         * @param message
         * @param loadMessagesForm
         */
        ChannelService.prototype.setAsActiveParentMessage = function (message, loadMessagesForm) {
            if (loadMessagesForm === void 0) { loadMessagesForm = 'request'; }
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var messageToQuote, messageToJumpTo, activeChannel, result;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            messageToQuote = this.messageToQuoteSubject.getValue();
                            if (messageToQuote && !!messageToQuote.parent_id) {
                                this.messageToQuoteSubject.next(undefined);
                            }
                            if (!!message) return [3 /*break*/, 1];
                            this.activeParentMessageIdSubject.next(undefined);
                            this.activeThreadMessagesSubject.next([]);
                            messageToJumpTo = this.jumpToMessageSubject.getValue();
                            if (messageToJumpTo && !!messageToJumpTo.parentId) {
                                this.jumpToMessageSubject.next({ id: undefined, parentId: undefined });
                            }
                            return [3 /*break*/, 4];
                        case 1:
                            this.activeParentMessageIdSubject.next(message.id);
                            activeChannel = this.activeChannelSubject.getValue();
                            if (!(loadMessagesForm === 'request')) return [3 /*break*/, 3];
                            return [4 /*yield*/, (activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.getReplies(message.id, {
                                    limit: (_a = this.options) === null || _a === void 0 ? void 0 : _a.message_limit,
                                }))];
                        case 2:
                            result = _h.sent();
                            this.activeThreadMessagesSubject.next((result === null || result === void 0 ? void 0 : result.messages) || []);
                            return [3 /*break*/, 4];
                        case 3:
                            this.activeThreadMessagesSubject.next((activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.state.threads[message.id]) || []);
                            _h.label = 4;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Loads the next page of messages of the active channel. The page size can be set in the [query option](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript#query-options) object.
         * @param direction
         */
        ChannelService.prototype.loadMoreMessages = function (direction) {
            var _h;
            var _this = this;
            if (direction === void 0) { direction = 'older'; }
            var _a, _b, _c, _d;
            var activeChnannel = this.activeChannelSubject.getValue();
            var messages = this.activeChannelMessagesSubject.getValue();
            var lastMessageId = (_a = messages[direction === 'older' ? 0 : messages.length - 1]) === null || _a === void 0 ? void 0 : _a.id;
            if (direction === 'newer' &&
                ((_b = activeChnannel === null || activeChnannel === void 0 ? void 0 : activeChnannel.state) === null || _b === void 0 ? void 0 : _b.latestMessages) === ((_c = activeChnannel === null || activeChnannel === void 0 ? void 0 : activeChnannel.state) === null || _c === void 0 ? void 0 : _c.messages)) {
                // If we are on latest message set, activeChannelMessages$ will be refreshed by WS events, no need for a request
                return false;
            }
            return activeChnannel === null || activeChnannel === void 0 ? void 0 : activeChnannel.query({
                messages: (_h = {
                        limit: (_d = this.options) === null || _d === void 0 ? void 0 : _d.message_limit
                    },
                    _h[direction === 'older' ? 'id_lt' : 'id_gt'] = lastMessageId,
                    _h),
                members: { limit: 0 },
                watchers: { limit: 0 },
            }).then(function (res) {
                var _a, _b, _c;
                if (((_a = activeChnannel === null || activeChnannel === void 0 ? void 0 : activeChnannel.data) === null || _a === void 0 ? void 0 : _a.id) ===
                    ((_c = (_b = _this.activeChannelSubject.getValue()) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.id)) {
                    _this.activeChannelMessagesSubject.next(__spreadArray([], __read(activeChnannel.state.messages)));
                }
                return res;
            });
        };
        /**
         * Loads the next page of messages of the active thread. The page size can be set in the [query option](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript#query-options) object.
         * @param direction
         */
        ChannelService.prototype.loadMoreThreadReplies = function (direction) {
            if (direction === void 0) { direction = 'older'; }
            var _a, _b;
            return __awaiter(this, void 0, void 0, function () {
                var activeChnannel, parentMessageId, threadMessages, lastMessageId;
                var _h;
                return __generator(this, function (_j) {
                    switch (_j.label) {
                        case 0:
                            if (direction === 'newer') {
                                // Thread replies aren't broke into different message sets, activeThreadMessages$ will be refreshed by WS events, no need for a request
                                return [2 /*return*/];
                            }
                            activeChnannel = this.activeChannelSubject.getValue();
                            parentMessageId = this.activeParentMessageIdSubject.getValue();
                            if (!parentMessageId) {
                                return [2 /*return*/];
                            }
                            threadMessages = this.activeThreadMessagesSubject.getValue();
                            lastMessageId = (_a = threadMessages[direction === 'older' ? 0 : threadMessages.length - 1]) === null || _a === void 0 ? void 0 : _a.id;
                            return [4 /*yield*/, (activeChnannel === null || activeChnannel === void 0 ? void 0 : activeChnannel.getReplies(parentMessageId, (_h = {
                                        limit: (_b = this.options) === null || _b === void 0 ? void 0 : _b.message_limit
                                    },
                                    _h[direction === 'older' ? 'id_lt' : 'id_gt'] = lastMessageId,
                                    _h)))];
                        case 1:
                            _j.sent();
                            this.activeThreadMessagesSubject.next((activeChnannel === null || activeChnannel === void 0 ? void 0 : activeChnannel.state.threads[parentMessageId]) || []);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Queries the channels with the given filters, sorts and options. More info about [channel querying](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript) can be found in the platform documentation. By default the first channel in the list will be set as active channel and will be marked as read.
         * @param filters
         * @param sort
         * @param options
         * @param shouldSetActiveChannel Decides if the first channel in the result should be made as an active channel, or no channel should be marked as active
         * @returns the list of channels found by the query
         */
        ChannelService.prototype.init = function (filters, sort, options, shouldSetActiveChannel) {
            if (shouldSetActiveChannel === void 0) { shouldSetActiveChannel = true; }
            return __awaiter(this, void 0, void 0, function () {
                var result, error_1;
                var _this = this;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            this.filters = filters;
                            this.options = Object.assign({ limit: 25, state: true, presence: true, watch: true, message_limit: this.messagePageSize }, options);
                            this.sort = sort || { last_message_at: -1 };
                            this.shouldSetActiveChannel = shouldSetActiveChannel;
                            this.clientEventsSubscription = this.chatClientService.events$.subscribe(function (notification) { return void _this.handleNotification(notification); });
                            _h.label = 1;
                        case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.queryChannels(this.shouldSetActiveChannel)];
                        case 2:
                            result = _h.sent();
                            return [2 /*return*/, result];
                        case 3:
                            error_1 = _h.sent();
                            this.dismissErrorNotification =
                                this.notificationService.addPermanentNotification('streamChat.Error loading channels', 'error');
                            throw error_1;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Resets the `activeChannel$`, `channels$` and `activeChannelMessages$` Observables. Useful when disconnecting a chat user, use in combination with [`disconnectUser`](./ChatClientService.mdx/#disconnectuser).
         */
        ChannelService.prototype.reset = function () {
            var _this = this;
            var _a, _b;
            this.deselectActiveChannel();
            this.channelsSubject.next(undefined);
            this.channelQueryStateSubject.next(undefined);
            (_a = this.clientEventsSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            (_b = this.dismissErrorNotification) === null || _b === void 0 ? void 0 : _b.call(this);
            this.dismissErrorNotification = undefined;
            Object.keys(this.channelSubscriptions).forEach(function (cid) {
                _this.channelSubscriptions[cid]();
            });
            this.channelSubscriptions = {};
            this.nextPageConfiguration = undefined;
        };
        /**
         * Loads the next page of channels. The page size can be set in the [query option](https://getstream.io/chat/docs/javascript/query_channels/?language=javascript#query-options) object.
         */
        ChannelService.prototype.loadMoreChannels = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0: return [4 /*yield*/, this.queryChannels(false)];
                        case 1:
                            _h.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Adds a reaction to a message.
         * @param messageId The id of the message to add the reaction to
         * @param reactionType The type of the reaction
         * @param customData
         */
        ChannelService.prototype.addReaction = function (messageId, reactionType, customData) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0: return [4 /*yield*/, ((_a = this.activeChannelSubject.getValue()) === null || _a === void 0 ? void 0 : _a.sendReaction(messageId, Object.assign({ type: reactionType }, customData)))];
                        case 1:
                            _h.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Removes a reaction from a message.
         * @param messageId The id of the message to remove the reaction from
         * @param reactionType Thr type of reaction to remove
         */
        ChannelService.prototype.removeReaction = function (messageId, reactionType) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0: return [4 /*yield*/, ((_a = this.activeChannelSubject
                                .getValue()) === null || _a === void 0 ? void 0 : _a.deleteReaction(messageId, reactionType))];
                        case 1:
                            _h.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Sends a message to the active channel. The message is immediately added to the message list, if an error occurs and the message can't be sent, the error is indicated in `state` of the message.
         * @param text The text of the message
         * @param attachments The attachments
         * @param mentionedUsers Mentioned users
         * @param parentId Id of the parent message (if sending a thread reply)
         * @param quotedMessageId Id of the message to quote (if sending a quote reply)
         * @param customData
         */
        ChannelService.prototype.sendMessage = function (text, attachments, mentionedUsers, parentId, quotedMessageId, customData) {
            if (attachments === void 0) { attachments = []; }
            if (mentionedUsers === void 0) { mentionedUsers = []; }
            if (parentId === void 0) { parentId = undefined; }
            if (quotedMessageId === void 0) { quotedMessageId = undefined; }
            if (customData === void 0) { customData = undefined; }
            return __awaiter(this, void 0, void 0, function () {
                var input, preview, channel, response;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            input = {
                                text: text,
                                attachments: attachments,
                                mentionedUsers: mentionedUsers,
                                parentId: parentId,
                                quotedMessageId: quotedMessageId,
                                customData: customData,
                            };
                            if (!this.beforeSendMessage) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.beforeSendMessage(input)];
                        case 1:
                            input = _h.sent();
                            _h.label = 2;
                        case 2:
                            preview = createMessagePreview(this.chatClientService.chatClient.user, input.text, input.attachments, input.mentionedUsers, input.parentId, input.quotedMessageId, input.customData);
                            channel = this.activeChannelSubject.getValue();
                            preview.readBy = [];
                            channel.state.addMessageSorted(preview, true);
                            return [4 /*yield*/, this.sendMessageRequest(preview, input.customData)];
                        case 3:
                            response = _h.sent();
                            return [2 /*return*/, response];
                    }
                });
            });
        };
        /**
         * Resends the given message to the active channel
         * @param message The message to resend
         */
        ChannelService.prototype.resendMessage = function (message) {
            return __awaiter(this, void 0, void 0, function () {
                var channel;
                return __generator(this, function (_h) {
                    channel = this.activeChannelSubject.getValue();
                    channel.state.addMessageSorted(Object.assign(Object.assign({}, message), { errorStatusCode: undefined, status: 'sending' }), true);
                    return [2 /*return*/, this.sendMessageRequest(message, undefined, true)];
                });
            });
        };
        /**
         * Updates the message in the active channel
         * @param message Mesage to be updated
         */
        ChannelService.prototype.updateMessage = function (message) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var messageToUpdate, response, channel;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            messageToUpdate = Object.assign({}, message);
                            delete messageToUpdate.i18n;
                            if (!this.beforeUpdateMessage) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.beforeUpdateMessage(messageToUpdate)];
                        case 1:
                            messageToUpdate = _h.sent();
                            _h.label = 2;
                        case 2:
                            if (message.moderation_details) {
                                return [2 /*return*/, this.resendMessage(message)];
                            }
                            return [4 /*yield*/, this.chatClientService.chatClient.updateMessage(messageToUpdate)];
                        case 3:
                            response = _h.sent();
                            channel = (_a = this.channelsSubject
                                .getValue()) === null || _a === void 0 ? void 0 : _a.find(function (c) { return c.cid === message.cid; });
                            if (response.message.type === 'error' &&
                                response.message.moderation_details) {
                                this.notificationService.addTemporaryNotification('streamChat.This message did not meet our content guidelines');
                                return [2 /*return*/, message];
                            }
                            return [2 /*return*/, this.transformToStreamMessage(response.message, channel)];
                    }
                });
            });
        };
        /**
         * Deletes the message from the active channel
         * @param message Message to be deleted
         * @param isLocalDelete set this `true` if you want to delete a message that's only part of the local state, not yet saved on the backend
         */
        ChannelService.prototype.deleteMessage = function (message, isLocalDelete) {
            if (isLocalDelete === void 0) { isLocalDelete = false; }
            return __awaiter(this, void 0, void 0, function () {
                var result, result;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            if (isLocalDelete && this.activeChannel) {
                                result = this.activeChannel.state.removeMessage({
                                    id: message.id,
                                    parent_id: message.parent_id,
                                });
                                if (result) {
                                    message.parent_id
                                        ? this.activeThreadMessagesSubject.next(this.activeChannel.state.threads[message.parent_id])
                                        : this.activeChannelMessagesSubject.next(this.activeChannel.state.messages);
                                }
                                return [2 /*return*/];
                            }
                            if (!this.messageDeleteConfirmationHandler) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.messageDeleteConfirmationHandler(message)];
                        case 1:
                            result = _h.sent();
                            if (!result) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.chatClientService.chatClient.deleteMessage(message.id)];
                        case 2:
                            _h.sent();
                            _h.label = 3;
                        case 3: return [3 /*break*/, 6];
                        case 4: return [4 /*yield*/, this.chatClientService.chatClient.deleteMessage(message.id)];
                        case 5:
                            _h.sent();
                            _h.label = 6;
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Uploads files to the channel. If you want to know more about [file uploads](https://getstream.io/chat/docs/javascript/file_uploads/?language=javascript) check out the platform documentation.
         * @param uploads the attachments to upload (output of the [`AttachmentService`](./AttachmentService.mdx))
         * @returns the result of file upload requests
         */
        ChannelService.prototype.uploadAttachments = function (uploads) {
            return __awaiter(this, void 0, void 0, function () {
                var result, channel, uploadResults;
                var _this = this;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            result = [];
                            channel = this.activeChannelSubject.getValue();
                            return [4 /*yield*/, Promise.allSettled(uploads.map(function (upload) { return upload.type === 'image'
                                    ? _this.customImageUploadRequest
                                        ? _this.customImageUploadRequest(upload.file, channel)
                                        : channel.sendImage(upload.file, upload.file.name, upload.file.type)
                                    : _this.customFileUploadRequest
                                        ? _this.customFileUploadRequest(upload.file, channel)
                                        : channel.sendFile(upload.file, upload.file.name, upload.file.type); }))];
                        case 1:
                            uploadResults = _h.sent();
                            uploadResults.forEach(function (uploadResult, i) {
                                var _a, _b, _c, _d, _e, _f, _g;
                                var file = uploads[i].file;
                                var type = uploads[i].type;
                                if (uploadResult.status === 'fulfilled') {
                                    result.push({
                                        file: file,
                                        type: type,
                                        state: 'success',
                                        url: uploadResult.value.file,
                                        /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */
                                        thumb_url: uploadResult.value.thumb_url,
                                    });
                                }
                                else {
                                    var reason = 'unknown';
                                    var extraData = void 0;
                                    /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment */
                                    var message = 
                                    /* eslint-disable-next-line @typescript-eslint/no-unsafe-member-access */
                                    (_b = (_a = uploadResult.reason.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message;
                                    /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment */
                                    var code = 
                                    /* eslint-disable-next-line @typescript-eslint/no-unsafe-member-access */
                                    (_d = (_c = uploadResult.reason.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.code;
                                    if (code === 22) {
                                        reason = 'file-size';
                                        extraData = { param: ((_e = /\d+MB/.exec(message || '')) === null || _e === void 0 ? void 0 : _e[0]) || '100MB' };
                                    }
                                    else if (code === 4 &&
                                        ((_f = message === null || message === void 0 ? void 0 : message.toLowerCase()) === null || _f === void 0 ? void 0 : _f.includes('file extension'))) {
                                        reason = 'file-extension';
                                        extraData = { param: ((_g = /\.\w+/.exec(message)) === null || _g === void 0 ? void 0 : _g[0]) || '' };
                                    }
                                    result.push({
                                        file: file,
                                        type: type,
                                        state: 'error',
                                        errorReason: reason,
                                        errorExtraInfo: extraData ? [extraData] : undefined,
                                    });
                                }
                            });
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        /**
         * Deletes an uploaded file by URL. If you want to know more about [file uploads](https://getstream.io/chat/docs/javascript/file_uploads/?language=javascript) check out the platform documentation
         * @param attachmentUpload Attachment to be deleted (output of the [`AttachmentService`](./AttachmentService.mdx))
         */
        ChannelService.prototype.deleteAttachment = function (attachmentUpload) {
            return __awaiter(this, void 0, void 0, function () {
                var channel;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            channel = this.activeChannelSubject.getValue();
                            return [4 /*yield*/, (attachmentUpload.type === 'image'
                                    ? this.customImageDeleteRequest
                                        ? this.customImageDeleteRequest(attachmentUpload.url, channel)
                                        : channel.deleteImage(attachmentUpload.url)
                                    : this.customFileDeleteRequest
                                        ? this.customFileDeleteRequest(attachmentUpload.url, channel)
                                        : channel.deleteFile(attachmentUpload.url))];
                        case 1:
                            _h.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Returns the autocomplete options for current channel members. If the channel has less than 100 members, it returns the channel members, otherwise sends a [search request](https://getstream.io/chat/docs/javascript/query_members/?language=javascript#pagination-and-ordering) with the given search term.
         * @param searchTerm Text to search for in the names of members
         * @returns The list of members matching the search filter
         */
        ChannelService.prototype.autocompleteMembers = function (searchTerm) {
            return __awaiter(this, void 0, void 0, function () {
                var activeChannel, result;
                var _this = this;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            activeChannel = this.activeChannelSubject.getValue();
                            if (!activeChannel) {
                                return [2 /*return*/, []];
                            }
                            if (!(Object.keys(activeChannel.state.members).length < 100)) return [3 /*break*/, 1];
                            return [2 /*return*/, Object.values(activeChannel.state.members).filter(function (m) { var _a; return ((_a = m.user) === null || _a === void 0 ? void 0 : _a.id) !== _this.chatClientService.chatClient.userID; })];
                        case 1:
                            if (!searchTerm) {
                                return [2 /*return*/, []];
                            }
                            return [4 /*yield*/, activeChannel.queryMembers({
                                    name: { $autocomplete: searchTerm },
                                    id: { $ne: this.chatClientService.chatClient.userID },
                                })];
                        case 2:
                            result = _h.sent();
                            return [2 /*return*/, Object.values(result.members)];
                    }
                });
            });
        };
        /**
         * [Runs a message action](https://getstream.io/chat/docs/rest/#messages-runmessageaction) in the current channel. Updates the message list based on the action result (if no message is returned, the message will be removed from the message list).
         * @param messageId
         * @param formData
         * @param parentMessageId
         */
        ChannelService.prototype.sendAction = function (messageId, formData, parentMessageId) {
            return __awaiter(this, void 0, void 0, function () {
                var channel, response, isThreadReply;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            channel = this.activeChannelSubject.getValue();
                            return [4 /*yield*/, channel.sendAction(messageId, formData)];
                        case 1:
                            response = _h.sent();
                            if (response === null || response === void 0 ? void 0 : response.message) {
                                channel.state.addMessageSorted(Object.assign(Object.assign({}, response.message), { status: 'received' }));
                                isThreadReply = !!response.message.parent_id;
                                isThreadReply
                                    ? this.activeThreadMessagesSubject.next(__spreadArray([], __read(channel.state.threads[response.message.parent_id])))
                                    : this.activeChannelMessagesSubject.next(__spreadArray([], __read(channel.state.messages)));
                            }
                            else {
                                channel.state.removeMessage({
                                    id: messageId,
                                    parent_id: parentMessageId,
                                });
                                if (parentMessageId) {
                                    this.activeThreadMessagesSubject.next(channel.state.threads[this.activeParentMessageIdSubject.getValue()]);
                                }
                                else {
                                    this.activeChannelMessagesSubject.next(__spreadArray([], __read(channel.state.messages)));
                                }
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Selects or deselects the current message to quote reply to
         * @param message The message to select, if called with `undefined`, it deselects the message
         */
        ChannelService.prototype.selectMessageToQuote = function (message) {
            this.messageToQuoteSubject.next(message);
        };
        /**
         * Add a new channel to the channel list
         * The channel will be added to the beginning of the channel list
         * @param channel
         */
        ChannelService.prototype.addChannel = function (channel) {
            if (!this.channels.find(function (c) { return c.cid === channel.cid; })) {
                this.channelsSubject.next(__spreadArray([channel], __read(this.channels)));
                this.watchForChannelEvents(channel);
            }
        };
        ChannelService.prototype.sendMessageRequest = function (preview, customData, isResend) {
            if (isResend === void 0) { isResend = false; }
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function () {
                var channel, isThreadReply, response, messages_1, newMessage, error_2, stringError, parsedError, isAlreadyExists, messages_2, newMessage;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            channel = this.activeChannelSubject.getValue();
                            isThreadReply = !!preview.parent_id;
                            isThreadReply
                                ? this.activeThreadMessagesSubject.next(__spreadArray([], __read(channel.state.threads[preview.parent_id])))
                                : this.activeChannelMessagesSubject.next(__spreadArray([], __read(channel.state.messages)));
                            _h.label = 1;
                        case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, channel.sendMessage(Object.assign({ id: preview.id, text: preview.text, attachments: preview.attachments, mentioned_users: (_a = preview.mentioned_users) === null || _a === void 0 ? void 0 : _a.map(function (u) { return u.id; }), parent_id: preview.parent_id, quoted_message_id: preview.quoted_message_id }, customData))];
                        case 2:
                            response = _h.sent();
                            channel.state.addMessageSorted(Object.assign(Object.assign({}, response.message), { status: 'received' }), true);
                            isThreadReply
                                ? this.activeThreadMessagesSubject.next(__spreadArray([], __read(channel.state.threads[preview.parent_id])))
                                : this.activeChannelMessagesSubject.next(__spreadArray([], __read(channel.state.messages)));
                            (isThreadReply ? this.activeThreadMessages$ : this.activeChannelMessages$)
                                .pipe(operators.take(1))
                                .subscribe(function (m) { return (messages_1 = m); });
                            newMessage = messages_1[messages_1.length - 1];
                            return [2 /*return*/, newMessage];
                        case 3:
                            error_2 = _h.sent();
                            stringError = JSON.stringify(error_2);
                            parsedError = stringError ? JSON.parse(stringError) : {};
                            isAlreadyExists = false;
                            if (isResend) {
                                if (parsedError.status === 400 &&
                                    parsedError.code === 4 &&
                                    ((_d = (_c = (_b = parsedError === null || parsedError === void 0 ? void 0 : parsedError.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.message) === null || _d === void 0 ? void 0 : _d.includes('already exists'))) {
                                    isAlreadyExists = true;
                                }
                            }
                            channel.state.addMessageSorted(Object.assign(Object.assign({}, preview), { errorStatusCode: isAlreadyExists
                                    ? undefined
                                    : parsedError.status || undefined, status: isAlreadyExists ? 'received' : 'failed' }), true);
                            isThreadReply
                                ? this.activeThreadMessagesSubject.next(__spreadArray([], __read(channel.state.threads[preview.parent_id])))
                                : this.activeChannelMessagesSubject.next(__spreadArray([], __read(channel.state.messages)));
                            (isThreadReply ? this.activeThreadMessages$ : this.activeChannelMessages$)
                                .pipe(operators.take(1))
                                .subscribe(function (m) { return (messages_2 = m); });
                            newMessage = messages_2[messages_2.length - 1];
                            return [2 /*return*/, newMessage];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Jumps to the selected message inside the message list, if the message is not yet loaded, it'll load the message (and it's surroundings) from the API.
         * @param messageId The ID of the message to be loaded, 'latest' means jump to the latest messages
         * @param parentMessageId The ID of the parent message if we want to load a thread message
         */
        ChannelService.prototype.jumpToMessage = function (messageId, parentMessageId) {
            return __awaiter(this, void 0, void 0, function () {
                var activeChannel, messages, parentMessage, error_3;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            activeChannel = this.activeChannelSubject.getValue();
                            _h.label = 1;
                        case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, (activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.state.loadMessageIntoState(messageId, parentMessageId))];
                        case 2:
                            _h.sent();
                            messages = (activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.state.messages) || [];
                            this.activeChannelMessagesSubject.next(__spreadArray([], __read(messages)));
                            if (parentMessageId) {
                                parentMessage = messages.find(function (m) { return m.id === parentMessageId; });
                                void this.setAsActiveParentMessage(parentMessage, 'state');
                            }
                            this.jumpToMessageSubject.next({
                                id: messageId,
                                parentId: parentMessageId,
                            });
                            return [3 /*break*/, 4];
                        case 3:
                            error_3 = _h.sent();
                            this.notificationService.addTemporaryNotification('streamChat.Message not found');
                            throw error_3;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Pins the given message in the channel
         * @param message
         */
        ChannelService.prototype.pinMessage = function (message) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var error_4;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            _h.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, ((_a = this.chatClientService.chatClient) === null || _a === void 0 ? void 0 : _a.pinMessage(message))];
                        case 1:
                            _h.sent();
                            this.notificationService.addTemporaryNotification('streamChat.Message pinned', 'success');
                            return [3 /*break*/, 3];
                        case 2:
                            error_4 = _h.sent();
                            this.notificationService.addTemporaryNotification('streamChat.Error pinning message');
                            throw error_4;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Removes the given message from pinned messages
         * @param message
         */
        ChannelService.prototype.unpinMessage = function (message) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var error_5;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            _h.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, ((_a = this.chatClientService.chatClient) === null || _a === void 0 ? void 0 : _a.unpinMessage(message))];
                        case 1:
                            _h.sent();
                            this.notificationService.addTemporaryNotification('streamChat.Message unpinned', 'success');
                            return [3 /*break*/, 3];
                        case 2:
                            error_5 = _h.sent();
                            this.notificationService.addTemporaryNotification('streamChat.Error removing message pin');
                            throw error_5;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        ChannelService.prototype.handleNotification = function (clientEvent) {
            var _this = this;
            switch (clientEvent.eventType) {
                case 'connection.recovered': {
                    void this.ngZone.run(function () { return __awaiter(_this, void 0, void 0, function () {
                        var shoulSetActiveChannel, messageToQuote_1, messages_3, updatedMessageToQuote, _a_1;
                        return __generator(this, function (_h) {
                            switch (_h.label) {
                                case 0:
                                    if (this.isStateRecoveryInProgress) {
                                        return [2 /*return*/];
                                    }
                                    this.isStateRecoveryInProgress = true;
                                    _h.label = 1;
                                case 1:
                                    _h.trys.push([1, 3, , 4]);
                                    this.nextPageConfiguration = undefined;
                                    shoulSetActiveChannel = this.shouldSetActiveChannel &&
                                        !this.activeChannelSubject.getValue();
                                    return [4 /*yield*/, this.queryChannels(shoulSetActiveChannel || false, true)];
                                case 2:
                                    _h.sent();
                                    if (this.activeChannelSubject.getValue()) {
                                        // Thread messages are not refetched so active thread gets deselected to avoid displaying stale messages
                                        void this.setAsActiveParentMessage(undefined);
                                        messageToQuote_1 = this.messageToQuoteSubject.getValue();
                                        this.setChannelState(this.activeChannelSubject.getValue());
                                        this.activeChannelMessages$
                                            .pipe(operators.take(1))
                                            .subscribe(function (m) { return (messages_3 = m); });
                                        updatedMessageToQuote = messages_3.find(function (m) { return m.id === (messageToQuote_1 === null || messageToQuote_1 === void 0 ? void 0 : messageToQuote_1.id); });
                                        if (updatedMessageToQuote) {
                                            this.selectMessageToQuote(updatedMessageToQuote);
                                        }
                                    }
                                    this.isStateRecoveryInProgress = false;
                                    return [3 /*break*/, 4];
                                case 3:
                                    _a_1 = _h.sent();
                                    this.isStateRecoveryInProgress = false;
                                    return [3 /*break*/, 4];
                                case 4: return [2 /*return*/];
                            }
                        });
                    }); });
                    break;
                }
                case 'notification.message_new': {
                    this.ngZone.run(function () {
                        if (_this.customNewMessageNotificationHandler) {
                            _this.customNewMessageNotificationHandler(clientEvent, _this.channelListSetter);
                        }
                        else {
                            _this.handleNewMessageNotification(clientEvent);
                        }
                    });
                    break;
                }
                case 'notification.added_to_channel': {
                    this.ngZone.run(function () {
                        if (_this.customAddedToChannelNotificationHandler) {
                            _this.customAddedToChannelNotificationHandler(clientEvent, _this.channelListSetter);
                        }
                        else {
                            _this.handleAddedToChannelNotification(clientEvent);
                        }
                    });
                    break;
                }
                case 'notification.removed_from_channel': {
                    this.ngZone.run(function () {
                        if (_this.customRemovedFromChannelNotificationHandler) {
                            _this.customRemovedFromChannelNotificationHandler(clientEvent, _this.channelListSetter);
                        }
                        else {
                            _this.handleRemovedFromChannelNotification(clientEvent);
                        }
                    });
                    break;
                }
                case 'user.updated': {
                    this.ngZone.run(function () {
                        var _a;
                        var updatedChannels = (_a = _this.channelsSubject.getValue()) === null || _a === void 0 ? void 0 : _a.map(function (c) {
                            if (_this.chatClientService.chatClient.activeChannels[c.cid]) {
                                return _this.chatClientService.chatClient.activeChannels[c.cid];
                            }
                            else {
                                return c;
                            }
                        });
                        _this.channelsSubject.next(updatedChannels);
                        var activeChannel = _this.activeChannelSubject.getValue();
                        if (activeChannel) {
                            _this.activeChannelSubject.next(_this.chatClientService.chatClient.activeChannels[activeChannel.cid] || activeChannel);
                            _this.activeChannelMessagesSubject.next(activeChannel.state.messages.map(function (m) {
                                m.readBy = getReadBy(m, activeChannel);
                                return Object.assign({}, m);
                            }));
                            var activeParentMessage = _this.activeParentMessageIdSubject.getValue();
                            if (activeParentMessage) {
                                var messages = activeChannel.state.threads[activeParentMessage];
                                _this.activeThreadMessagesSubject.next(__spreadArray([], __read(messages)));
                            }
                            _this.activeChannelPinnedMessagesSubject.next(__spreadArray([], __read(activeChannel.state.pinnedMessages)));
                        }
                    });
                    break;
                }
            }
        };
        ChannelService.prototype.handleRemovedFromChannelNotification = function (clientEvent) {
            var channelIdToBeRemoved = clientEvent.event.channel.cid;
            this.removeChannelsFromChannelList([channelIdToBeRemoved], true);
        };
        ChannelService.prototype.handleNewMessageNotification = function (clientEvent) {
            if (clientEvent.event.channel) {
                void this.addChannelsFromNotification([clientEvent.event.channel]);
            }
        };
        ChannelService.prototype.handleAddedToChannelNotification = function (clientEvent) {
            if (clientEvent.event.channel) {
                void this.addChannelsFromNotification([clientEvent.event.channel]);
            }
        };
        ChannelService.prototype.addChannelsFromNotification = function (channelResponses) {
            return __awaiter(this, void 0, void 0, function () {
                var newChannels, watchRequests, currentChannels;
                var _this = this;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            newChannels = [];
                            watchRequests = [];
                            channelResponses.forEach(function (channelResponse) {
                                var channel = _this.chatClientService.chatClient.channel(channelResponse.type, channelResponse.id);
                                watchRequests.push(channel.watch());
                                newChannels.push(channel);
                            });
                            return [4 /*yield*/, Promise.all(watchRequests)];
                        case 1:
                            _h.sent();
                            currentChannels = this.channelsSubject.getValue() || [];
                            newChannels = newChannels.filter(function (newChannel) { return !currentChannels.find(function (c) { return c.cid === newChannel.cid; }); });
                            if (newChannels.length > 0) {
                                newChannels.forEach(function (c) { return _this.watchForChannelEvents(c); });
                                this.channelsSubject.next(__spreadArray(__spreadArray([], __read(newChannels)), __read(currentChannels)));
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        ChannelService.prototype.removeChannelsFromChannelList = function (cids, shouldStopWatching) {
            var _this = this;
            var _a;
            var channels = this.channels.filter(function (c) { return !cids.includes(c.cid || ''); });
            if (shouldStopWatching) {
                cids.forEach(function (cid) {
                    var _a;
                    if (_this.channelSubscriptions[cid]) {
                        _this.channelSubscriptions[cid]();
                        delete _this.channelSubscriptions.cid;
                    }
                    void ((_a = _this.chatClientService.chatClient.activeChannels[cid]) === null || _a === void 0 ? void 0 : _a.stopWatching());
                });
            }
            if (channels.length < this.channels.length) {
                this.channelsSubject.next(channels);
                if (cids.includes(((_a = this.activeChannelSubject.getValue()) === null || _a === void 0 ? void 0 : _a.cid) || '')) {
                    if (channels.length > 0) {
                        this.setAsActiveChannel(channels[0]);
                    }
                    else {
                        this.activeChannelSubject.next(undefined);
                    }
                }
            }
        };
        ChannelService.prototype.watchForActiveChannelEvents = function (channel) {
            var _this = this;
            this.activeChannelSubscriptions.push(channel.on('message.new', function (event) {
                _this.ngZone.run(function () {
                    event.message && event.message.parent_id
                        ? event.message.parent_id ===
                            _this.activeParentMessageIdSubject.getValue()
                            ? _this.activeThreadMessagesSubject.next(__spreadArray([], __read(channel.state.threads[event.message.parent_id])))
                            : null
                        : _this.activeChannelMessagesSubject.next(__spreadArray([], __read(channel.state.messages)));
                    _this.activeChannel$.pipe(operators.first()).subscribe(function (c) {
                        if (c) {
                            _this.markRead(c);
                        }
                    });
                    _this.updateLatestMessages(event);
                });
            }));
            this.activeChannelSubscriptions.push(channel.on('message.updated', function (event) { return _this.messageUpdated(event); }));
            this.activeChannelSubscriptions.push(channel.on('message.deleted', function (event) { return _this.messageUpdated(event); }));
            this.activeChannelSubscriptions.push(channel.on('reaction.new', function (e) { return _this.messageReactionEventReceived(e); }));
            this.activeChannelSubscriptions.push(channel.on('reaction.deleted', function (e) { return _this.messageReactionEventReceived(e); }));
            this.activeChannelSubscriptions.push(channel.on('reaction.updated', function (e) { return _this.messageReactionEventReceived(e); }));
            this.activeChannelSubscriptions.push(channel.on('message.read', function (e) {
                _this.ngZone.run(function () {
                    var _h;
                    var latestMessage;
                    var messages;
                    _this.activeChannelMessages$.pipe(operators.first()).subscribe(function (m) {
                        messages = m;
                        latestMessage = messages[messages.length - 1];
                    });
                    if (!latestMessage || !e.user) {
                        return;
                    }
                    if (latestMessage.readBy) {
                        latestMessage.readBy.splice(0, latestMessage.readBy.length);
                    }
                    else {
                        latestMessage.readBy = [];
                    }
                    (_h = latestMessage.readBy).push.apply(_h, __spreadArray([], __read(getReadBy(latestMessage, channel))));
                    messages[messages.length - 1] = Object.assign({}, latestMessage);
                    _this.activeChannelMessagesSubject.next(__spreadArray([], __read(messages)));
                });
            }));
            this.activeChannelSubscriptions.push(this.chatClientService.events$
                .pipe(operators.filter(function (e) { return e.eventType === 'notification.mark_unread' &&
                e.event.channel_id === channel.id; }), operators.map(function (e) { return e.event; }))
                .subscribe(function (e) {
                _this.ngZone.run(function () {
                    _this.activeChannelLastReadMessageId = e.last_read_message_id;
                    _this.activeChannelUnreadCount = e.unread_messages;
                    _this.activeChannelSubject.next(_this.activeChannel);
                });
            }));
            this.activeChannelSubscriptions.push(channel.on('typing.start', function (e) { return _this.ngZone.run(function () { return _this.handleTypingStartEvent(e); }); }));
            this.activeChannelSubscriptions.push(channel.on('typing.stop', function (e) { return _this.ngZone.run(function () { return _this.handleTypingStopEvent(e); }); }));
        };
        /**
         * Call this method if user started typing in the active channel
         * @param parentId The id of the parent message, if user is typing in a thread
         */
        ChannelService.prototype.typingStarted = function (parentId) {
            return __awaiter(this, void 0, void 0, function () {
                var activeChannel;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            activeChannel = this.activeChannelSubject.getValue();
                            return [4 /*yield*/, (activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.keystroke(parentId))];
                        case 1:
                            _h.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Call this method if user stopped typing in the active channel
         * @param parentId The id of the parent message, if user were typing in a thread
         */
        ChannelService.prototype.typingStopped = function (parentId) {
            return __awaiter(this, void 0, void 0, function () {
                var activeChannel;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            activeChannel = this.activeChannelSubject.getValue();
                            return [4 /*yield*/, (activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.stopTyping(parentId))];
                        case 1:
                            _h.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        Object.defineProperty(ChannelService.prototype, "channels", {
            /**
             * The current list of channels
             */
            get: function () {
                return this.channelsSubject.getValue() || [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChannelService.prototype, "activeChannel", {
            /**
             * The current active channel
             */
            get: function () {
                return this.activeChannelSubject.getValue() || undefined;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChannelService.prototype, "activeChannelMessages", {
            /**
             * The current active channel messages
             */
            get: function () {
                return this.activeChannelMessagesSubject.getValue() || [];
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Get the last 1200 reactions of a message in the current active channel. If you need to fetch more reactions please use the [following endpoint](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript#paginating-reactions).
         * @param messageId
         * @returns all reactions of a message
         */
        ChannelService.prototype.getMessageReactions = function (messageId) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function () {
                var reactions, limit, offset, reactionsLimit, lastPageSize, response, e_1;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            reactions = [];
                            limit = 300;
                            offset = 0;
                            reactionsLimit = ChannelService.MAX_MESSAGE_REACTIONS_TO_FETCH;
                            lastPageSize = limit;
                            _h.label = 1;
                        case 1:
                            if (!(lastPageSize === limit && reactions.length < reactionsLimit)) return [3 /*break*/, 6];
                            _h.label = 2;
                        case 2:
                            _h.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, ((_a = this.activeChannel) === null || _a === void 0 ? void 0 : _a.getReactions(messageId, {
                                    offset: offset,
                                    limit: limit,
                                }))];
                        case 3:
                            response = _h.sent();
                            lastPageSize = ((_b = response === null || response === void 0 ? void 0 : response.reactions) === null || _b === void 0 ? void 0 : _b.length) || 0;
                            if (lastPageSize > 0) {
                                reactions.push.apply(reactions, __spreadArray([], __read(response.reactions)));
                            }
                            offset += lastPageSize;
                            return [3 /*break*/, 5];
                        case 4:
                            e_1 = _h.sent();
                            this.notificationService.addTemporaryNotification('streamChat.Error loading reactions');
                            throw e_1;
                        case 5: return [3 /*break*/, 1];
                        case 6: return [2 /*return*/, reactions];
                    }
                });
            });
        };
        /**
         * Marks the channel from the given message as unread
         * @param messageId
         * @returns the result of the request
         */
        ChannelService.prototype.markMessageUnread = function (messageId) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function () {
                var response, e_2, error, data, count;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            if (!this.activeChannel) {
                                return [2 /*return*/];
                            }
                            _h.label = 1;
                        case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.activeChannel.markUnread({
                                    message_id: messageId,
                                })];
                        case 2:
                            response = _h.sent();
                            this.areReadEventsPaused = true;
                            return [2 /*return*/, response];
                        case 3:
                            e_2 = _h.sent();
                            error = JSON.parse(JSON.stringify(e_2));
                            data = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data;
                            if (data &&
                                data.code === 4 &&
                                data.StatusCode === 400 &&
                                ((_b = data.message) === null || _b === void 0 ? void 0 : _b.includes('it is older than last'))) {
                                count = (_d = (_c = /\d+ channel messages/
                                    .exec(data.message)) === null || _c === void 0 ? void 0 : _c[0].match(/\d+/)) === null || _d === void 0 ? void 0 : _d[0];
                                if (count) {
                                    this.notificationService.addTemporaryNotification('streamChat.Error, only the first {{count}} message can be marked as unread', undefined, undefined, { count: count });
                                    throw e_2;
                                }
                            }
                            this.notificationService.addTemporaryNotification('streamChat.Error marking message as unread');
                            throw e_2;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        ChannelService.prototype.messageUpdated = function (event) {
            var _this = this;
            this.ngZone.run(function () {
                var _a;
                var isThreadReply = event.message && event.message.parent_id;
                var channel = _this.activeChannelSubject.getValue();
                if (!channel) {
                    return;
                }
                // Get messages from state as message order could change, and message could've been deleted
                var messages = isThreadReply
                    ? channel.state.threads[((_a = event === null || event === void 0 ? void 0 : event.message) === null || _a === void 0 ? void 0 : _a.parent_id) || '']
                    : channel.state.messages;
                if (!messages) {
                    return;
                }
                var messageIndex = messages.findIndex(function (m) { var _a; return m.id === ((_a = event === null || event === void 0 ? void 0 : event.message) === null || _a === void 0 ? void 0 : _a.id); });
                if (messageIndex !== -1) {
                    isThreadReply
                        ? _this.activeThreadMessagesSubject.next(__spreadArray([], __read(messages)))
                        : _this.activeChannelMessagesSubject.next(__spreadArray([], __read(messages)));
                    _this.activeChannelPinnedMessagesSubject.next(__spreadArray([], __read(channel.state.pinnedMessages)));
                }
            });
        };
        ChannelService.prototype.messageReactionEventReceived = function (e) {
            var _this = this;
            this.ngZone.run(function () {
                var _a, _b, _c, _d;
                var isThreadMessage = e.message && e.message.parent_id;
                var messages;
                (isThreadMessage
                    ? _this.activeThreadMessages$
                    : _this.activeChannelMessages$)
                    .pipe(operators.first())
                    .subscribe(function (m) { return (messages = m); });
                var messageIndex = messages.findIndex(function (m) { var _a; return m.id === ((_a = e === null || e === void 0 ? void 0 : e.message) === null || _a === void 0 ? void 0 : _a.id); });
                if (messageIndex === -1) {
                    return;
                }
                var message = messages[messageIndex];
                message.reaction_counts = Object.assign({}, (_a = e.message) === null || _a === void 0 ? void 0 : _a.reaction_counts);
                message.reaction_scores = Object.assign({}, (_b = e.message) === null || _b === void 0 ? void 0 : _b.reaction_scores);
                message.latest_reactions = __spreadArray([], __read((((_c = e.message) === null || _c === void 0 ? void 0 : _c.latest_reactions) || [])));
                message.own_reactions = __spreadArray([], __read((((_d = e.message) === null || _d === void 0 ? void 0 : _d.own_reactions) || [])));
                messages[messageIndex] = Object.assign({}, message);
                isThreadMessage
                    ? _this.activeThreadMessagesSubject.next(__spreadArray([], __read(messages)))
                    : _this.activeChannelMessagesSubject.next(__spreadArray([], __read(messages)));
            });
        };
        ChannelService.prototype.formatMessage = function (message) {
            var m = message;
            m.pinned_at = message.pinned_at ? new Date(message.pinned_at) : null;
            m.created_at = message.created_at
                ? new Date(message.created_at)
                : new Date();
            m.updated_at = message.updated_at
                ? new Date(message.updated_at)
                : new Date();
            message.status = message.status || 'received';
            return m;
        };
        ChannelService.prototype.isStreamMessage = function (message) {
            return !!message.readBy;
        };
        ChannelService.prototype.isFormatMessageResponse = function (message) {
            return message.created_at instanceof Date;
        };
        ChannelService.prototype.stopWatchForActiveChannelEvents = function (channel) {
            if (!channel) {
                return;
            }
            this.activeChannelSubscriptions.forEach(function (s) { return s.unsubscribe(); });
            this.activeChannelSubscriptions = [];
        };
        ChannelService.prototype.queryChannels = function (shouldSetActiveChannel, recoverState) {
            if (recoverState === void 0) { recoverState = false; }
            var _a, _b;
            return __awaiter(this, void 0, void 0, function () {
                var filters, options, channels, prevChannels_1, filteredChannels, currentActiveChannel_1, isCurrentActiveChannelDeselected, nextChannels, e_3, error_6;
                var _this = this;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            _h.trys.push([0, 6, , 7]);
                            this.channelQueryStateSubject.next({ state: 'in-progress' });
                            filters = void 0;
                            options = void 0;
                            if (this.nextPageConfiguration) {
                                if (this.nextPageConfiguration.type === 'filter') {
                                    filters = Object.assign(Object.assign({}, this.filters), this.nextPageConfiguration.paginationFilter);
                                    options = this.options;
                                }
                                else {
                                    options = Object.assign(Object.assign({}, this.options), { offset: this.nextPageConfiguration.offset });
                                    filters = this.filters;
                                }
                            }
                            else {
                                filters = this.filters;
                                options = this.options;
                            }
                            return [4 /*yield*/, this.chatClientService.chatClient.queryChannels(filters, this.sort || {}, options)];
                        case 1:
                            channels = _h.sent();
                            this.setNextPageConfiguration(channels);
                            channels.forEach(function (c) { return _this.watchForChannelEvents(c); });
                            prevChannels_1 = recoverState
                                ? []
                                : this.channelsSubject.getValue() || [];
                            filteredChannels = channels.filter(function (channel) { return !prevChannels_1.find(function (existingChannel) { return existingChannel.cid === channel.cid; }); });
                            currentActiveChannel_1 = this.activeChannelSubject.getValue();
                            isCurrentActiveChannelDeselected = false;
                            nextChannels = __spreadArray(__spreadArray([], __read(prevChannels_1)), __read(filteredChannels));
                            if (!(recoverState &&
                                currentActiveChannel_1 &&
                                !filteredChannels.find(function (c) { return c.cid === (currentActiveChannel_1 === null || currentActiveChannel_1 === void 0 ? void 0 : currentActiveChannel_1.cid); }))) return [3 /*break*/, 5];
                            _h.label = 2;
                        case 2:
                            _h.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, currentActiveChannel_1.watch()];
                        case 3:
                            _h.sent();
                            nextChannels.unshift(currentActiveChannel_1);
                            return [3 /*break*/, 5];
                        case 4:
                            e_3 = _h.sent();
                            isCurrentActiveChannelDeselected = true;
                            return [3 /*break*/, 5];
                        case 5:
                            this.channelsSubject.next(nextChannels);
                            if (isCurrentActiveChannelDeselected) {
                                this.deselectActiveChannel();
                            }
                            if (filteredChannels.length > 0 &&
                                !currentActiveChannel_1 &&
                                shouldSetActiveChannel) {
                                this.setAsActiveChannel(filteredChannels[0]);
                                currentActiveChannel_1 = this.activeChannelSubject.getValue();
                            }
                            this.hasMoreChannelsSubject.next(channels.length >= this.options.limit);
                            this.channelQueryStateSubject.next({ state: 'success' });
                            if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.keepAliveChannels$OnError) &&
                                this.dismissErrorNotification) {
                                this.dismissErrorNotification();
                            }
                            return [2 /*return*/, channels];
                        case 6:
                            error_6 = _h.sent();
                            if (!((_b = this.options) === null || _b === void 0 ? void 0 : _b.keepAliveChannels$OnError)) {
                                this.channelsSubject.error(error_6);
                            }
                            this.channelQueryStateSubject.next({
                                state: 'error',
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                error: error_6,
                            });
                            throw error_6;
                        case 7: return [2 /*return*/];
                    }
                });
            });
        };
        ChannelService.prototype.watchForChannelEvents = function (channel) {
            var _this = this;
            var unsubscribe = channel.on(function (event) {
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                var type = event.type;
                switch (type) {
                    case 'message.new': {
                        _this.ngZone.run(function () {
                            if (_this.customNewMessageHandler) {
                                _this.customNewMessageHandler(event, channel, _this.channelListSetter, _this.messageListSetter, _this.threadListSetter, _this.parentMessageSetter);
                            }
                            else {
                                _this.handleNewMessage(event, channel);
                            }
                        });
                        break;
                    }
                    case 'channel.hidden': {
                        _this.ngZone.run(function () {
                            if (_this.customChannelHiddenHandler) {
                                _this.customChannelHiddenHandler(event, channel, _this.channelListSetter, _this.messageListSetter, _this.threadListSetter, _this.parentMessageSetter);
                            }
                            else {
                                _this.handleChannelHidden(event);
                            }
                        });
                        break;
                    }
                    case 'channel.deleted': {
                        _this.ngZone.run(function () {
                            if (_this.customChannelDeletedHandler) {
                                _this.customChannelDeletedHandler(event, channel, _this.channelListSetter, _this.messageListSetter, _this.threadListSetter, _this.parentMessageSetter);
                            }
                            else {
                                _this.handleChannelDeleted(event);
                            }
                        });
                        break;
                    }
                    case 'channel.visible': {
                        _this.ngZone.run(function () {
                            if (_this.customChannelVisibleHandler) {
                                _this.customChannelVisibleHandler(event, channel, _this.channelListSetter, _this.messageListSetter, _this.threadListSetter, _this.parentMessageSetter);
                            }
                            else {
                                _this.handleChannelVisible(event, channel);
                            }
                        });
                        break;
                    }
                    case 'channel.updated': {
                        _this.ngZone.run(function () {
                            if (_this.customChannelUpdatedHandler) {
                                _this.customChannelUpdatedHandler(event, channel, _this.channelListSetter, _this.messageListSetter, _this.threadListSetter, _this.parentMessageSetter);
                            }
                            else {
                                _this.handleChannelUpdate(event);
                            }
                        });
                        break;
                    }
                    case 'channel.truncated': {
                        _this.ngZone.run(function () {
                            if (_this.customChannelTruncatedHandler) {
                                _this.customChannelTruncatedHandler(event, channel, _this.channelListSetter, _this.messageListSetter, _this.threadListSetter, _this.parentMessageSetter);
                            }
                            else {
                                _this.handleChannelTruncate(event);
                            }
                        });
                        break;
                    }
                    case 'capabilities.changed': {
                        _this.ngZone.run(function () {
                            var _a;
                            var cid = event.cid;
                            if (cid) {
                                var currentChannels = _this.channelsSubject.getValue();
                                var index = currentChannels === null || currentChannels === void 0 ? void 0 : currentChannels.findIndex(function (c) { return c.cid === cid; });
                                if (index !== -1 && index !== undefined) {
                                    _this.channelsSubject.next(__spreadArray([], __read(currentChannels)));
                                    if (cid === ((_a = _this.activeChannelSubject.getValue()) === null || _a === void 0 ? void 0 : _a.cid)) {
                                        _this.activeChannelSubject.next(_this.activeChannelSubject.getValue());
                                    }
                                }
                            }
                        });
                        break;
                    }
                }
            });
            this.channelSubscriptions[channel.cid] = unsubscribe.unsubscribe;
        };
        ChannelService.prototype.handleNewMessage = function (_, channel) {
            var channelIndex = this.channels.findIndex(function (c) { return c.cid === channel.cid; });
            this.channels.splice(channelIndex, 1);
            this.channelsSubject.next(__spreadArray([channel], __read(this.channels)));
        };
        ChannelService.prototype.handleChannelHidden = function (event) {
            this.removeChannelsFromChannelList([event.channel.cid], false);
        };
        ChannelService.prototype.handleChannelDeleted = function (event) {
            this.removeChannelsFromChannelList([event.channel.cid], false);
        };
        ChannelService.prototype.handleChannelVisible = function (event, channel) {
            var _this = this;
            if (!this.channels.find(function (c) { return c.cid === event.cid; })) {
                this.ngZone.run(function () { return _this.channelsSubject.next(__spreadArray(__spreadArray([], __read(_this.channels)), [channel])); });
            }
        };
        ChannelService.prototype.handleChannelUpdate = function (event) {
            var _a, _b, _c, _d;
            var channelIndex = this.channels.findIndex(function (c) { return c.cid === event.channel.cid; });
            if (channelIndex !== -1) {
                var channel = this.channels[channelIndex];
                var notIncludedProperies = {
                    hidden: ((_a = channel.data) === null || _a === void 0 ? void 0 : _a.hidden) || false,
                    own_capabilities: ((_b = channel.data) === null || _b === void 0 ? void 0 : _b.own_capabilities) || [],
                };
                channel.data = Object.assign(Object.assign({}, event.channel), notIncludedProperies);
                this.channelsSubject.next(__spreadArray([], __read(this.channels)));
                if (((_c = event.channel) === null || _c === void 0 ? void 0 : _c.cid) === ((_d = this.activeChannelSubject.getValue()) === null || _d === void 0 ? void 0 : _d.cid)) {
                    this.activeChannelSubject.next(channel);
                }
            }
        };
        ChannelService.prototype.handleChannelTruncate = function (event) {
            var _a, _b;
            var channelIndex = this.channels.findIndex(function (c) { return c.cid === event.channel.cid; });
            if (channelIndex !== -1) {
                this.channels[channelIndex].state.messages = [];
                this.channelsSubject.next(__spreadArray([], __read(this.channels)));
                if (((_a = event.channel) === null || _a === void 0 ? void 0 : _a.cid) === ((_b = this.activeChannelSubject.getValue()) === null || _b === void 0 ? void 0 : _b.cid)) {
                    var channel = this.activeChannelSubject.getValue();
                    channel.state.messages = [];
                    this.activeChannelSubject.next(channel);
                    this.activeChannelMessagesSubject.next([]);
                    this.activeParentMessageIdSubject.next(undefined);
                    this.activeThreadMessagesSubject.next([]);
                }
            }
        };
        Object.defineProperty(ChannelService.prototype, "canSendReadEvents", {
            get: function () {
                var _a;
                var channel = this.activeChannelSubject.getValue();
                if (!channel) {
                    return false;
                }
                var capabilites = (_a = channel.data) === null || _a === void 0 ? void 0 : _a.own_capabilities;
                return capabilites.indexOf('read-events') !== -1;
            },
            enumerable: false,
            configurable: true
        });
        ChannelService.prototype.transformToStreamMessage = function (message, channel) {
            var isThreadMessage = !!message.parent_id;
            if (this.isStreamMessage(message) &&
                this.isFormatMessageResponse(message)) {
                if (message.quoted_message) {
                    message.quoted_message.translation = getMessageTranslation(message.quoted_message, channel, this.chatClientService.chatClient.user);
                }
                message.translation = getMessageTranslation(message, channel, this.chatClientService.chatClient.user);
                return message;
            }
            else {
                if (message.quoted_message) {
                    message.quoted_message.translation = getMessageTranslation(message.quoted_message, channel, this.chatClientService.chatClient.user);
                }
                if (this.isFormatMessageResponse(message)) {
                    message.readBy = isThreadMessage
                        ? []
                        : channel
                            ? getReadBy(message, channel)
                            : [];
                    message.translation = getMessageTranslation(message, channel, this.chatClientService.chatClient.user);
                    return message;
                }
                else {
                    message = this.formatMessage(message);
                    message.readBy = isThreadMessage
                        ? []
                        : channel
                            ? getReadBy(message, channel)
                            : [];
                    message.translation = getMessageTranslation(message, channel, this.chatClientService.chatClient.user);
                    return message;
                }
            }
        };
        ChannelService.prototype.handleTypingStartEvent = function (event) {
            var _a, _b;
            if (((_a = event.user) === null || _a === void 0 ? void 0 : _a.id) === ((_b = this.chatClientService.chatClient.user) === null || _b === void 0 ? void 0 : _b.id)) {
                return;
            }
            var isTypingInThread = !!event.parent_id;
            if (isTypingInThread &&
                event.parent_id !== this.activeParentMessageIdSubject.getValue()) {
                return;
            }
            var subject = isTypingInThread
                ? this.usersTypingInThreadSubject
                : this.usersTypingInChannelSubject;
            var users = subject.getValue();
            var user = event.user;
            if (user && !users.find(function (u) { return u.id === user.id; })) {
                users.push(user);
                subject.next(__spreadArray([], __read(users)));
            }
        };
        ChannelService.prototype.handleTypingStopEvent = function (event) {
            var usersTypingInChannel = this.usersTypingInChannelSubject.getValue();
            var usersTypingInThread = this.usersTypingInThreadSubject.getValue();
            var user = event.user;
            if (user && usersTypingInChannel.find(function (u) { return u.id === user.id; })) {
                usersTypingInChannel.splice(usersTypingInChannel.findIndex(function (u) { return u.id === user.id; }), 1);
                this.usersTypingInChannelSubject.next(__spreadArray([], __read(usersTypingInChannel)));
                return;
            }
            if (user && usersTypingInThread.find(function (u) { return u.id === user.id; })) {
                usersTypingInThread.splice(usersTypingInThread.findIndex(function (u) { return u.id === user.id; }), 1);
                this.usersTypingInThreadSubject.next(__spreadArray([], __read(usersTypingInThread)));
                return;
            }
        };
        ChannelService.prototype.updateLatestMessages = function (event) {
            var _a, _b, _c, _d, _e, _f, _g;
            if (((_b = (_a = event.message) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.id) !== ((_d = (_c = this.chatClientService) === null || _c === void 0 ? void 0 : _c.chatClient.user) === null || _d === void 0 ? void 0 : _d.id)) {
                return;
            }
            var latestMessages = this.latestMessageDateByUserByChannelsSubject.getValue();
            if (!((_e = event.message) === null || _e === void 0 ? void 0 : _e.created_at)) {
                return;
            }
            var channelId = (_f = event === null || event === void 0 ? void 0 : event.message) === null || _f === void 0 ? void 0 : _f.cid;
            if (!channelId) {
                return;
            }
            var messageDate = new Date(event.message.created_at);
            if (!latestMessages[channelId] ||
                ((_g = latestMessages[channelId]) === null || _g === void 0 ? void 0 : _g.getTime()) < messageDate.getTime()) {
                latestMessages[channelId] = messageDate;
                this.latestMessageDateByUserByChannelsSubject.next(Object.assign({}, latestMessages));
            }
        };
        ChannelService.prototype.setChannelState = function (channel) {
            var _this = this;
            channel.state.messages.forEach(function (m) {
                m.readBy = getReadBy(m, channel);
                m.translation = getMessageTranslation(m, channel, _this.chatClientService.chatClient.user);
                if (m.quoted_message) {
                    m.quoted_message.translation = getMessageTranslation(m.quoted_message, channel, _this.chatClientService.chatClient.user);
                }
            });
            this.markRead(channel);
            this.activeChannelMessagesSubject.next(__spreadArray([], __read(channel.state.messages)));
            this.activeChannelPinnedMessagesSubject.next(__spreadArray([], __read(channel.state.pinnedMessages)));
            this.activeParentMessageIdSubject.next(undefined);
            this.activeThreadMessagesSubject.next([]);
            this.messageToQuoteSubject.next(undefined);
            this.usersTypingInChannelSubject.next([]);
            this.usersTypingInThreadSubject.next([]);
        };
        ChannelService.prototype.markRead = function (channel) {
            if (this.canSendReadEvents &&
                this.shouldMarkActiveChannelAsRead &&
                !this.areReadEventsPaused) {
                void channel.markRead();
            }
        };
        ChannelService.prototype.setNextPageConfiguration = function (channelQueryResult) {
            var _a;
            if (this.customPaginator) {
                this.nextPageConfiguration = this.customPaginator(channelQueryResult);
            }
            else {
                this.nextPageConfiguration = {
                    type: 'offset',
                    offset: (((_a = this.nextPageConfiguration) === null || _a === void 0 ? void 0 : _a.type) === 'offset'
                        ? this.nextPageConfiguration.offset
                        : 0) + channelQueryResult.length,
                };
            }
        };
        return ChannelService;
    }());
    /**
     * internal
     */
    ChannelService.MAX_MESSAGE_REACTIONS_TO_FETCH = 1200;
    ChannelService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelService, deps: [{ token: ChatClientService }, { token: i0__namespace.NgZone }, { token: NotificationService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ChannelService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ChatClientService }, { type: i0__namespace.NgZone }, { type: NotificationService }]; } });

    /**
     * The `ThemeService` can be used to change the theme of the chat UI and to customize the theme. Our [theming guide](../theming/introduction.mdx) gives a complete overview about the topic.
     */
    var ThemeService = /** @class */ (function () {
        function ThemeService() {
            var _this = this;
            /**
             * A Subject that can be used to get or set the currently active theme.
             */
            this.theme$ = new rxjs.BehaviorSubject('light');
            this.defaultDarkModeVariables = {
                '--bg-gradient-end': '#101214',
                '--bg-gradient-start': '#070a0d',
                '--black': '#ffffff',
                '--blue-alice': '#00193d',
                '--border': '#141924',
                '--button-background': '#ffffff',
                '--button-text': '#005fff',
                '--grey': '#7a7a7a',
                '--grey-gainsboro': '#2d2f2f',
                '--grey-whisper': '#1c1e22',
                '--modal-shadow': '#000000',
                '--overlay': '#00000066',
                '--overlay-dark': '#ffffffcc',
                '--shadow-icon': '#00000080',
                '--targetedMessageBackground': '#302d22',
                '--transparent': 'transparent',
                '--white': '#101418',
                '--white-smoke': '#13151b',
                '--white-snow': '#070a0d',
            };
            this.variablesToDelete = [];
            this.theme$.subscribe(function (theme) {
                var darkVariables = _this.customDarkThemeVariables
                    ? Object.assign(Object.assign({}, _this.defaultDarkModeVariables), _this.customDarkThemeVariables) : _this.defaultDarkModeVariables;
                var lightVariables = _this.customLightThemeVariables
                    ? _this.customLightThemeVariables
                    : {};
                _this.variablesToDelete.forEach(function (variables) { return _this.deleteVariables(variables); });
                if (theme === 'dark') {
                    _this.deleteVariables(lightVariables);
                    _this.setVariables(darkVariables);
                }
                else {
                    _this.deleteVariables(darkVariables);
                    _this.setVariables(lightVariables);
                }
            });
            this.themeVersion = (getComputedStyle(document.documentElement)
                .getPropertyValue('--str-chat__theme-version')
                .replace(' ', '') || '1');
        }
        Object.defineProperty(ThemeService.prototype, "customLightThemeVariables", {
            /**
             * A getter that returns the currently set custom light theme variables.
             * @deprecated Only use with [theme v1](../concepts/theming-and-css.mdx)
             * @returns An object where the keys are theme variables, and the values are the currently set CSS values.
             */
            get: function () {
                return this._customLightThemeVariables;
            },
            /**
             * A setter that can be used to overwrite the values of the CSS theme variables of the light theme.
             * @deprecated Only use with [theme v1](../concepts/theming-and-css.mdx)
             * @param variables An object where the keys are theme variables, and the values are CSS values.
             */
            set: function (variables) {
                var prevVariables = this.customLightThemeVariables;
                if (prevVariables) {
                    this.variablesToDelete.push(prevVariables);
                }
                this._customLightThemeVariables = variables;
                if (this.theme$.getValue() === 'light') {
                    this.theme$.next('light');
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ThemeService.prototype, "customDarkThemeVariables", {
            /**
             * A getter that returns the currently set custom dark theme variables.
             * @deprecated Only use with [theme v1](../concepts/theming-and-css.mdx)
             * @returns An object where the keys are theme variables, and the values are the currently set CSS values.
             */
            get: function () {
                return this._customDarkThemeVariables;
            },
            /**
             * A setter that can be used to overwrite the values of the CSS theme variables of the dark theme.
             * @deprecated Only use with [theme v1](../concepts/theming-and-css.mdx)
             * @param variables An object where the keys are theme variables, and the values are CSS values.
             */
            set: function (variables) {
                var prevVariables = this.customDarkThemeVariables;
                if (prevVariables) {
                    this.variablesToDelete.push(prevVariables);
                }
                this._customDarkThemeVariables = variables;
                if (this.theme$.getValue() === 'dark') {
                    this.theme$.next('dark');
                }
            },
            enumerable: false,
            configurable: true
        });
        ThemeService.prototype.deleteVariables = function (variables) {
            if (!variables) {
                return;
            }
            Object.keys(variables).forEach(function (key) { return document.documentElement.style.setProperty(key, null); });
        };
        ThemeService.prototype.setVariables = function (variables) {
            if (!variables) {
                return;
            }
            Object.keys(variables).forEach(function (key) { return document.documentElement.style.setProperty(key, variables[key]); });
        };
        return ThemeService;
    }());
    ThemeService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ThemeService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ThemeService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ThemeService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ThemeService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    var isImageFile = function (file) {
        // photoshop files begin with 'image/'
        return file.type.startsWith('image/') && !file.type.endsWith('.photoshop');
    };

    var isImageAttachment = function (attachment) {
        return (attachment.type === 'image' &&
            !attachment.title_link &&
            !attachment.og_scrape_url);
    };

    /**
     * The `AttachmentService` manages the uploads of a message input.
     */
    var AttachmentService = /** @class */ (function () {
        function AttachmentService(channelService, notificationService) {
            this.channelService = channelService;
            this.notificationService = notificationService;
            this.attachmentUploadInProgressCounterSubject = new rxjs.BehaviorSubject(0);
            this.attachmentUploadsSubject = new rxjs.BehaviorSubject([]);
            this.attachmentUploadInProgressCounter$ =
                this.attachmentUploadInProgressCounterSubject.asObservable();
            this.attachmentUploads$ = this.attachmentUploadsSubject.asObservable();
        }
        /**
         * Resets the attachments uploads (for example after the message with the attachments sent successfully)
         */
        AttachmentService.prototype.resetAttachmentUploads = function () {
            this.attachmentUploadsSubject.next([]);
        };
        /**
         * Uploads the selected files, and creates preview for image files. The result is propagated throught the `attachmentUploads$` stream.
         * @param fileList The files selected by the user
         * @returns A promise with the result
         */
        AttachmentService.prototype.filesSelected = function (fileList) {
            return __awaiter(this, void 0, void 0, function () {
                var imageFiles, dataFiles, videoFiles, newUploads;
                var _this = this;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            if (!fileList) {
                                return [2 /*return*/];
                            }
                            imageFiles = [];
                            dataFiles = [];
                            videoFiles = [];
                            Array.from(fileList).forEach(function (file) {
                                if (isImageFile(file)) {
                                    imageFiles.push(file);
                                }
                                else if (file.type.startsWith('video/')) {
                                    videoFiles.push(file);
                                }
                                else {
                                    dataFiles.push(file);
                                }
                            });
                            imageFiles.forEach(function (f) { return _this.createPreview(f); });
                            newUploads = __spreadArray(__spreadArray(__spreadArray([], __read(imageFiles.map(function (file) { return ({
                                file: file,
                                state: 'uploading',
                                type: 'image',
                            }); }))), __read(videoFiles.map(function (file) { return ({
                                file: file,
                                state: 'uploading',
                                type: 'video',
                            }); }))), __read(dataFiles.map(function (file) { return ({
                                file: file,
                                state: 'uploading',
                                type: 'file',
                            }); })));
                            this.attachmentUploadsSubject.next(__spreadArray(__spreadArray([], __read(this.attachmentUploadsSubject.getValue())), __read(newUploads)));
                            return [4 /*yield*/, this.uploadAttachments(newUploads)];
                        case 1:
                            _e.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * You can add custom `image`, `video` and `file` attachments using this method.
         *
         * Note: If you just want to use your own CDN for file uploads, you don't necessary need this method, you can just specify you own upload function in the [`ChannelService`](./ChannelService.mdx)
         *
         * @param attachment
         */
        AttachmentService.prototype.addAttachment = function (attachment) {
            attachment.isCustomAttachment = true;
            this.createFromAttachments([attachment]);
        };
        /**
         * Retries to upload an attachment.
         * @param file
         * @returns A promise with the result
         */
        AttachmentService.prototype.retryAttachmentUpload = function (file) {
            return __awaiter(this, void 0, void 0, function () {
                var attachmentUploads, upload;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            attachmentUploads = this.attachmentUploadsSubject.getValue();
                            upload = attachmentUploads.find(function (u) { return u.file === file; });
                            if (!upload) {
                                return [2 /*return*/];
                            }
                            upload.state = 'uploading';
                            this.attachmentUploadsSubject.next(__spreadArray([], __read(attachmentUploads)));
                            return [4 /*yield*/, this.uploadAttachments([upload])];
                        case 1:
                            _e.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Deletes an attachment, the attachment can have any state (`error`, `uploading` or `success`).
         * @param upload
         */
        AttachmentService.prototype.deleteAttachment = function (upload) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var attachmentUploads, result, index, error_1, index;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            attachmentUploads = this.attachmentUploadsSubject.getValue();
                            if (!(upload.state === 'success' &&
                                !((_a = upload.fromAttachment) === null || _a === void 0 ? void 0 : _a.isCustomAttachment))) return [3 /*break*/, 5];
                            _e.label = 1;
                        case 1:
                            _e.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.channelService.deleteAttachment(upload)];
                        case 2:
                            _e.sent();
                            result = __spreadArray([], __read(attachmentUploads));
                            index = attachmentUploads.indexOf(upload);
                            result.splice(index, 1);
                            return [3 /*break*/, 4];
                        case 3:
                            error_1 = _e.sent();
                            result = attachmentUploads;
                            this.notificationService.addTemporaryNotification('streamChat.Error deleting attachment');
                            return [3 /*break*/, 4];
                        case 4: return [3 /*break*/, 6];
                        case 5:
                            result = __spreadArray([], __read(attachmentUploads));
                            index = attachmentUploads.indexOf(upload);
                            result.splice(index, 1);
                            _e.label = 6;
                        case 6:
                            this.attachmentUploadsSubject.next(__spreadArray([], __read(result)));
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Maps the current uploads to a format that can be sent along with the message to the Stream API.
         * @returns the attachments
         */
        AttachmentService.prototype.mapToAttachments = function () {
            var attachmentUploads = this.attachmentUploadsSubject.getValue();
            return attachmentUploads
                .filter(function (r) { return r.state === 'success'; })
                .map(function (r) {
                var _a, _b, _c, _d;
                var attachment = {
                    type: r.type,
                };
                if (r.fromAttachment) {
                    return r.fromAttachment;
                }
                else {
                    attachment.mime_type = (_a = r.file) === null || _a === void 0 ? void 0 : _a.type;
                    if (r.type === 'image') {
                        attachment.fallback = (_b = r.file) === null || _b === void 0 ? void 0 : _b.name;
                        attachment.image_url = r.url;
                    }
                    else {
                        attachment.asset_url = r.url;
                        attachment.title = (_c = r.file) === null || _c === void 0 ? void 0 : _c.name;
                        attachment.file_size = (_d = r.file) === null || _d === void 0 ? void 0 : _d.size;
                        attachment.thumb_url = r.thumb_url;
                    }
                }
                return attachment;
            });
        };
        /**
         * Maps attachments received from the Stream API to uploads. This is useful when editing a message.
         * @param attachments Attachemnts received with the message
         */
        AttachmentService.prototype.createFromAttachments = function (attachments) {
            var attachmentUploads = [];
            attachments.forEach(function (attachment) {
                if (isImageAttachment(attachment)) {
                    attachmentUploads.push({
                        url: (attachment.img_url ||
                            attachment.thumb_url ||
                            attachment.image_url),
                        state: 'success',
                        type: 'image',
                        file: {
                            name: attachment.fallback,
                            type: attachment.mime_type,
                        },
                        fromAttachment: attachment,
                    });
                }
                else if (attachment.type === 'file' || attachment.type === 'video') {
                    attachmentUploads.push({
                        url: attachment.asset_url,
                        state: 'success',
                        file: {
                            name: attachment.title,
                            size: attachment.file_size,
                            type: attachment.mime_type,
                        },
                        type: attachment.type,
                        thumb_url: attachment.thumb_url,
                        fromAttachment: attachment,
                    });
                }
            });
            if (attachmentUploads.length > 0) {
                this.attachmentUploadsSubject.next(__spreadArray(__spreadArray([], __read(this.attachmentUploadsSubject.getValue())), __read(attachmentUploads)));
            }
        };
        AttachmentService.prototype.createPreview = function (file) {
            var _this = this;
            var reader = new FileReader();
            reader.onload = function (event) {
                var _a;
                var attachmentUploads = _this.attachmentUploadsSubject.getValue();
                var upload = attachmentUploads.find(function (upload) { return upload.file === file; });
                if (!upload) {
                    return;
                }
                upload.previewUri = ((_a = event.target) === null || _a === void 0 ? void 0 : _a.result) || undefined;
                _this.attachmentUploadsSubject.next(__spreadArray([], __read(attachmentUploads)));
            };
            reader.readAsDataURL(file);
        };
        AttachmentService.prototype.uploadAttachments = function (uploads) {
            return __awaiter(this, void 0, void 0, function () {
                var result, attachmentUploads;
                var _this = this;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            this.attachmentUploadInProgressCounterSubject.next(this.attachmentUploadInProgressCounterSubject.getValue() + 1);
                            return [4 /*yield*/, this.channelService.uploadAttachments(uploads)];
                        case 1:
                            result = _e.sent();
                            attachmentUploads = this.attachmentUploadsSubject.getValue();
                            result.forEach(function (r) {
                                var _a, _b, _c, _d;
                                var upload = attachmentUploads.find(function (upload) { return upload.file === r.file; });
                                if (!upload) {
                                    if (r.url) {
                                        void _this.channelService.deleteAttachment(r);
                                    }
                                    return;
                                }
                                upload.state = r.state;
                                upload.url = r.url;
                                upload.thumb_url = r.thumb_url;
                                if (upload.state === 'error') {
                                    upload.errorReason = r.errorReason;
                                    upload.errorExtraInfo = r.errorExtraInfo;
                                    var errorKey = void 0;
                                    var translateParams = { name: upload.file.name };
                                    switch (upload.errorReason) {
                                        case 'file-extension':
                                            errorKey =
                                                'streamChat.Error uploading file, extension not supported';
                                            translateParams.ext = (_b = (_a = upload.errorExtraInfo) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.param;
                                            break;
                                        case 'file-size':
                                            errorKey =
                                                'streamChat.Error uploading file, maximum file size exceeded';
                                            translateParams.limit = (_d = (_c = upload.errorExtraInfo) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.param;
                                            break;
                                        default:
                                            errorKey = 'streamChat.Error uploading file';
                                    }
                                    _this.notificationService.addTemporaryNotification(errorKey, 'error', undefined, translateParams);
                                }
                            });
                            this.attachmentUploadInProgressCounterSubject.next(this.attachmentUploadInProgressCounterSubject.getValue() - 1);
                            this.attachmentUploadsSubject.next(__spreadArray([], __read(attachmentUploads)));
                            return [2 /*return*/];
                    }
                });
            });
        };
        return AttachmentService;
    }());
    AttachmentService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentService, deps: [{ token: ChannelService }, { token: NotificationService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AttachmentService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ChannelService }, { type: NotificationService }]; } });

    /**
     * The `AttachmentConfigurationService` provides customization for certain attributes of attachments displayed inside the message component. If you're using your own CDN, you can integrate resizing features of it by providing your own handlers.
     */
    var AttachmentConfigurationService = /** @class */ (function () {
        function AttachmentConfigurationService() {
            /**
             * You can turn on/off thumbnail generation for video attachments
             */
            this.shouldGenerateVideoThumbnail = true;
        }
        /**
         * Handles the configuration for image attachments, it's possible to provide your own function to override the default logic
         * @param attachment The attachment to configure
         * @param location Specifies where the image is being displayed
         * @param element The default resizing logics reads the height/max-height and max-width propperties of this element and reduces file size based on the given values. File size reduction is done by Stream's CDN.
         */
        AttachmentConfigurationService.prototype.getImageAttachmentConfiguration = function (attachment, location, element) {
            if (this.customImageAttachmentConfigurationHandler) {
                return this.customImageAttachmentConfigurationHandler(attachment, location, element);
            }
            var defaultOriginalDimension = 1000000;
            var urlString = (attachment.img_url ||
                attachment.thumb_url ||
                attachment.image_url ||
                '');
            var url;
            try {
                url = new URL(urlString);
            }
            catch (error) {
                return {
                    url: urlString,
                    width: '',
                    height: '',
                    originalHeight: defaultOriginalDimension,
                    originalWidth: defaultOriginalDimension,
                };
            }
            var originalHeight = Number(url.searchParams.get('oh')) > 1
                ? Number(url.searchParams.get('oh'))
                : defaultOriginalDimension;
            var originalWidth = Number(url.searchParams.get('ow')) > 1
                ? Number(url.searchParams.get('ow'))
                : defaultOriginalDimension;
            var displayWarning = location === 'gallery' || location === 'single';
            var sizeRestriction = this.getSizingRestrictions(url, element, displayWarning);
            if (sizeRestriction) {
                // Apply 2x for retina displays
                sizeRestriction.height *= 2;
                sizeRestriction.width *= 2;
                this.addResizingParamsToUrl(sizeRestriction, url);
            }
            return {
                url: url.href,
                width: '',
                height: '',
                originalHeight: originalHeight,
                originalWidth: originalWidth,
            };
        };
        /**
         * Handles the configuration for video attachments, it's possible to provide your own function to override the default logic
         * @param attachment The attachment to configure
         * @param element The default resizing logics reads the height/max-height and max-width propperties of this element and reduces file size based on the given values. File size reduction is done by Stream's CDN.
         */
        AttachmentConfigurationService.prototype.getVideoAttachmentConfiguration = function (attachment, element) {
            if (this.customVideoAttachmentConfigurationHandler) {
                return this.customVideoAttachmentConfigurationHandler(attachment, element);
            }
            var thumbUrl = undefined;
            var originalHeight = 1000000;
            var originalWidth = 1000000;
            if (attachment.thumb_url && this.shouldGenerateVideoThumbnail) {
                var url = void 0;
                try {
                    url = new URL(attachment.thumb_url);
                    originalHeight =
                        Number(url.searchParams.get('oh')) > 1
                            ? Number(url.searchParams.get('oh'))
                            : originalHeight;
                    originalWidth =
                        Number(url.searchParams.get('ow')) > 1
                            ? Number(url.searchParams.get('ow'))
                            : originalWidth;
                    var displayWarning = true;
                    var sizeRestriction = this.getSizingRestrictions(url, element, displayWarning);
                    if (sizeRestriction) {
                        sizeRestriction.height *= 2;
                        sizeRestriction.width *= 2;
                        this.addResizingParamsToUrl(sizeRestriction, url);
                    }
                    thumbUrl = url.href;
                }
                catch (_a) {
                    thumbUrl = attachment.thumb_url;
                }
            }
            return {
                url: attachment.asset_url || '',
                width: '',
                height: '',
                thumbUrl: thumbUrl,
                originalHeight: originalHeight,
                originalWidth: originalWidth,
            };
        };
        /**
         * Handles the configuration for giphy attachments, it's possible to provide your own function to override the default logic
         * @param attachment The attachment to configure
         */
        AttachmentConfigurationService.prototype.getGiphyAttachmentConfiguration = function (attachment) {
            var _a;
            if (this.customGiphyAttachmentConfigurationHandler) {
                return this.customGiphyAttachmentConfigurationHandler(attachment);
            }
            var giphy = (_a = attachment.giphy) === null || _a === void 0 ? void 0 : _a.fixed_height_downsampled;
            return {
                url: (giphy === null || giphy === void 0 ? void 0 : giphy.url) || attachment.image_url || attachment.thumb_url || '',
                height: (giphy === null || giphy === void 0 ? void 0 : giphy.height) ? (giphy === null || giphy === void 0 ? void 0 : giphy.height) + "px" : '300px',
                width: (giphy === null || giphy === void 0 ? void 0 : giphy.width) ? (giphy === null || giphy === void 0 ? void 0 : giphy.width) + "px" : '',
            };
        };
        /**
         * Handles the configuration for scraped image attachments, it's possible to provide your own function to override the default logic
         * @param attachment The attachment to configure
         */
        AttachmentConfigurationService.prototype.getScrapedImageAttachmentConfiguration = function (attachment) {
            if (this.customScrapedImageAttachmentConfigurationHandler) {
                return this.customScrapedImageAttachmentConfigurationHandler(attachment);
            }
            return {
                url: attachment.image_url || attachment.thumb_url || '',
                width: '',
                height: '', // Set from CSS
            };
        };
        AttachmentConfigurationService.prototype.addResizingParamsToUrl = function (sizeRestriction, url) {
            url.searchParams.set('h', sizeRestriction.height.toString());
            url.searchParams.set('w', sizeRestriction.width.toString());
        };
        AttachmentConfigurationService.prototype.getSizingRestrictions = function (url, htmlElement, displayWarning) {
            if (displayWarning === void 0) { displayWarning = false; }
            var urlParams = url.searchParams;
            var originalHeight = Number(urlParams.get('oh')) || 1;
            var originalWidth = Number(urlParams.get('ow')) || 1;
            var cssSizeRestriction = this.getCSSSizeRestriction(htmlElement);
            var sizeRestriction;
            if ((cssSizeRestriction.maxHeight || cssSizeRestriction.height) &&
                cssSizeRestriction.maxWidth) {
                sizeRestriction = this.getSizeRestrictions(originalHeight, originalWidth, (cssSizeRestriction.maxHeight || cssSizeRestriction.height), cssSizeRestriction.maxWidth);
            }
            else {
                sizeRestriction = undefined;
                if (displayWarning) {
                    console.warn("Invalid value set for height/max-height and/or max-width for HTML element, this can cause scrolling issues inside the message list, more info https://getstream.io/chat/docs/sdk/angular/components/AttachmentListComponent/#image-and-video-sizing, attachment URL: " + url.toString());
                }
            }
            return sizeRestriction;
        };
        AttachmentConfigurationService.prototype.getSizeRestrictions = function (originalHeight, originalWidth, maxHeight, maxWidth) {
            return {
                height: Math.round(Math.max(maxHeight, (maxWidth / originalWidth) * originalHeight)),
                width: Math.round(Math.max(maxHeight, (maxWidth / originalHeight) * originalWidth)),
            };
        };
        AttachmentConfigurationService.prototype.getCSSSizeRestriction = function (htmlElement) {
            var computedStylesheet = getComputedStyle(htmlElement);
            var height = this.getValueRepresentationOfCSSProperty(computedStylesheet.getPropertyValue('height'));
            var maxHeight = this.getValueRepresentationOfCSSProperty(computedStylesheet.getPropertyValue('max-height'));
            var maxWidth = this.getValueRepresentationOfCSSProperty(computedStylesheet.getPropertyValue('max-width'));
            return { height: height, maxHeight: maxHeight, maxWidth: maxWidth };
        };
        AttachmentConfigurationService.prototype.getValueRepresentationOfCSSProperty = function (property) {
            return Number(property.replace('px', '')) || undefined;
        };
        return AttachmentConfigurationService;
    }());
    AttachmentConfigurationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentConfigurationService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AttachmentConfigurationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentConfigurationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentConfigurationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var en = {
        streamChat: {
            '1 reply': '1 reply',
            'Attach files': 'Attach files',
            Cancel: 'Cancel',
            'Channel Missing': 'Channel Missing',
            Close: 'Close',
            'Close emoji picker': 'Close emoji picker',
            'Commands matching': 'Commands matching',
            'Connection failure, reconnecting now...': 'Connection failure, reconnecting now...',
            Delete: 'Delete',
            Delivered: 'Delivered',
            'Edit Message': 'Edit Message',
            'Edit message request failed': 'Edit message request failed',
            'Emoji matching': 'Emoji matching',
            'Empty message...': 'Empty message...',
            'Error adding flag': 'Error adding flag',
            'Error connecting to chat, refresh the page to try again.': 'Error connecting to chat, refresh the page to try again',
            'Error deleting message': 'Error deleting message',
            'Error loading reactions': 'Error loading reactions',
            'Error muting a user ...': 'Error muting a user ...',
            'Error pinning message': 'Error pinning message',
            'Error removing message pin': 'Error removing message pin',
            'Error unmuting a user ...': 'Error unmuting a user ...',
            'Error uploading file': 'Error uploading file "{{ name }}"',
            'Error uploading file, maximum file size exceeded': 'Error uploading "{{ name }}", maximum file size {{ limit }} exceeded',
            'Error uploading file, extension not supported': 'Error uploading "{{ name }}", type {{ ext }} not supported',
            'Error deleting attachment': 'Error deleting attachment',
            'Error · Unsent': "Message couldn't be sent",
            'Error: {{ errorMessage }}': 'Error: {{ errorMessage }}',
            Flag: 'Flag',
            'Message Failed': 'Message Failed',
            'Message Failed · Unauthorized': 'Unauthorized to send message',
            'Message Failed · Click to try again': "Message couldn't be sent, click to try again",
            'Message deleted': 'Message deleted',
            'Message has been successfully flagged': 'Message has been successfully flagged',
            'Message pinned': 'Message pinned',
            'Message unpinned': 'Message unpinned',
            Mute: 'Mute',
            New: 'New',
            'New Messages!': 'New Messages!',
            'No results found': 'No results found',
            'Nothing yet...': 'Nothing yet...',
            'Only visible to you': 'Only visible to you',
            'Open emoji picker': 'Open emoji picker',
            'People matching': 'People matching',
            'Pick your emoji': 'Pick your emoji',
            Pin: 'Pin',
            'Pinned by': 'Pinned by',
            Reply: 'Reply',
            'Reply to Message': 'Reply to Message',
            Search: 'Search',
            'Searching...': 'Searching...',
            Send: 'Send',
            'Send message request failed': 'Send message request failed',
            'Sending...': 'Sending...',
            'Slow Mode ON': 'Slow Mode ON',
            'Start of a new thread': 'Start of a new thread',
            'This message was deleted...': 'This message was deleted...',
            Thread: 'Thread reply',
            'Type your message': 'Type your message',
            Unmute: 'Unmute',
            Unpin: 'Unpin',
            'Wait until all attachments have uploaded': 'Wait until all attachments have uploaded',
            'You have no channels currently': 'You have no channels currently',
            "You've reached the maximum number of files": "You've reached the maximum number of files",
            live: 'live',
            'this content could not be displayed': 'this content could not be displayed',
            '{{ commaSeparatedUsers }} and {{ moreCount }} more': '{{ commaSeparatedUsers }} and {{ moreCount }} more',
            '{{ commaSeparatedUsers }}, and {{ lastUser }}': '{{ commaSeparatedUsers }}, and {{ lastUser }}',
            '{{ firstUser }} and {{ secondUser }}': '{{ firstUser }} and {{ secondUser }}',
            '{{ imageCount }} more': '{{ imageCount }} more',
            '{{ memberCount }} members': '{{ memberCount }} members',
            '{{ replyCount }} replies': '{{ replyCount }} replies',
            '{{ user }} has been muted': '{{ user }} has been muted',
            '{{ user }} has been unmuted': '{{ user }} has been unmuted',
            '{{ watcherCount }} online': '{{ watcherCount }} online',
            '🏙 Attachment...': '🏙 Attachment...',
            'Connection error': 'Connection error',
            'Load more': 'Load more',
            failed: 'failed',
            retry: 'retry',
            test: 'success',
            'Sending links is not allowed in this conversation': 'Sending links is not allowed in this conversation',
            "You can't send messages in this channel": "You can't send messages in this channel",
            "You can't send thread replies in this channel": "You can't send thread replies in this channel",
            'Message not found': 'Message not found',
            'No chats here yet…': 'No chats here yet…',
            'user is typing': '{{ user }} is typing',
            'users are typing': '{{ users }} are typing',
            'Error loading channels': 'Error loading channels',
            'See original (automatically translated)': 'See original (automatically translated)',
            'See translation': 'See translation',
            'Mark as unread': 'Mark as unread',
            'Error marking message as unread': 'Error marking message as unread',
            'Error, only the first {{count}} message can be marked as unread': 'Error, only the first {{count}} message can be marked as unread',
            'Unread messages': 'Unread messages',
            '{{count}} unread messages': '{{count}} unread messages',
            '{{count}} unread message': '{{count}} unread message',
            'This message did not meet our content guidelines': 'This message did not meet our content guidelines',
            'Send Anyway': 'Send Anyway',
            Edited: 'Edited',
            'Error playing audio': 'Error playing audio',
        },
    };

    /**
     * The `StreamI18nService` can be used to customize the labels of the chat UI. Our [translation guide](../concepts/translation.mdx) covers this topic in detail.
     */
    var StreamI18nService = /** @class */ (function () {
        function StreamI18nService(translteService) {
            this.translteService = translteService;
        }
        /**
         * Registers the translation to the [ngx-translate](https://github.com/ngx-translate/core) TranslateService.
         * @param lang The language key to register the translation to
         * @param overrides An object which keys are translation keys, and the values are custom translations
         */
        StreamI18nService.prototype.setTranslation = function (lang, overrides) {
            if (lang === void 0) { lang = 'en'; }
            if (!this.translteService.defaultLang) {
                this.translteService.defaultLang = lang;
            }
            this.translteService.setTranslation(lang, { streamChat: Object.assign(Object.assign({}, en.streamChat), overrides) }, true);
        };
        return StreamI18nService;
    }());
    StreamI18nService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamI18nService, deps: [{ token: i9__namespace.TranslateService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    StreamI18nService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamI18nService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamI18nService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i9__namespace.TranslateService }]; } });

    /**
     * The `Avatar` component displays the provided image, with fallback to the first letter of the optional name input.
     */
    var AvatarComponent = /** @class */ (function () {
        function AvatarComponent(chatClientService, ngZone, cdRef) {
            this.chatClientService = chatClientService;
            this.ngZone = ngZone;
            this.cdRef = cdRef;
            /**
             * The size in pixels of the avatar image.
             */
            this.size = 32;
            /**
             * If a channel avatar is displayed, and if the channel has exactly two members a green dot is displayed if the other member is online. Set this flag to `false` to turn off this behavior.
             */
            this.showOnlineIndicator = true;
            /**
             * If channel/user image isn't provided the initials of the name of the channel/user is shown instead, you can choose how the initals should be computed
             */
            this.initialsType = 'first-letter-of-first-word';
            this.isError = false;
            this.isOnline = false;
            this.initials = '';
            this.isViewInited = false;
            this.subscriptions = [];
        }
        AvatarComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.chatClientService.user$.subscribe(function (u) {
                if ((u === null || u === void 0 ? void 0 : u.id) !== _this.userId) {
                    _this.userId = u === null || u === void 0 ? void 0 : u.id;
                    if (_this.type || _this.channel || _this.name) {
                        _this.setInitials();
                        _this.setFallbackChannelImage();
                        _this.updateIsOnlineSubscription();
                    }
                    if (_this.isViewInited) {
                        _this.cdRef.detectChanges();
                    }
                }
            }));
        };
        AvatarComponent.prototype.ngOnChanges = function (changes) {
            if (changes['channel']) {
                this.updateIsOnlineSubscription();
            }
            if (changes.type || changes.name || changes.channel) {
                this.setInitials();
            }
            if (changes.type || changes.channel) {
                this.setFallbackChannelImage();
            }
        };
        AvatarComponent.prototype.setFallbackChannelImage = function () {
            if (this.type !== 'channel') {
                this.fallbackChannelImage = undefined;
            }
            else {
                var otherMember = this.getOtherMemberIfOneToOneChannel();
                if (otherMember) {
                    this.fallbackChannelImage = otherMember.image;
                }
                else {
                    this.fallbackChannelImage = undefined;
                }
            }
        };
        AvatarComponent.prototype.setInitials = function () {
            var _a, _b, _c, _d, _e;
            var result = '';
            if (this.type === 'user') {
                result = ((_a = this.name) === null || _a === void 0 ? void 0 : _a.toString()) || '';
            }
            else if (this.type === 'channel') {
                if ((_c = (_b = this.channel) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.name) {
                    result = (_e = (_d = this.channel) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.name;
                }
                else {
                    var otherMember = this.getOtherMemberIfOneToOneChannel();
                    if (otherMember) {
                        result = otherMember.name || otherMember.id || '';
                    }
                    else {
                        result = '#';
                    }
                }
            }
            var words = result.split(' ');
            var initials;
            if (this.initialsType === 'first-letter-of-each-word') {
                initials = words.map(function (w) { return w.charAt(0) || ''; }).join('');
            }
            else {
                initials = words[0].charAt(0) || '';
            }
            this.initials = initials;
        };
        AvatarComponent.prototype.updateIsOnlineSubscription = function () {
            var _this = this;
            var _a, _b;
            if (this.channel) {
                var otherMember_1 = this.getOtherMemberIfOneToOneChannel();
                if (otherMember_1) {
                    this.isOnline = otherMember_1.online || false;
                    this.isOnlineSubscription = this.chatClientService.events$
                        .pipe(operators.filter(function (e) { return e.eventType === 'user.presence.changed'; }))
                        .subscribe(function (event) {
                        var _a;
                        if (((_a = event.event.user) === null || _a === void 0 ? void 0 : _a.id) === otherMember_1.id) {
                            _this.ngZone.run(function () {
                                var _a;
                                _this.isOnline = ((_a = event.event.user) === null || _a === void 0 ? void 0 : _a.online) || false;
                            });
                        }
                    });
                }
                else {
                    this.isOnline = false;
                    (_a = this.isOnlineSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                }
            }
            else {
                this.isOnline = false;
                (_b = this.isOnlineSubscription) === null || _b === void 0 ? void 0 : _b.unsubscribe();
            }
        };
        AvatarComponent.prototype.ngAfterViewInit = function () {
            this.isViewInited = true;
        };
        AvatarComponent.prototype.getOtherMemberIfOneToOneChannel = function () {
            var _this = this;
            var _a, _b;
            var otherMembers = Object.values(((_b = (_a = this.channel) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.members) || {}).filter(function (m) { return m.user_id !== _this.userId; });
            if (otherMembers.length === 1) {
                return otherMembers[0].user;
            }
            else {
                return undefined;
            }
        };
        return AvatarComponent;
    }());
    AvatarComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AvatarComponent, deps: [{ token: ChatClientService }, { token: i0__namespace.NgZone }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AvatarComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: AvatarComponent, selector: "stream-avatar", inputs: { name: "name", imageUrl: "imageUrl", size: "size", location: "location", channel: "channel", user: "user", type: "type", showOnlineIndicator: "showOnlineIndicator", initialsType: "initialsType" }, usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  class=\"str-chat__avatar str-chat__avatar--circle stream-chat__avatar--{{\n    location\n  }}\"\n  title=\"{{ name }}\"\n  [ngStyle]=\"{\n    flexBasis: 'calc(var(--str-chat__spacing-px, 1px) * ' + size + ')',\n    fontSize:\n      initialsType === 'first-letter-of-first-word'\n        ? 'calc(var(--str-chat__spacing-px, 1px) * ' + size / 2 + ')'\n        : 'calc(var(--str-chat__spacing-px, 1px) * ' + size / 3 + ')',\n    height: 'calc(var(--str-chat__spacing-px, 1px) * ' + size + ')',\n    lineHeight: 'calc(var(--str-chat__spacing-px, 1px) * ' + size + ')',\n    width: 'calc(var(--str-chat__spacing-px, 1px) * ' + size + ')'\n  }\"\n>\n  <img\n    *ngIf=\"(imageUrl || fallbackChannelImage) && !isError; else fallback\"\n    class=\"str-chat__avatar-image str-chat__avatar-image\"\n    src=\"{{ imageUrl || fallbackChannelImage }}\"\n    alt=\"{{ initials }}\"\n    data-testid=\"avatar-img\"\n    (error)=\"isError = true\"\n    [ngStyle]=\"{\n      flexBasis: 'calc(var(--str-chat__spacing-px, 1px) * ' + size + ')',\n      height: 'calc(var(--str-chat__spacing-px, 1px) * ' + size + ')',\n      objectFit: 'cover',\n      width: 'calc(var(--str-chat__spacing-px, 1px) * ' + size + ')'\n    }\"\n    fetchpriority=\"high\"\n  />\n  <ng-template #fallback>\n    <div data-testid=\"fallback-img\" class=\"str-chat__avatar-fallback\">\n      {{ initials }}\n    </div>\n  </ng-template>\n  <div\n    data-testid=\"online-indicator\"\n    *ngIf=\"isOnline && showOnlineIndicator\"\n    class=\"str-chat__avatar--online-indicator\"\n  ></div>\n</div>\n", styles: [""], directives: [{ type: i8__namespace.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AvatarComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-avatar',
                        templateUrl: './avatar.component.html',
                        styleUrls: ['./avatar.component.scss'],
                    }]
            }], ctorParameters: function () { return [{ type: ChatClientService }, { type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { name: [{
                    type: i0.Input
                }], imageUrl: [{
                    type: i0.Input
                }], size: [{
                    type: i0.Input
                }], location: [{
                    type: i0.Input
                }], channel: [{
                    type: i0.Input
                }], user: [{
                    type: i0.Input
                }], type: [{
                    type: i0.Input
                }], showOnlineIndicator: [{
                    type: i0.Input
                }], initialsType: [{
                    type: i0.Input
                }] } });

    /**
     * A central location for registering your custom templates to override parts of the chat application.
     *
     * For code examples to the different customizations see our [customizations example application](https://github.com/GetStream/stream-chat-angular/tree/master/projects/customizations-example), specifically the [AppComponent](https://github.com/GetStream/stream-chat-angular/tree/master/projects/customizations-example/src/app) (see [README](https://github.com/GetStream/stream-chat-angular/blob/master/README.md#customization-examples) for instructions on how to start the application).
     *
     * You can find the type definitions of the context that is provided for each template [on GitHub](https://github.com/GetStream/stream-chat-angular/blob/master/projects/stream-chat-angu)
     */
    var CustomTemplatesService = /** @class */ (function () {
        function CustomTemplatesService() {
            /**
             * The autocomplete list item template for mentioning users (used in the [`AutocompleteTextareaComponent`](../components/AutocompleteTextareaComponent.mdx))
             */
            this.mentionAutocompleteItemTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The autocomplete list item template for commands (used in the [`AutocompleteTextareaComponent`](../components/AutocompleteTextareaComponent.mdx))
             */
            this.commandAutocompleteItemTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Template used to display an item in the [channel list](../components/ChannelListComponent.mdx) (instead of the default [channal list item](../components/ChannelPreviewComponent.mdx))
             *
             */
            this.channelPreviewTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The message input template used when editing a message (instead of the [default message input](../components/MessageInputComponent.mdx))
             *
             */
            this.messageInputTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used for displaying a [mention inside a message](../code-examples/mention-actions.mdx)
             *
             */
            this.mentionTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template for [emoji picker](../code-examples/emoji-picker.mdx)
             *
             */
            this.emojiPickerTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The typing indicator template used in the [message list](../components/MessageListComponent.mdx)
             *
             */
            this.typingIndicatorTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display a message in the [message list](../components/MessageListComponent.mdx) (instead of the [default message component](../components/MessageComponent.mdx))
             *
             */
            this.messageTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template for channel actions displayed in the [channel header](../components/ChannelHeaderComponent.mdx) (by default no channel action is displayed)
             *
             */
            this.channelActionsTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display attachments of a [message](../components/MessageComponent.mdx) (instead of the [default attachment list](../components/AttachmentListComponent.mdx))
             *
             */
            this.attachmentListTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display attachments in the [message input](../components/MessageInputComponent.mdx) component (instead of the [default attachment preview](../components/AttachmentPreviewListComponent.mdx))
             *
             */
            this.attachmentPreviewListTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display avatars for channels and users (instead of the [default avatar](../components/AvatarComponent.mdx))
             *
             */
            this.avatarTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Template for displaying icons (instead of the [default icon component](../components/IconComponent.mdx))
             *
             */
            this.iconTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Template for displaying the loading indicator (instead of the [default loading indicator](../components/LoadingIndicatorComponent.mdx))
             *
             */
            this.loadingIndicatorTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Template for displaying the message actions box (instead of the [default message actions box](../components/MessageActionsBoxComponent.mdx))
             *
             */
            this.messageActionsBoxTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used for displaying an item in the [message actions box](../components/MessageActionsBoxComponent.mdx)
             *
             */
            this.messageActionsBoxItemTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display the reactions of a [message](../components/MessageComponent.mdx), and the selector to add a reaction to a message (instead of the [default message reactions component](../components/MessageReactionsComponent.mdx))
             *
             */
            this.messageReactionsTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display a modal window (instead of the [default modal](../components/ModalComponent.mdx))
             *
             */
            this.modalTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to override the [default notification component](../components/NotificationComponent.mdx)
             *
             */
            this.notificationTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used for header of a [thread](../components/ThreadComponent.mdx)
             *
             */
            this.threadHeaderTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used for displaying the delivered state of the message inside the [message component](../components/MessageComponent.mdx)
             *
             * Displayed for the last message sent by the current user, if the message isn't yet read by anyone
             *
             */
            this.deliveredStatusTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used for displaying the sending state of the message inside the [message component](../components/MessageComponent.mdx)
             *
             * Displayed for the last message sent by the current user, if the message is currently being sent
             *
             */
            this.sendingStatusTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used for displaying the sent state of the message inside the [message component](../components/MessageComponent.mdx)
             *
             * Displayed for the last message sent by the current user, if the message is read at least by one user
             *
             */
            this.readStatusTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Template to display custom metadata inside [message component](../components/MessageComponent.mdx)
             *
             */
            this.customMessageMetadataTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display additional information about a channel under the channel name inside the [channel header component](../components/ChannelHeaderComponent.mdx)
             *
             */
            this.channelHeaderInfoTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used for displaying file upload/attachment selector inside the [message input](../components/MessageInputComponent.mdx)
             *
             */
            this.customAttachmentUploadTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template that can be used to override how a single image attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
             */
            this.imageAttachmentTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template that can be used to override how a voice recording attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx), by default the [voice recording component](../components/VoiceRecordingComponent.mdx) is used
             */
            this.voiceRecordingAttachmentTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template that can be used to override how a video attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
             */
            this.videoAttachmentTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template that can be used to override how image gallery is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
             */
            this.galleryAttachmentTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template that can be used to override how a file attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
             */
            this.fileAttachmentTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template that can be used to override how a card attachment is displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
             */
            this.cardAttachmentTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template that can be used to override how attachment actions are displayed inside the [attachment list](../components/AttachmentListComponent.mdx)
             */
            this.attachmentActionsTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display [system messages](https://getstream.io/chat/docs/javascript/silent_messages/?language=javascript&q=system) indise the [message component](../components/MessageComponent.mdx)
             */
            this.systemMessageTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display the date separator inside the [message list](../components/MessageListComponent.mdx)
             */
            this.dateSeparatorTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display unread messages indicator inside the [message list](../components/MessageListComponent.mdx) when the channel is opened
             *
             * This UI element is used to separate unread messages from read messages
             */
            this.newMessagesIndicatorTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display unread messages notification inside the [message list](../components/MessageListComponent.mdx) when the channel is opened
             *
             * Users can use this notification to jump to the first unread message when it's clicked
             */
            this.newMessagesNotificationTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template to show if the main message list is empty
             */
            this.emptyMainMessageListPlaceholder$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template to show if the thread message list is empty
             */
            this.emptyThreadMessageListPlaceholder$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display the [edit message form](../components/EditMessageFormComponent.mdx)
             */
            this.editMessageFormTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * The template used to display the [message bounce prompt](../components/MessageBouncePromptComponent.mdx)
             */
            this.messageBouncePromptTemplate$ = new rxjs.BehaviorSubject(undefined);
            /**
             * Template used to display the channel information inside the [channel list item](../components/ChannelPreviewComponent.mdx)
             *
             */
            this.channelPreviewInfoTemplate$ = new rxjs.BehaviorSubject(undefined);
        }
        return CustomTemplatesService;
    }());
    CustomTemplatesService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: CustomTemplatesService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CustomTemplatesService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: CustomTemplatesService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: CustomTemplatesService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    /**
     * The `AvatarPlaceholder` component displays the [default avatar](./AvatarComponent.mdx) unless a [custom template](../services/CustomTemplatesService.mdx) is provided. This component is used by the SDK internally, you likely won't need to use it.
     */
    var AvatarPlaceholderComponent = /** @class */ (function () {
        function AvatarPlaceholderComponent(customTemplatesService) {
            this.customTemplatesService = customTemplatesService;
            /**
             * The size in pixels of the avatar image.
             */
            this.size = 32;
            /**
             * If channel/user image isn't provided the initials of the name of the channel/user is shown instead, you can choose how the initals should be computed
             */
            this.initialsType = 'first-letter-of-first-word';
            /**
             * If a channel avatar is displayed, and if the channel has exactly two members a green dot is displayed if the other member is online. Set this flag to `false` to turn off this behavior.
             */
            this.showOnlineIndicator = true;
            this.context = {
                name: undefined,
                imageUrl: undefined,
                size: undefined,
                location: undefined,
                channel: undefined,
                user: undefined,
                type: undefined,
                initialsType: undefined,
                showOnlineIndicator: undefined,
            };
        }
        AvatarPlaceholderComponent.prototype.ngOnChanges = function () {
            this.context = {
                name: this.name,
                imageUrl: this.imageUrl,
                size: this.size,
                location: this.location,
                type: this.type,
                user: this.user,
                channel: this.channel,
                initialsType: this.initialsType,
                showOnlineIndicator: this.showOnlineIndicator,
            };
        };
        return AvatarPlaceholderComponent;
    }());
    AvatarPlaceholderComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AvatarPlaceholderComponent, deps: [{ token: CustomTemplatesService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AvatarPlaceholderComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: { name: "name", imageUrl: "imageUrl", size: "size", location: "location", channel: "channel", user: "user", type: "type", initialsType: "initialsType", showOnlineIndicator: "showOnlineIndicator" }, usesOnChanges: true, ngImport: i0__namespace, template: "<ng-template\n  #defaultAvatar\n  let-name=\"name\"\n  let-imageUrl=\"imageUrl\"\n  let-size=\"size\"\n  let-type=\"type\"\n  let-channel=\"channel\"\n  let-user=\"user\"\n  let-location=\"location\"\n  let-initialsType=\"initialsType\"\n  let-showOnlineIndicator=\"showOnlineIndicator\"\n>\n  <stream-avatar\n    [name]=\"name\"\n    [imageUrl]=\"imageUrl\"\n    [size]=\"size\"\n    [type]=\"type\"\n    [channel]=\"channel\"\n    [user]=\"user\"\n    [location]=\"location\"\n    [initialsType]=\"initialsType\"\n    [showOnlineIndicator]=\"showOnlineIndicator\"\n  ></stream-avatar>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.avatarTemplate$ | async) || defaultAvatar;\n    context: context\n  \"\n></ng-container>\n", components: [{ type: AvatarComponent, selector: "stream-avatar", inputs: ["name", "imageUrl", "size", "location", "channel", "user", "type", "showOnlineIndicator", "initialsType"] }], directives: [{ type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AvatarPlaceholderComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-avatar-placeholder',
                        templateUrl: './avatar-placeholder.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: CustomTemplatesService }]; }, propDecorators: { name: [{
                    type: i0.Input
                }], imageUrl: [{
                    type: i0.Input
                }], size: [{
                    type: i0.Input
                }], location: [{
                    type: i0.Input
                }], channel: [{
                    type: i0.Input
                }], user: [{
                    type: i0.Input
                }], type: [{
                    type: i0.Input
                }], initialsType: [{
                    type: i0.Input
                }], showOnlineIndicator: [{
                    type: i0.Input
                }] } });

    /**
     * The `Icon` component can be used to display different icons (i. e. message delivered icon).
     */
    var IconComponent = /** @class */ (function () {
        function IconComponent() {
        }
        return IconComponent;
    }());
    IconComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: IconComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    IconComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: IconComponent, selector: "stream-icon", inputs: { icon: "icon", size: "size" }, ngImport: i0__namespace, template: "<svg\n  data-testid=\"action-icon\"\n  *ngIf=\"icon === 'action-icon'\"\n  height=\"4\"\n  viewBox=\"0 0 11 4\"\n  width=\"11\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M1.5 3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm4 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm4 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z\"\n    fillRule=\"nonzero\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'delivered-icon'\"\n  data-testid=\"delivered-icon\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    fill-rule=\"evenodd\"\n    clip-rule=\"evenodd\"\n    d=\"M8.9999 16.2L4.7999 12L3.3999 13.4L8.9999 19L20.9999 6.99998L19.5999 5.59998L8.9999 16.2Z\"\n    fill=\"black\"\n  />\n</svg>\n\n<svg\n  *ngIf=\"icon === 'reaction-icon'\"\n  height=\"12\"\n  viewBox=\"0 0 12 12\"\n  width=\"12\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  data-testid=\"reaction-icon\"\n>\n  <g clipRule=\"evenodd\" fillRule=\"evenodd\">\n    <path\n      d=\"M6 1.2C3.3 1.2 1.2 3.3 1.2 6c0 2.7 2.1 4.8 4.8 4.8 2.7 0 4.8-2.1 4.8-4.8 0-2.7-2.1-4.8-4.8-4.8zM0 6c0-3.3 2.7-6 6-6s6 2.7 6 6-2.7 6-6 6-6-2.7-6-6z\"\n    ></path>\n    <path\n      d=\"M5.4 4.5c0 .5-.4.9-.9.9s-.9-.4-.9-.9.4-.9.9-.9.9.4.9.9zM8.4 4.5c0 .5-.4.9-.9.9s-.9-.4-.9-.9.4-.9.9-.9.9.4.9.9zM3.3 6.7c.3-.2.6-.1.8.1.3.4.8.9 1.5 1 .6.2 1.4.1 2.4-1 .2-.2.6-.3.8 0 .2.2.3.6 0 .8-1.1 1.3-2.4 1.7-3.5 1.5-1-.2-1.8-.9-2.2-1.5-.2-.3-.1-.7.2-.9z\"\n    ></path>\n  </g>\n</svg>\n<svg\n  data-testid=\"connection-error\"\n  *ngIf=\"icon === 'connection-error'\"\n  width=\"78px\"\n  height=\"78px\"\n  viewBox=\"0 0 78 78\"\n  version=\"1.1\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n>\n  <!-- Generator: Sketch 52.6 (67491) - http://www.bohemiancoding.com/sketch -->\n  <title>Combined Shape</title>\n  <desc>Created with Sketch.</desc>\n  <g\n    id=\"Interactions\"\n    stroke=\"none\"\n    stroke-width=\"1\"\n    fill=\"none\"\n    fill-rule=\"evenodd\"\n  >\n    <g\n      id=\"Connection-Error-_-Connectivity\"\n      transform=\"translate(-270.000000, -30.000000)\"\n      fill=\"#CF1F25\"\n    >\n      <g\n        id=\"109-network-connection\"\n        transform=\"translate(270.000000, 30.000000)\"\n      >\n        <path\n          d=\"M66.4609744,11.414231 C81.6225232,26.5757798 81.6225232,51.157545 66.4609744,66.3188467 C51.2994256,81.4803954 26.7176604,81.4803954 11.5563587,66.3188467 C-3.60519004,51.1572979 -3.60519004,26.5755327 11.5563587,11.414231 C26.7179075,-3.74731776 51.2996727,-3.74731776 66.4609744,11.414231 Z M54.7853215,45.8823776 L54.7853215,40.5882574 C54.7853215,39.613638 53.9952341,38.8235506 53.0206147,38.8235506 L44.9576695,38.8235506 L41.428256,42.3529641 L51.255555,42.3529641 L51.255555,45.8823776 L54.7853215,45.8823776 Z M40.6659027,43.1153174 L37.8988425,45.8823776 L40.6659027,45.8823776 L40.6659027,43.1153174 Z M51.1764962,56.4702653 L58.2353232,56.4702653 C59.2099355,56.4702653 60.00003,55.6801708 60.00003,54.7055585 L60.00003,51.176145 C60.00003,50.2015327 59.2099355,49.4114382 58.2353232,49.4114382 L51.1764962,49.4114382 C50.2018839,49.4114382 49.4117894,50.2015327 49.4117894,51.176145 L49.4117894,54.7055585 C49.4117894,55.6801708 50.2018839,56.4702653 51.1764962,56.4702653 Z M35.2941353,56.4702653 L42.3529624,56.4702653 C43.3275746,56.4702653 44.1176691,55.6801708 44.1176691,54.7055585 L44.1176691,51.176145 C44.1176691,50.2015327 43.3275746,49.4114382 42.3529624,49.4114382 L35.2941353,49.4114382 C34.319523,49.4114382 33.5294285,50.2015327 33.5294285,51.176145 L33.5294285,54.7055585 C33.5294285,55.6801708 34.319523,56.4702653 35.2941353,56.4702653 Z M56.6964989,19.0874231 C56.007381,18.3985134 54.8903216,18.3985134 54.2012036,19.087423 L45.882376,27.4062507 L45.882376,19.4117761 C45.882376,18.4371568 45.0922885,17.6470693 44.1176692,17.6470693 L33.5294286,17.6470693 C32.5548092,17.6470694 31.7647218,18.4371568 31.7647218,19.4117761 L31.7647218,30.0000167 C31.7647219,30.9746363 32.5548092,31.7647237 33.5294285,31.7647237 L41.5239031,31.7647237 L34.4650761,38.8235508 L24.7058947,38.8235508 C23.7312753,38.8235508 22.9411879,39.6136382 22.9411879,40.5882575 L22.9411879,45.8823778 L26.4706014,45.8823778 L26.4706014,42.3529643 L30.9356624,42.3529643 L23.8768354,49.4117914 L19.4117743,49.4117914 C18.4371549,49.4117914 17.6470675,50.2018788 17.6470675,51.1764981 L17.6470675,54.7059117 C17.6504049,54.9674302 17.7129076,55.2248042 17.8298886,55.4587302 L16.4456526,56.8429662 C15.7446193,57.5200453 15.7252005,58.6372282 16.4022825,59.3382615 C17.0793616,60.0392948 18.1965445,60.0587136 18.8975778,59.3816316 C18.9122847,59.3674273 18.9267436,59.3529684 18.940948,59.3382615 L56.6964963,21.5830662 C57.3856425,20.8939094 57.3856425,19.7765747 56.6964963,19.0874179 Z\"\n          id=\"Combined-Shape\"\n        ></path>\n      </g>\n    </g>\n  </g>\n</svg>\n<svg\n  *ngIf=\"icon === 'send'\"\n  data-testid=\"send\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <title translate>streamChat.Send</title>\n  <path\n    d=\"M4.00952 22L24 12L4.00952 2L4 9.77778L18.2857 12L4 14.2222L4.00952 22Z\"\n    fill=\"black\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'file-upload'\"\n  data-testid=\"file-upload\"\n  height=\"14\"\n  width=\"14\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <title translate>streamChat.Attach files</title>\n  <path\n    d=\"M1.667.333h10.666c.737 0 1.334.597 1.334 1.334v10.666c0 .737-.597 1.334-1.334 1.334H1.667a1.333 1.333 0 0 1-1.334-1.334V1.667C.333.93.93.333 1.667.333zm2 1.334a1.667 1.667 0 1 0 0 3.333 1.667 1.667 0 0 0 0-3.333zm-2 9.333v1.333h10.666v-4l-2-2-4 4-2-2L1.667 11z\"\n    fillRule=\"nonzero\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'retry'\"\n  data-testid=\"retry\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M17.6449 6.35C16.1949 4.9 14.2049 4 11.9949 4C7.57488 4 4.00488 7.58 4.00488 12C4.00488 16.42 7.57488 20 11.9949 20C15.7249 20 18.8349 17.45 19.7249 14H17.6449C16.8249 16.33 14.6049 18 11.9949 18C8.68488 18 5.99488 15.31 5.99488 12C5.99488 8.69 8.68488 6 11.9949 6C13.6549 6 15.1349 6.69 16.2149 7.78L12.9949 11H19.9949V4L17.6449 6.35Z\"\n    fill=\"black\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'close'\"\n  data-testid=\"close\"\n  width=\"28\"\n  height=\"28\"\n  viewBox=\"0 0 28 28\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <rect width=\"28\" height=\"28\" rx=\"14\" fill=\"#72767E\" />\n  <circle cx=\"14\" cy=\"14\" r=\"12\" fill=\"#72767E\" />\n  <path\n    fill-rule=\"evenodd\"\n    clip-rule=\"evenodd\"\n    d=\"M28 14C28 21.732 21.732 28 14 28C6.26801 28 0 21.732 0 14C0 6.26801 6.26801 0 14 0C21.732 0 28 6.26801 28 14ZM26 14C26 20.6274 20.6274 26 14 26C7.37258 26 2 20.6274 2 14C2 7.37258 7.37258 2 14 2C20.6274 2 26 7.37258 26 14ZM19.59 7L21 8.41L15.41 14L21 19.59L19.59 21L14 15.41L8.41 21L7 19.59L12.59 14L7 8.41L8.41 7L14 12.59L19.59 7Z\"\n    fill=\"white\"\n  />\n</svg>\n\n<svg\n  *ngIf=\"icon === 'file'\"\n  data-testid=\"file\"\n  className=\"rfu-file-icon--small fa-file-fallback\"\n  [attr.height]=\"size || 20\"\n  [attr.width]=\"size || 20\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  viewBox=\"0 0 384 512\"\n>\n  <path\n    d=\"M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48z\"\n    fill=\"#414D54\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'unspecified-filetype'\"\n  data-testid=\"unspecified-filetype\"\n  width=\"34\"\n  height=\"40\"\n  viewBox=\"0 0 34 40\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M0 3C0 1.34315 1.34315 0 3 0H23L34 11V37C34 38.6569 32.6569 40 31 40H3C1.34315 40 0 38.6569 0 37V3Z\"\n    fill=\"url(#paint0_linear)\"\n  />\n  <path d=\"M34 11L26 11C24.3431 11 23 9.65685 23 8V0L34 11Z\" fill=\"#DBDBDB\" />\n  <path\n    fill-rule=\"evenodd\"\n    clip-rule=\"evenodd\"\n    d=\"M8 13H23V15H8V13Z\"\n    fill=\"#CFCFCF\"\n  />\n  <path\n    fill-rule=\"evenodd\"\n    clip-rule=\"evenodd\"\n    d=\"M8 17H18V19H8V17Z\"\n    fill=\"#CFCFCF\"\n  />\n  <path\n    fill-rule=\"evenodd\"\n    clip-rule=\"evenodd\"\n    d=\"M8 21H23V23H8V21Z\"\n    fill=\"#CFCFCF\"\n  />\n  <defs>\n    <linearGradient\n      id=\"paint0_linear\"\n      x1=\"0\"\n      y1=\"0\"\n      x2=\"0\"\n      y2=\"40\"\n      gradientUnits=\"userSpaceOnUse\"\n    >\n      <stop stop-color=\"white\" />\n      <stop offset=\"1\" stop-color=\"#DBDBDB\" />\n    </linearGradient>\n  </defs>\n</svg>\n<svg\n  *ngIf=\"icon === 'reply'\"\n  data-testid=\"reply\"\n  height=\"15\"\n  width=\"18\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M.56 10.946H.06l-.002-.498L.025.92a.5.5 0 1 1 1-.004l.032 9.029H9.06v-4l9 4.5-9 4.5v-4H.56z\"\n    fillRule=\"nonzero\"\n  />\n</svg>\n<svg\n  data-testid=\"close-no-outline\"\n  *ngIf=\"icon === 'close-no-outline'\"\n  viewBox=\"0 0 24 24\"\n  width=\"24\"\n  height=\"24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z\"\n    fill=\"black\"\n  />\n</svg>\n<svg\n  height=\"10\"\n  width=\"14\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  data-testid=\"reply-in-thread\"\n  *ngIf=\"icon === 'reply-in-thread'\"\n>\n  <path\n    d=\"M8.516 3c4.78 0 4.972 6.5 4.972 6.5-1.6-2.906-2.847-3.184-4.972-3.184v2.872L3.772 4.994 8.516.5V3zM.484 5l4.5-4.237v1.78L2.416 5l2.568 2.125v1.828L.484 5z\"\n    fillRule=\"evenodd\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'arrow-left'\"\n  data-testid=\"arrow-left\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M15.7049 7.41L14.2949 6L8.29492 12L14.2949 18L15.7049 16.59L11.1249 12L15.7049 7.41Z\"\n    fill=\"var(--black)\"\n  />\n</svg>\n\n<svg\n  *ngIf=\"icon === 'arrow-right'\"\n  data-testid=\"arrow-right\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M9.70492 6L8.29492 7.41L12.8749 12L8.29492 16.59L9.70492 18L15.7049 12L9.70492 6Z\"\n    fill=\"var(--black)\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'menu'\"\n  data-testid=\"menu\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    fill-rule=\"evenodd\"\n    clip-rule=\"evenodd\"\n    d=\"M3 8V6H21V8H3ZM3 13H21V11H3V13ZM3 18H21V16H3V18Z\"\n    fill=\"black\"\n  />\n</svg>\n\n<svg\n  data-testid=\"arrow-up\"\n  *ngIf=\"icon === 'arrow-up'\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M16.59 15.7051L12 11.1251L7.41 15.7051L6 14.2951L12 8.29508L18 14.2951L16.59 15.7051Z\"\n    fill=\"var(--primary-color)\"\n  />\n</svg>\n<svg\n  data-testid=\"arrow-down\"\n  *ngIf=\"icon === 'arrow-down'\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M7.41 8.29504L12 12.875L16.59 8.29504L18 9.70504L12 15.705L6 9.70504L7.41 8.29504Z\"\n    fill=\"var(--primary-color)\"\n  />\n</svg>\n<svg\n  data-testid=\"chat-bubble\"\n  *ngIf=\"icon === 'chat-bubble'\"\n  viewBox=\"0 0 136 136\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M106 24.5H30C24.775 24.5 20.5 28.775 20.5 34V119.5L39.5 100.5H106C111.225 100.5 115.5 96.225 115.5 91V34C115.5 28.775 111.225 24.5 106 24.5ZM106 91H39.5L30 100.5V34H106V91Z\"\n    fill=\"#B4B7BB\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'attach'\"\n  data-testid=\"attach\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <g clip-path=\"url(#clip0_10878_5)\">\n    <path\n      d=\"M12.9997 6.99993L10.9997 6.99993L10.9997 10.9999L6.99972 10.9999L6.99972 12.9999L10.9997 12.9999L10.9997 16.9999L12.9997 16.9999L12.9997 12.9999L16.9997 12.9999L16.9997 10.9999L12.9997 10.9999L12.9997 6.99993ZM11.9997 1.99992C6.47972 1.99992 1.99972 6.47993 1.99972 11.9999C1.99972 17.5199 6.47972 21.9999 11.9997 21.9999C17.5197 21.9999 21.9997 17.5199 21.9997 11.9999C21.9997 6.47993 17.5197 1.99992 11.9997 1.99992ZM11.9997 19.9999C7.58972 19.9999 3.99972 16.4099 3.99972 11.9999C3.99972 7.58993 7.58972 3.99993 11.9997 3.99993C16.4097 3.99993 19.9997 7.58993 19.9997 11.9999C19.9997 16.4099 16.4097 19.9999 11.9997 19.9999Z\"\n      fill=\"black\"\n    />\n  </g>\n  <defs>\n    <clipPath id=\"clip0_10878_5\">\n      <rect width=\"24\" height=\"24\" fill=\"white\" />\n    </clipPath>\n  </defs>\n</svg>\n<svg\n  *ngIf=\"icon === 'download'\"\n  data-testid=\"download\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    d=\"M19.35 10.04C18.67 6.59 15.64 4 12 4C9.11 4 6.6 5.64 5.35 8.04C2.34 8.36 0 10.91 0 14C0 17.31 2.69 20 6 20H19C21.76 20 24 17.76 24 15C24 12.36 21.95 10.22 19.35 10.04ZM19 18H6C3.79 18 2 16.21 2 14C2 11.95 3.53 10.24 5.56 10.03L6.63 9.92L7.13 8.97C8.08 7.14 9.94 6 12 6C14.62 6 16.88 7.86 17.39 10.43L17.69 11.93L19.22 12.04C20.78 12.14 22 13.45 22 15C22 16.65 20.65 18 19 18ZM13.45 10H10.55V13H8L12 17L16 13H13.45V10Z\"\n    fill=\"black\"\n  />\n</svg>\n<svg\n  *ngIf=\"icon === 'error'\"\n  data-testid=\"error\"\n  [attr.width]=\"size ?? 24\"\n  [attr.height]=\"size ?? 24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    id=\"background\"\n    d=\"M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2Z\"\n    fill=\"var(--str-chat__message-error-message-color)\"\n  />\n  <path d=\"M13 17H11V15H13V17ZM13 13H11V7H13V13Z\" fill=\"white\" />\n</svg>\n<svg\n  *ngIf=\"icon === 'play'\"\n  fill=\"none\"\n  viewBox=\"0 0 12 14\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path d=\"M0.5 0V14L11.5 7L0.5 0Z\" fill=\"#080707\" />\n</svg>\n<svg\n  *ngIf=\"icon === 'pause'\"\n  fill=\"none\"\n  viewBox=\"0 0 12 14\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path d=\"M0 14H4V0H0V14ZM8 0V14H12V0H8Z\" fill=\"#080707\" />\n</svg>\n\n<svg\n  *ngIf=\"icon === 'audio-file'\"\n  class=\"rfu-file-audio\"\n  fill=\"none\"\n  [attr.height]=\"size || 20\"\n  [attr.width]=\"size || 20\"\n  viewBox=\"0 0 34 40\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    clip-rule=\"evenodd\"\n    d=\"M17.7168 33.172C18.2348 33.172 18.4238 33.655 18.4238 34.18C18.4238 34.642 18.2978 35.195 17.7168 35.195C17.1708 35.195 16.9888 34.642 16.9888 34.145C16.9888 33.683 17.1708 33.172 17.7168 33.172ZM19.5718 31.002H18.3818V32.7589H18.3678C18.1228 32.43 17.7798 32.262 17.3318 32.262C16.3028 32.262 15.7988 33.158 15.7988 34.103C15.7988 35.125 16.2818 36.1049 17.4228 36.1049C17.8428 36.1049 18.1928 35.923 18.4238 35.58H18.4378V36H19.5718V31.002ZM12.7095 34.1872C12.7095 33.7252 12.8775 33.1722 13.4305 33.1722C13.9835 33.1722 14.1585 33.7252 14.1585 34.1872C14.1585 34.6492 13.9835 35.1952 13.4305 35.1952C12.8775 35.1952 12.7095 34.6492 12.7095 34.1872ZM11.5195 34.1872C11.5195 35.2792 12.3035 36.1052 13.4305 36.1052C14.5575 36.1052 15.3485 35.2792 15.3485 34.1872C15.3485 33.0952 14.5575 32.2622 13.4305 32.2622C12.3035 32.2622 11.5195 33.0952 11.5195 34.1872ZM21.839 32.3671H22.574V33.1371H21.839V34.7891C21.839 35.0761 22.007 35.1391 22.266 35.1391C22.3142 35.1391 22.364 35.1357 22.4147 35.1323C22.4672 35.1287 22.5206 35.1251 22.574 35.1251V36.0001C22.481 36.0031 22.388 36.0099 22.295 36.0168C22.171 36.0259 22.047 36.0351 21.923 36.0351C20.908 36.0351 20.649 35.7411 20.649 34.7541V33.1371H20.047V32.3671H20.649V31.2681H21.839V32.3671Z\"\n    fill=\"white\"\n    fill-rule=\"evenodd\"\n  ></path>\n  <path\n    d=\"M0 28H34V37C34 38.6569 32.6569 40 31 40H3C1.34315 40 0 38.6569 0 37V28Z\"\n    fill=\"#2727B0\"\n  ></path>\n  <path d=\"M0 3C0 1.34315 1.34315 0 3 0H23L34 11V28H0V3Z\" fill=\"#F5F5F5\"></path>\n  <path\n    d=\"M34 11L26 11C24.3431 11 23 9.65685 23 8V0L34 11Z\"\n    fill=\"#DBDBDB\"\n  ></path>\n  <path\n    clip-rule=\"evenodd\"\n    d=\"M8.87912 21.941H12.298L16.9521 24.7493C17.0307 24.8138 17.1293 24.849 17.2311 24.849C17.4738 24.8488 17.6705 24.6519 17.6703 24.4092V12.4399C17.6704 12.3381 17.6352 12.2396 17.5707 12.1609C17.4168 11.9732 17.1398 11.9457 16.9521 12.0996L12.298 14.908H8.87912C8.3936 14.908 8 15.3016 8 15.7871V21.0619C8 21.5474 8.3936 21.941 8.87912 21.941ZM12.9258 16.6664L15.9122 15.2224V21.6268L12.9258 20.1829H9.7583V16.6664H12.9258ZM19.8511 16.3517C19.474 16.4092 19.2397 16.6637 19.3283 16.9191L19.3262 16.92C19.5295 17.4995 19.6305 18.098 19.6284 18.6953C19.6305 19.2975 19.5237 19.9014 19.3196 20.4909C19.229 20.7462 19.4682 20.9996 19.8474 21.06C19.9008 21.0683 19.9542 21.072 20.0076 21.072C20.3259 21.072 20.6156 20.9234 20.6922 20.7057C20.9194 20.0451 21.0337 19.37 21.0374 18.6953C21.0349 18.0251 20.9211 17.3575 20.6955 16.7035C20.6053 16.4477 20.229 16.2908 19.8511 16.3517ZM22.1605 14.6028C22.5252 14.5163 22.9259 14.6454 23.055 14.8938C23.6891 16.1157 24 17.4042 24 18.6923C24.0004 19.9895 23.6796 21.2839 23.0521 22.5153C22.9503 22.7123 22.6763 22.8344 22.3828 22.8344C22.3071 22.8344 22.2301 22.8261 22.1543 22.8092C21.7863 22.7251 21.5914 22.4536 21.7185 22.2077C22.2988 21.0761 22.5922 19.8836 22.5931 18.6919C22.5931 17.5056 22.3054 16.3222 21.7276 15.2025C21.6001 14.9563 21.795 14.686 22.1605 14.6028Z\"\n    fill=\"#2727B0\"\n    fill-rule=\"evenodd\"\n  ></path>\n</svg>\n<svg\n  *ngIf=\"icon === 'read-icon'\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <path\n    fill-rule=\"evenodd\"\n    clip-rule=\"evenodd\"\n    d=\"M15.7071 7.29289C16.0976 7.68342 16.0976 8.31658 15.7071 8.70711L11.4142 13L13 14.5858L20.2929 7.29289C20.6834 6.90237 21.3166 6.90237 21.7071 7.29289C22.0976 7.68342 22.0976 8.31658 21.7071 8.70711L13.7071 16.7071C13.3166 17.0976 12.6834 17.0976 12.2929 16.7071L10 14.4142L7.70711 16.7071C7.31658 17.0976 6.68342 17.0976 6.29289 16.7071L6.29206 16.7063L2.29289 12.7071C1.90237 12.3166 1.90237 11.6834 2.29289 11.2929C2.68342 10.9024 3.31658 10.9024 3.70711 11.2929L7 14.5858L9.29214 12.2936L9.29289 12.2929L9.29364 12.2921L14.2929 7.29289C14.6834 6.90237 15.3166 6.90237 15.7071 7.29289Z\"\n    fill=\"black\"\n  />\n</svg>\n", directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i9__namespace.TranslateDirective, selector: "[translate],[ngx-translate]", inputs: ["translate", "translateParams"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: IconComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-icon',
                        templateUrl: './icon.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { icon: [{
                    type: i0.Input
                }], size: [{
                    type: i0.Input
                }] } });

    /**
     * The `IconPlaceholder` component displays the [default icons](./IconComponent.mdx) unless a [custom template](../services/CustomTemplatesService.mdx) is provided. This component is used by the SDK internally, you likely won't need to use it.
     */
    var IconPlaceholderComponent = /** @class */ (function () {
        function IconPlaceholderComponent(customTemplatesService) {
            this.customTemplatesService = customTemplatesService;
            this.iconContext = { icon: undefined, size: undefined };
        }
        IconPlaceholderComponent.prototype.ngOnChanges = function () {
            this.iconContext = {
                icon: this.icon,
                size: this.size,
            };
        };
        return IconPlaceholderComponent;
    }());
    IconPlaceholderComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: IconPlaceholderComponent, deps: [{ token: CustomTemplatesService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    IconPlaceholderComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: { icon: "icon", size: "size" }, usesOnChanges: true, ngImport: i0__namespace, template: "<ng-template #defaultIcon let-icon=\"icon\" let-size=\"size\">\n  <stream-icon [icon]=\"icon\" [size]=\"size\"></stream-icon>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.iconTemplate$ | async) || defaultIcon;\n    context: iconContext\n  \"\n></ng-container>\n", components: [{ type: IconComponent, selector: "stream-icon", inputs: ["icon", "size"] }], directives: [{ type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: IconPlaceholderComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-icon-placeholder',
                        templateUrl: './icon-placeholder.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: CustomTemplatesService }]; }, propDecorators: { icon: [{
                    type: i0.Input
                }], size: [{
                    type: i0.Input
                }] } });

    /**
     * The `LoadingIndicator` component displays a spinner to indicate that an action is in progress.
     */
    var LoadingIndicatorComponent = /** @class */ (function () {
        function LoadingIndicatorComponent() {
            /**
             * The size of the indicator (in pixels)
             */
            this.size = 15;
            /**
             * The color of the indicator
             */
            this.color = "var(--str-chat__loading-indicator-color, var(--str-chat__primary-color, '#006CFF'))";
            this.linearGradientId = uuid.v4();
        }
        return LoadingIndicatorComponent;
    }());
    LoadingIndicatorComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: LoadingIndicatorComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    LoadingIndicatorComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: LoadingIndicatorComponent, selector: "stream-loading-indicator", inputs: { size: "size", color: "color" }, ngImport: i0__namespace, template: "<div class=\"str-chat__loading-indicator\">\n  <svg\n    [attr.height]=\"size\"\n    viewBox=\"0 0 30 30\"\n    [attr.width]=\"size\"\n    data-testid=\"loading-indicator\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <defs>\n      <linearGradient\n        id=\"{{ linearGradientId }}\"\n        x1=\"50%\"\n        x2=\"50%\"\n        y1=\"0%\"\n        y2=\"100%\"\n      >\n        <stop offset=\"0%\" stop-color=\"#FFF\" stop-opacity=\"0\" />\n        <stop\n          data-testid=\"stop-color\"\n          offset=\"100%\"\n          [attr.stop-color]=\"color\"\n          stop-opacity=\"1\"\n          [ngStyle]=\"{ stopColor: color }\"\n        />\n      </linearGradient>\n    </defs>\n    <path\n      d=\"M2.518 23.321l1.664-1.11A12.988 12.988 0 0 0 15 28c7.18 0 13-5.82 13-13S22.18 2 15 2V0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-5.206 0-9.792-2.652-12.482-6.679z\"\n      [attr.fill]=\"'url(#' + linearGradientId + ')'\"\n      fillRule=\"evenodd\"\n    />\n  </svg>\n</div>\n", directives: [{ type: i8__namespace.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: LoadingIndicatorComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-loading-indicator',
                        templateUrl: './loading-indicator.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { size: [{
                    type: i0.Input
                }], color: [{
                    type: i0.Input
                }] } });

    /**
     * The `LoadingInficatorPlaceholder` component displays the [default loading indicator](./LoadingIndicatorComponent.mdx) unless a [custom template](../services/CustomTemplatesService.mdx) is provided. This component is used by the SDK internally, you likely won't need to use it.
     */
    var LoadingIndicatorPlaceholderComponent = /** @class */ (function () {
        function LoadingIndicatorPlaceholderComponent(customTemplatesService) {
            this.customTemplatesService = customTemplatesService;
            /**
             * The size of the indicator (in pixels)
             */
            this.size = 15;
            /**
             * The color of the indicator
             */
            this.color = "var(--str-chat__loading-indicator-color, var(--str-chat__primary-color, '#006CFF'))";
        }
        LoadingIndicatorPlaceholderComponent.prototype.getLoadingIndicatorContext = function () {
            return {
                size: this.size,
                color: this.color,
            };
        };
        return LoadingIndicatorPlaceholderComponent;
    }());
    LoadingIndicatorPlaceholderComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: LoadingIndicatorPlaceholderComponent, deps: [{ token: CustomTemplatesService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    LoadingIndicatorPlaceholderComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder", inputs: { size: "size", color: "color" }, ngImport: i0__namespace, template: "<ng-template #defaultLoadingIndicator let-size=\"size\" let-color=\"color\">\n  <stream-loading-indicator\n    [size]=\"size\"\n    [color]=\"color\"\n  ></stream-loading-indicator>\n</ng-template>\n<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.loadingIndicatorTemplate$ | async) ||\n      defaultLoadingIndicator;\n    context: getLoadingIndicatorContext()\n  \"\n></ng-container>\n", components: [{ type: LoadingIndicatorComponent, selector: "stream-loading-indicator", inputs: ["size", "color"] }], directives: [{ type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: LoadingIndicatorPlaceholderComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-loading-indicator-placeholder',
                        templateUrl: './loading-indicator-placeholder.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: CustomTemplatesService }]; }, propDecorators: { size: [{
                    type: i0.Input
                }], color: [{
                    type: i0.Input
                }] } });

    /**
     * The message actions service provides customization options for the [message actions](../../components/MessageActionsBoxComponent)
     */
    var MessageActionsService = /** @class */ (function () {
        function MessageActionsService(chatClientService, notificationService, channelService) {
            var _this = this;
            this.chatClientService = chatClientService;
            this.notificationService = notificationService;
            this.channelService = channelService;
            /**
             * Default actions - these are the actions that are handled by the built-in component
             */
            this.defaultActions = [
                {
                    actionName: 'mark-unread',
                    actionLabelOrTranslationKey: 'streamChat.Mark as unread',
                    actionHandler: function (message) { return _this.channelService.markMessageUnread(message.id); },
                    isVisible: function (enabledActions, isMine, message) { return enabledActions.indexOf('read-events') !== -1 && !message.parent_id; },
                },
                {
                    actionName: 'quote',
                    actionLabelOrTranslationKey: 'streamChat.Reply',
                    actionHandler: function (message) { return _this.channelService.selectMessageToQuote(message); },
                    isVisible: function (enabledActions) { return enabledActions.indexOf('quote-message') !== -1; },
                },
                {
                    actionName: 'pin',
                    actionLabelOrTranslationKey: function (message) { return message.pinned ? 'streamChat.Unpin' : 'streamChat.Pin'; },
                    actionHandler: function (message) { return message.pinned
                        ? _this.channelService.unpinMessage(message)
                        : _this.channelService.pinMessage(message); },
                    isVisible: function (enabledActions) { return enabledActions.indexOf('pin-message') !== -1; },
                },
                {
                    actionName: 'flag',
                    actionLabelOrTranslationKey: 'streamChat.Flag',
                    actionHandler: function (message) { return __awaiter(_this, void 0, void 0, function () {
                        var err_1;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _b.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, this.chatClientService.flagMessage(message.id)];
                                case 1:
                                    _b.sent();
                                    this.notificationService.addTemporaryNotification('streamChat.Message has been successfully flagged', 'success');
                                    return [3 /*break*/, 3];
                                case 2:
                                    err_1 = _b.sent();
                                    this.notificationService.addTemporaryNotification('streamChat.Error adding flag');
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); },
                    isVisible: function (enabledActions, isMine) { return enabledActions.indexOf('flag-message') !== -1 && !isMine; },
                },
                {
                    actionName: 'edit',
                    actionLabelOrTranslationKey: 'streamChat.Edit Message',
                    actionHandler: function (message) {
                        _this.messageToEdit$.next(message);
                    },
                    isVisible: function (enabledActions, isMine) { return (enabledActions.indexOf('update-own-message') !== -1 && isMine) ||
                        enabledActions.indexOf('update-any-message') !== -1; },
                },
                {
                    actionName: 'delete',
                    actionLabelOrTranslationKey: 'streamChat.Delete',
                    actionHandler: function (message) { return __awaiter(_this, void 0, void 0, function () {
                        var error_1;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _b.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, this.channelService.deleteMessage(message)];
                                case 1:
                                    _b.sent();
                                    return [3 /*break*/, 3];
                                case 2:
                                    error_1 = _b.sent();
                                    this.notificationService.addTemporaryNotification('streamChat.Error deleting message');
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); },
                    isVisible: function (enabledActions, isMine) { return ((enabledActions.indexOf('delete') !== -1 ||
                        enabledActions.indexOf('delete-own-message') !== -1) &&
                        isMine) ||
                        enabledActions.indexOf('delete-any') !== -1 ||
                        enabledActions.indexOf('delete-any-message') !== -1; },
                },
            ];
            /**
             * The built-in components will handle changes to this observable.
             */
            this.messageToEdit$ = new rxjs.BehaviorSubject(undefined);
            /**
             * You can pass your own custom actions that will be displayed inside the built-in message actions component
             */
            this.customActions$ = new rxjs.BehaviorSubject([]);
        }
        /**
         * This method returns how many authorized actions are available to the given message
         *
         * @param message
         * @param enabledActions
         * @returns the count
         */
        MessageActionsService.prototype.getAuthorizedMessageActionsCount = function (message, enabledActions) {
            var _a;
            var customActions = this.customActions$.getValue() || [];
            var allActions = __spreadArray(__spreadArray([], __read(this.defaultActions)), __read(customActions));
            var currentUserId = (_a = this.chatClientService.chatClient.user) === null || _a === void 0 ? void 0 : _a.id;
            var isMine = message.user_id === currentUserId;
            return allActions.filter(function (item) { return item.isVisible(enabledActions, isMine, message); }).length;
        };
        return MessageActionsService;
    }());
    MessageActionsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageActionsService, deps: [{ token: ChatClientService }, { token: NotificationService }, { token: ChannelService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MessageActionsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageActionsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageActionsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: ChatClientService }, { type: NotificationService }, { type: ChannelService }]; } });

    /**
     * The `MessageActionsBox` component displays a list of message actions (i.e edit), that can be opened or closed. You can find the [list of the supported actions](../concepts/message-interactions.mdx) in the message interaction guide.
     */
    var MessageActionsBoxComponent = /** @class */ (function () {
        function MessageActionsBoxComponent(customTemplatesService, messageActionsService, cdRef) {
            this.customTemplatesService = customTemplatesService;
            this.messageActionsService = messageActionsService;
            this.cdRef = cdRef;
            /**
             * Indicates if the list should be opened or closed. Adding a UI element to open and close the list is the parent's component responsibility.
             * @deprecated No need for this since [theme-v2](../theming/introduction.mdx)
             */
            this.isOpen = false;
            /**
             * Indicates if the message actions are belonging to a message that was sent by the current user or not.
             */
            this.isMine = false;
            /**
             * The list of [channel capabilities](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript) that are enabled for the current user, the list of [supported interactions](../concepts/message-interactions.mdx) can be found in our message interaction guide. Unathorized actions won't be displayed on the UI.
             */
            this.enabledActions = [];
            /**
             * A list of custom message actions to be displayed in the action box
             *
             * In the next major release this will be released with `messageReactionsService.customActions$`
             *
             * More information: https://getstream.io/chat/docs/sdk/angular/services/MessageActionsService
             */
            this.customActions = [];
            /**
             * The number of authorized actions (it can be less or equal than the number of enabled actions)
             *
             * @deprecated components should use `messageReactionsService.getAuthorizedMessageActionsCount` method
             *
             * More information: https://getstream.io/chat/docs/sdk/angular/services/MessageActionsService
             */
            this.displayedActionsCount = new i0.EventEmitter();
            /**
             * An event which emits `true` if the edit message modal is open, and `false` when it is closed.
             *
             * @deprecated components should use `messageReactionsService.messageToEdit$` Observable
             *
             * More information: https://getstream.io/chat/docs/sdk/angular/services/MessageActionsService
             */
            this.isEditing = new i0.EventEmitter();
            this.visibleMessageActionItems = [];
            this.isEditModalOpen = false;
            this.subscriptions = [];
            this.isViewInited = false;
            this.messageActionItems = this.messageActionsService.defaultActions;
        }
        MessageActionsBoxComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.messageActionsService.messageToEdit$.subscribe(function (m) {
                var _a;
                var isEditModalOpen = false;
                if (m && m.id === ((_a = _this.message) === null || _a === void 0 ? void 0 : _a.id)) {
                    isEditModalOpen = true;
                }
                if (isEditModalOpen !== _this.isEditModalOpen) {
                    _this.isEditModalOpen = isEditModalOpen;
                    _this.isEditing.emit(_this.isEditModalOpen);
                    if (_this.isViewInited) {
                        _this.cdRef.detectChanges();
                    }
                }
            }));
        };
        MessageActionsBoxComponent.prototype.ngOnChanges = function (changes) {
            if (changes.isMine ||
                changes.enabledActions ||
                changes.message ||
                changes.customActions) {
                this.setVisibleActions();
            }
        };
        MessageActionsBoxComponent.prototype.ngAfterViewInit = function () {
            this.isViewInited = true;
        };
        MessageActionsBoxComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        MessageActionsBoxComponent.prototype.getActionLabel = function (actionLabelOrTranslationKey) {
            return typeof actionLabelOrTranslationKey === 'string'
                ? actionLabelOrTranslationKey
                : actionLabelOrTranslationKey(this.message);
        };
        MessageActionsBoxComponent.prototype.getMessageActionTemplateContext = function (item) {
            return {
                actionHandler: item.actionHandler,
                isMine: this.isMine,
                actionName: item.actionName,
                message: this.message,
                actionLabelOrTranslationKey: item.actionLabelOrTranslationKey,
            };
        };
        MessageActionsBoxComponent.prototype.trackByActionName = function (_, item) {
            return item.actionName;
        };
        MessageActionsBoxComponent.prototype.setVisibleActions = function () {
            var _this = this;
            this.visibleMessageActionItems = __spreadArray(__spreadArray([], __read(this.messageActionItems)), __read(this.customActions)).filter(function (item) { return item.isVisible(_this.enabledActions, _this.isMine, _this.message); });
            this.displayedActionsCount.emit(this.visibleMessageActionItems.length);
        };
        return MessageActionsBoxComponent;
    }());
    MessageActionsBoxComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageActionsBoxComponent, deps: [{ token: CustomTemplatesService }, { token: MessageActionsService }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MessageActionsBoxComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: MessageActionsBoxComponent, selector: "stream-message-actions-box", inputs: { isOpen: "isOpen", isMine: "isMine", message: "message", enabledActions: "enabledActions", customActions: "customActions" }, outputs: { displayedActionsCount: "displayedActionsCount", isEditing: "isEditing" }, usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  #actionBox\n  data-testid=\"action-box\"\n  class=\"str-chat__message-actions-box str-chat__message-actions-box-angular\"\n  [class.str-chat__message-actions-box--open]=\"true\"\n>\n  <ul class=\"str-chat__message-actions-list\">\n    <ng-container\n      *ngFor=\"let item of visibleMessageActionItems; trackBy: trackByActionName\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.messageActionsBoxItemTemplate$ | async) ||\n            defaultMessageActionItem;\n          context: getMessageActionTemplateContext(item)\n        \"\n      ></ng-container>\n    </ng-container>\n  </ul>\n</div>\n\n<ng-template\n  #defaultMessageActionItem\n  let-actionName=\"actionName\"\n  let-actionHandler=\"actionHandler\"\n  let-actionLabelOrTranslationKey=\"actionLabelOrTranslationKey\"\n>\n  <button\n    class=\"str-chat__message-actions-list-item-button\"\n    [attr.data-testid]=\"actionName + '-action'\"\n    (click)=\"actionHandler(message, isMine)\"\n  >\n    <li class=\"str-chat__message-actions-list-item\">\n      {{ getActionLabel(actionLabelOrTranslationKey) | translate }}\n    </li>\n  </button>\n</ng-template>\n", directives: [{ type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageActionsBoxComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-message-actions-box',
                        templateUrl: './message-actions-box.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: MessageActionsService }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { isOpen: [{
                    type: i0.Input
                }], isMine: [{
                    type: i0.Input
                }], message: [{
                    type: i0.Input
                }], enabledActions: [{
                    type: i0.Input
                }], customActions: [{
                    type: i0.Input
                }], displayedActionsCount: [{
                    type: i0.Output
                }], isEditing: [{
                    type: i0.Output
                }] } });

    /**
     * The `Modal` component displays its content in an overlay. The modal can be closed with a close button, if the user clicks outside of the modal content, or if the escape button is pressed. The modal can also be closed from outside.
     */
    var ModalComponent = /** @class */ (function () {
        function ModalComponent() {
            var _this = this;
            /**
             * If `true` the modal will be displayed, if `false` the modal will be hidden
             */
            this.isOpen = false;
            /**
             * Emits `true` if the modal becomes visible, and `false` if the modal is closed.
             */
            this.isOpenChange = new i0.EventEmitter();
            this.watchForEscPress = function (event) {
                if (event.key === 'Escape') {
                    _this.close();
                }
            };
            this.stopWatchForEscPress = function () {
                window.removeEventListener('keyup', _this.watchForEscPress);
            };
            this.watchForOutsideClicks = function (event) {
                var _a;
                if (!((_a = _this.innerContainer) === null || _a === void 0 ? void 0 : _a.nativeElement.contains(event.target))) {
                    _this.close();
                }
            };
        }
        ModalComponent.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (changes.isOpen) {
                if (this.isOpen) {
                    window.addEventListener('keyup', this.watchForEscPress);
                    setTimeout(function () { return window.addEventListener('click', _this.watchForOutsideClicks); }, 0);
                }
                else {
                    this.stopWatchForOutsideClicks();
                    this.stopWatchForEscPress();
                }
            }
        };
        ModalComponent.prototype.close = function () {
            this.isOpen = false;
            this.isOpenChange.emit(false);
            this.stopWatchForOutsideClicks();
            this.stopWatchForEscPress();
        };
        ModalComponent.prototype.stopWatchForOutsideClicks = function () {
            window.removeEventListener('click', this.watchForOutsideClicks);
        };
        return ModalComponent;
    }());
    ModalComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ModalComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    ModalComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: ModalComponent, selector: "stream-modal", inputs: { isOpen: "isOpen", content: "content" }, outputs: { isOpenChange: "isOpenChange" }, viewQueries: [{ propertyName: "innerContainer", first: true, predicate: ["modalInner"], descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  data-testid=\"modal\"\n  class=\"str-chat__modal str-chat__modal--{{ isOpen ? 'open' : 'close' }}\"\n>\n  <div\n    data-testid=\"close\"\n    class=\"str-chat__modal__close-button\"\n    (click)=\"close()\"\n    (keyup.enter)=\"close()\"\n  >\n    <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n  </div>\n  <div class=\"str-chat__modal__inner\" #modalInner>\n    <ng-container *ngIf=\"content; else elseContent\">\n      <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n    </ng-container>\n    <ng-template #elseContent>\n      <ng-content></ng-content>\n    </ng-template>\n  </div>\n</div>\n", components: [{ type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ModalComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-modal',
                        templateUrl: './modal.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { isOpen: [{
                    type: i0.Input
                }], content: [{
                    type: i0.Input
                }], isOpenChange: [{
                    type: i0.Output
                }], innerContainer: [{
                    type: i0.ViewChild,
                    args: ['modalInner']
                }] } });

    var textareaInjectionToken = new i0.InjectionToken('textareaInjectionToken');

    var TextareaDirective = /** @class */ (function () {
        function TextareaDirective(viewContainerRef) {
            this.viewContainerRef = viewContainerRef;
            this.value = '';
            this.valueChange = new i0.EventEmitter();
            this.send = new i0.EventEmitter();
            this.userMentions = new i0.EventEmitter();
            this.subscriptions = [];
            this.unpropagatedChanges = [];
        }
        TextareaDirective.prototype.ngOnChanges = function (changes) {
            var _this = this;
            var _a, _b;
            this.unpropagatedChanges.push(changes);
            if (!this.componentRef) {
                return;
            }
            if (changes.componentRef) {
                this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
                if (this.componentRef) {
                    this.subscriptions.push(this.componentRef.instance.valueChange.subscribe(function (value) { return _this.valueChange.next(value); }));
                    this.subscriptions.push(this.componentRef.instance.send.subscribe(function (value) { return _this.send.next(value); }));
                    if (this.componentRef.instance.userMentions) {
                        this.subscriptions.push(this.componentRef.instance.userMentions.subscribe(function (value) { return _this.userMentions.next(value); }));
                    }
                    this.componentRef.instance.areMentionsEnabled = this.areMentionsEnabled;
                    this.componentRef.instance.mentionScope = this.mentionScope;
                    this.componentRef.instance.value = this.value;
                    this.componentRef.instance.placeholder = this.placeholder;
                    this.componentRef.instance.inputMode = this.inputMode;
                    this.componentRef.instance.autoFocus = this.autoFocus;
                }
            }
            if (changes.areMentionsEnabled) {
                this.componentRef.instance.areMentionsEnabled = this.areMentionsEnabled;
            }
            if (changes.mentionScope) {
                this.componentRef.instance.mentionScope = this.mentionScope;
            }
            if (changes.value) {
                this.componentRef.instance.value = this.value;
            }
            if (changes.placeholder) {
                this.componentRef.instance.placeholder = this.placeholder;
            }
            if (changes.inputMode) {
                this.componentRef.instance.inputMode = this.inputMode;
            }
            if (changes.autoFocus) {
                this.componentRef.instance.autoFocus = this.autoFocus;
            }
            // ngOnChanges not called for dynamic components since we don't use template binding
            var changesToPropagate = {};
            this.unpropagatedChanges.forEach(function (c) { return (changesToPropagate = Object.assign(Object.assign({}, changesToPropagate), c)); });
            // eslint-disable-next-line @angular-eslint/no-lifecycle-call
            (_b = (_a = this.componentRef.instance).ngOnChanges) === null || _b === void 0 ? void 0 : _b.call(_a, changesToPropagate);
            this.unpropagatedChanges = [];
        };
        return TextareaDirective;
    }());
    TextareaDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TextareaDirective, deps: [{ token: i0__namespace.ViewContainerRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    TextareaDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.5", type: TextareaDirective, selector: "[streamTextarea]", inputs: { componentRef: "componentRef", areMentionsEnabled: "areMentionsEnabled", mentionScope: "mentionScope", inputMode: "inputMode", value: "value", placeholder: "placeholder", autoFocus: "autoFocus" }, outputs: { valueChange: "valueChange", send: "send", userMentions: "userMentions" }, usesOnChanges: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TextareaDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[streamTextarea]',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ViewContainerRef }]; }, propDecorators: { componentRef: [{
                    type: i0.Input
                }], areMentionsEnabled: [{
                    type: i0.Input
                }], mentionScope: [{
                    type: i0.Input
                }], inputMode: [{
                    type: i0.Input
                }], value: [{
                    type: i0.Input
                }], placeholder: [{
                    type: i0.Input
                }], autoFocus: [{
                    type: i0.Input
                }], valueChange: [{
                    type: i0.Output
                }], send: [{
                    type: i0.Output
                }], userMentions: [{
                    type: i0.Output
                }] } });

    /**
     * If you have an emoji picker in your application, you can propagate the selected emoji to the textarea using this service, more info can be found in [custom emoji picker guide](../code-examples/emoji-picker.mdx)
     */
    var EmojiInputService = /** @class */ (function () {
        function EmojiInputService() {
            /**
             * If you have an emoji picker in your application, you can propagate the selected emoji to the textarea using this Subject, more info can be found in [custom emoji picker guide](../code-examples/emoji-picker.mdx)
             */
            this.emojiInput$ = new rxjs.Subject();
        }
        return EmojiInputService;
    }());
    EmojiInputService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: EmojiInputService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    EmojiInputService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: EmojiInputService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: EmojiInputService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    /**
     * The `MessageInputConfigService` is used to keep a consistent configuration among the different [`MessageInput`](../components/MessageInputComponent.mdx) components if your UI has more than one input component.
     */
    var MessageInputConfigService = /** @class */ (function () {
        function MessageInputConfigService() {
            /**
             * If file upload is enabled, the user can open a file selector from the input. Please note that the user also needs to have the necessary [channel capability](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript).
             */
            this.isFileUploadEnabled = true;
            /**
             * If true, users can mention other users in messages. You also [need to use the `AutocompleteTextarea`](../concepts/opt-in-architecture.mdx) for this feature to work.
             */
            this.areMentionsEnabled = true;
            /**
             * If `false`, users can only upload one attachment per message
             */
            this.isMultipleFileUploadEnabled = true;
            /**
             * The scope for user mentions, either members of the current channel of members of the application
             */
            this.mentionScope = 'channel';
            /**
             * In `desktop` mode the `Enter` key will trigger message sending, in `mobile` mode the `Enter` key will insert a new line to the message input.
             */
            this.inputMode = 'desktop';
        }
        return MessageInputConfigService;
    }());
    MessageInputConfigService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageInputConfigService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MessageInputConfigService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageInputConfigService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageInputConfigService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    /**
     * This component can be used to visualize the wave bar of a voice recording
     */
    var VoiceRecordingWavebarComponent = /** @class */ (function () {
        function VoiceRecordingWavebarComponent(ngZone, cdRef) {
            var _this = this;
            this.ngZone = ngZone;
            this.cdRef = cdRef;
            /**
             * The waveform data to visualize
             */
            this.waveFormData = [];
            this.resampledWaveFormData = [];
            this.progress = 0;
            this.isDragging = false;
            this.sampleSize = 40;
            this.isViewInited = false;
            this.upsample = function () {
                if (_this.sampleSize === _this.waveFormData.length)
                    return _this.waveFormData;
                // eslint-disable-next-line  prefer-const
                var _f = __read(_this.divMod(_this.sampleSize, _this.waveFormData.length), 2), bucketSize = _f[0], remainder = _f[1];
                var result = [];
                for (var i = 0; i < _this.waveFormData.length; i++) {
                    var extra = remainder && remainder-- ? 1 : 0;
                    result.push.apply(result, __spreadArray([], __read(Array(bucketSize + extra).fill(_this.waveFormData[i]))));
                }
                return result;
            };
            this.getNextBucketMean = function (data, currentBucketIndex, bucketSize) {
                var nextBucketStartIndex = Math.floor(currentBucketIndex * bucketSize) + 1;
                var nextNextBucketStartIndex = Math.floor((currentBucketIndex + 1) * bucketSize) + 1;
                nextNextBucketStartIndex =
                    nextNextBucketStartIndex < data.length
                        ? nextNextBucketStartIndex
                        : data.length;
                return _this.mean(data.slice(nextBucketStartIndex, nextNextBucketStartIndex));
            };
            this.mean = function (values) { return values.reduce(function (acc, value) { return acc + value; }, 0) / values.length; };
            this.triangleAreaHeron = function (a, b, c) {
                var s = (a + b + c) / 2;
                return Math.sqrt(s * (s - a) * (s - b) * (s - c));
            };
            this.triangleBase = function (a, b) { return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)); };
            this.divMod = function (num, divisor) {
                return [Math.floor(num / divisor), num % divisor];
            };
        }
        VoiceRecordingWavebarComponent.prototype.ngOnInit = function () {
            var _this = this;
            var _a;
            this.containerSizeChanged();
            if ((_a = this.container) === null || _a === void 0 ? void 0 : _a.nativeElement) {
                this.ngZone.runOutsideAngular(function () {
                    new ResizeObserver(function () {
                        _this.containerSizeChanged();
                    }).observe(_this.container.nativeElement);
                });
            }
        };
        VoiceRecordingWavebarComponent.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (changes.waveFormData) {
                this.resampledWaveFormData =
                    this.waveFormData.length > this.sampleSize
                        ? this.downsample()
                        : this.upsample();
            }
            if (changes.audioElement) {
                this.ngZone.runOutsideAngular(function () {
                    var _a;
                    (_a = _this.audioElement) === null || _a === void 0 ? void 0 : _a.addEventListener('timeupdate', function () {
                        var _a;
                        var progress = (((_a = _this.audioElement) === null || _a === void 0 ? void 0 : _a.currentTime) || 0) / (_this.duration || 0) || 0;
                        if (Math.abs(progress - _this.progress) >= 0.02) {
                            _this.ngZone.run(function () {
                                _this.progress = progress;
                                _this.cdRef.detectChanges();
                            });
                        }
                    });
                });
            }
        };
        VoiceRecordingWavebarComponent.prototype.ngAfterViewInit = function () {
            this.isViewInited = true;
        };
        VoiceRecordingWavebarComponent.prototype.seek = function (event) {
            var _a, _b, _c, _d, _e;
            var containerWidth = ((_b = (_a = this.container) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect().width) || 0;
            var containerStart = ((_e = (_d = (_c = this.container) === null || _c === void 0 ? void 0 : _c.nativeElement) === null || _d === void 0 ? void 0 : _d.getBoundingClientRect()) === null || _e === void 0 ? void 0 : _e.x) || 0;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            var progress = (event.x - containerStart) / containerWidth;
            if (!isNaN(progress) && this.audioElement) {
                var duration = this.duration || 0;
                var time = duration * progress;
                this.audioElement.currentTime = time;
            }
        };
        VoiceRecordingWavebarComponent.prototype.trackByIndex = function (index) {
            return index;
        };
        VoiceRecordingWavebarComponent.prototype.containerSizeChanged = function () {
            var _this = this;
            var _a;
            if (!((_a = this.container) === null || _a === void 0 ? void 0 : _a.nativeElement)) {
                return;
            }
            var containerWidth = this.container.nativeElement.clientWidth;
            if (containerWidth === 0) {
                return;
            }
            var barWidth = +getComputedStyle(this.container.nativeElement)
                .getPropertyValue('--str-chat__voice-recording-amplitude-bar-width')
                .replace('px', '');
            var barGap = +getComputedStyle(this.container.nativeElement)
                .getPropertyValue('--str-chat__voice-recording-amplitude-bar-gap-width')
                .replace('px', '');
            if (!isNaN(barWidth) && !isNaN(barGap)) {
                var sampleSize_1 = Math.floor(containerWidth / (barWidth + barGap));
                if (sampleSize_1 !== this.sampleSize &&
                    !isNaN(sampleSize_1) &&
                    sampleSize_1 !== Infinity) {
                    this.ngZone.run(function () {
                        _this.sampleSize = sampleSize_1;
                        _this.resampledWaveFormData =
                            _this.waveFormData.length > _this.sampleSize
                                ? _this.downsample()
                                : _this.upsample();
                        if (_this.isViewInited) {
                            _this.cdRef.detectChanges();
                        }
                    });
                }
            }
        };
        VoiceRecordingWavebarComponent.prototype.downsample = function () {
            if (this.waveFormData.length <= this.sampleSize) {
                return this.waveFormData;
            }
            if (this.sampleSize === 1)
                return [this.mean(this.waveFormData)];
            var result = [];
            // bucket size adjusted due to the fact that the first and the last item in the original data array is kept in target output
            var bucketSize = (this.waveFormData.length - 2) / (this.sampleSize - 2);
            var lastSelectedPointIndex = 0;
            result.push(this.waveFormData[lastSelectedPointIndex]); // Always add the first point
            var maxAreaPoint, maxArea, triangleArea;
            for (var bucketIndex = 1; bucketIndex < this.sampleSize - 1; bucketIndex++) {
                var previousBucketRefPoint = this.waveFormData[lastSelectedPointIndex];
                var nextBucketMean = this.getNextBucketMean(this.waveFormData, bucketIndex, bucketSize);
                var currentBucketStartIndex = Math.floor((bucketIndex - 1) * bucketSize) + 1;
                var nextBucketStartIndex = Math.floor(bucketIndex * bucketSize) + 1;
                var countUnitsBetweenAtoC = 1 + nextBucketStartIndex - currentBucketStartIndex;
                maxArea = triangleArea = -1;
                for (var currentPointIndex = currentBucketStartIndex; currentPointIndex < nextBucketStartIndex; currentPointIndex++) {
                    var countUnitsBetweenAtoB = Math.abs(currentPointIndex - currentBucketStartIndex) + 1;
                    var countUnitsBetweenBtoC = countUnitsBetweenAtoC - countUnitsBetweenAtoB;
                    var currentPointValue = this.waveFormData[currentPointIndex];
                    triangleArea = this.triangleAreaHeron(this.triangleBase(Math.abs(previousBucketRefPoint - currentPointValue), countUnitsBetweenAtoB), this.triangleBase(Math.abs(currentPointValue - nextBucketMean), countUnitsBetweenBtoC), this.triangleBase(Math.abs(previousBucketRefPoint - nextBucketMean), countUnitsBetweenAtoC));
                    if (triangleArea > maxArea) {
                        maxArea = triangleArea;
                        maxAreaPoint = this.waveFormData[currentPointIndex];
                        lastSelectedPointIndex = currentPointIndex;
                    }
                }
                if (typeof maxAreaPoint !== 'undefined')
                    result.push(maxAreaPoint);
            }
            result.push(this.waveFormData[this.waveFormData.length - 1]); // Always add the last point
            return result;
        };
        return VoiceRecordingWavebarComponent;
    }());
    VoiceRecordingWavebarComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: VoiceRecordingWavebarComponent, deps: [{ token: i0__namespace.NgZone }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    VoiceRecordingWavebarComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: VoiceRecordingWavebarComponent, selector: "stream-voice-recording-wavebar", inputs: { audioElement: "audioElement", waveFormData: "waveFormData", duration: "duration" }, viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  class=\"str-chat__wave-progress-bar__track\"\n  #container\n  data-testid=\"wave-progress-bar-track\"\n  (mousedown)=\"isDragging = true\"\n  (mouseup)=\"isDragging = false\"\n  (mouseleave)=\"isDragging = false\"\n  (mousemove)=\"isDragging ? seek($event) : null\"\n  (click)=\"seek($event)\"\n  (keyup.enter)=\"seek($event)\"\n  role=\"progressbar\"\n>\n  <div\n    *ngFor=\"\n      let dataPoint of resampledWaveFormData;\n      let i = index;\n      trackBy: trackByIndex\n    \"\n    class=\"str-chat__wave-progress-bar__amplitude-bar\"\n    [class.str-chat__wave-progress-bar__amplitude-bar--active]=\"\n      progress > i / resampledWaveFormData.length\n    \"\n    [style.--str-chat__wave-progress-bar__amplitude-bar-height]=\"\n      dataPoint ? dataPoint * 100 + '%' : '0%'\n    \"\n  ></div>\n  <div\n    class=\"str-chat__wave-progress-bar__progress-indicator\"\n    data-testid=\"wave-progress-bar-progress-indicator\"\n    [ngStyle]=\"{ 'inset-inline-start': progress * 100 + '%' }\"\n  ></div>\n</div>\n", directives: [{ type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8__namespace.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: VoiceRecordingWavebarComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-voice-recording-wavebar',
                        templateUrl: './voice-recording-wavebar.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { audioElement: [{
                    type: i0.Input
                }], waveFormData: [{
                    type: i0.Input
                }], duration: [{
                    type: i0.Input
                }], container: [{
                    type: i0.ViewChild,
                    args: ['container', { static: true }]
                }] } });

    /**
     * This component can be used to display an attachment with type `voiceRecording`. The component allows playing the attachment inside the browser.
     */
    var VoiceRecordingComponent = /** @class */ (function () {
        function VoiceRecordingComponent(ngZone, cdRef) {
            this.ngZone = ngZone;
            this.cdRef = cdRef;
            this.fileSize = '';
            this.durationFormatted = '';
            this.secondsElapsed = 0;
            this.isError = false;
            this.secondsElapsedFormatted = this.getFormattedDuration(this.secondsElapsed);
        }
        VoiceRecordingComponent.prototype.ngOnChanges = function (changes) {
            var _a;
            if (changes.attachment) {
                this.fileSize = this.getFileSize();
                this.durationFormatted = this.getFormattedDuration((_a = this.attachment) === null || _a === void 0 ? void 0 : _a.duration);
            }
        };
        VoiceRecordingComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // timeupdate fired frequntly so we optimize change detections
            this.ngZone.runOutsideAngular(function () {
                var _a;
                (_a = _this.audioElement) === null || _a === void 0 ? void 0 : _a.nativeElement.addEventListener('timeupdate', function () {
                    var _a, _b, _c, _d, _e;
                    var secondsElapsed = ((_b = (_a = _this.audioElement) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.ended)
                        ? ((_c = _this.attachment) === null || _c === void 0 ? void 0 : _c.duration) || 0
                        : Math.round(((_e = (_d = _this.audioElement) === null || _d === void 0 ? void 0 : _d.nativeElement) === null || _e === void 0 ? void 0 : _e.currentTime) || 0);
                    if (_this.secondsElapsed !== secondsElapsed) {
                        _this.ngZone.run(function () {
                            _this.secondsElapsed = secondsElapsed;
                            _this.secondsElapsedFormatted = _this.getFormattedDuration(_this.secondsElapsed);
                            _this.cdRef.detectChanges();
                        });
                    }
                });
            });
        };
        VoiceRecordingComponent.prototype.togglePlay = function () {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function () {
                var _f, e_1;
                return __generator(this, function (_g) {
                    switch (_g.label) {
                        case 0:
                            if (!this.audioElement || !((_a = this.attachment) === null || _a === void 0 ? void 0 : _a.asset_url)) {
                                return [2 /*return*/];
                            }
                            _g.label = 1;
                        case 1:
                            _g.trys.push([1, 5, , 6]);
                            if (!((_b = this.audioElement) === null || _b === void 0 ? void 0 : _b.nativeElement.paused)) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.audioElement.nativeElement.play()];
                        case 2:
                            _f = _g.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            _f = this.audioElement.nativeElement.pause();
                            _g.label = 4;
                        case 4:
                            _f;
                            this.isError = false;
                            return [3 /*break*/, 6];
                        case 5:
                            e_1 = _g.sent();
                            this.isError = true;
                            return [3 /*break*/, 6];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        VoiceRecordingComponent.prototype.setPlaybackRate = function () {
            var _a, _b, _c;
            if (!((_a = this.audioElement) === null || _a === void 0 ? void 0 : _a.nativeElement)) {
                return;
            }
            var playbackRate = ((_c = (_b = this.audioElement) === null || _b === void 0 ? void 0 : _b.nativeElement) === null || _c === void 0 ? void 0 : _c.playbackRate) + 0.5;
            if (playbackRate > 2) {
                playbackRate = 1;
            }
            this.audioElement.nativeElement.playbackRate = playbackRate;
        };
        VoiceRecordingComponent.prototype.getFormattedDuration = function (duration) {
            if (duration === undefined || duration <= 0)
                return '00:00';
            var _f = __read(this.divMod(duration, 3600), 2), hours = _f[0], hoursLeftover = _f[1];
            var _g = __read(this.divMod(hoursLeftover, 60), 2), minutes = _g[0], seconds = _g[1];
            var roundedSeconds = Math.ceil(seconds);
            var prependHrsZero = hours.toString().length === 1 ? '0' : '';
            var prependMinZero = minutes.toString().length === 1 ? '0' : '';
            var prependSecZero = roundedSeconds.toString().length === 1 ? '0' : '';
            var minSec = "" + prependMinZero + minutes + ":" + prependSecZero + roundedSeconds;
            return hours ? "" + prependHrsZero + hours + ":" + minSec : minSec;
        };
        VoiceRecordingComponent.prototype.getFileSize = function () {
            var _a, _b;
            if (((_a = this.attachment) === null || _a === void 0 ? void 0 : _a.file_size) === undefined ||
                ((_b = this.attachment) === null || _b === void 0 ? void 0 : _b.file_size) === null) {
                return '';
            }
            return prettybytes__default['default'](Number(this.attachment.file_size || 0));
        };
        VoiceRecordingComponent.prototype.divMod = function (num, divisor) {
            return [Math.floor(num / divisor), num % divisor];
        };
        return VoiceRecordingComponent;
    }());
    VoiceRecordingComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: VoiceRecordingComponent, deps: [{ token: i0__namespace.NgZone }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    VoiceRecordingComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: VoiceRecordingComponent, selector: "stream-voice-recording", inputs: { attachment: "attachment" }, viewQueries: [{ propertyName: "audioElement", first: true, predicate: ["audioElement"], descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  class=\"str-chat__message-attachment__voice-recording-widget\"\n  [class.str-chat__message-attachment__voice-recording-widget--error]=\"isError\"\n  data-testid=\"voice-recording-widget\"\n>\n  <!-- Empty event handlers to trigger change detection -->\n  <audio\n    #audioElement\n    (play)=\"(null)\"\n    (pause)=\"(null)\"\n    (ended)=\"(null)\"\n    (error)=\"isError = true\"\n    (abort)=\"isError = true\"\n  >\n    <source\n      data-testid=\"audio-source\"\n      [src]=\"attachment?.asset_url\"\n      [type]=\"attachment?.mime_type\"\n    />\n  </audio>\n  <button\n    class=\"str-chat__message-attachment-audio-widget--play-button\"\n    data-testid=\"play-button\"\n    (click)=\"togglePlay()\"\n  >\n    <stream-icon-placeholder\n      [icon]=\"audioElement?.paused ? 'play' : 'pause'\"\n    ></stream-icon-placeholder>\n  </button>\n  <div class=\"str-chat__message-attachment__voice-recording-widget__metadata\">\n    <div class=\"str-chat__message-attachment-voice-recording-widget--first-row\">\n      <div\n        class=\"str-chat__message-attachment__voice-recording-widget__title\"\n        data-testid=\"voice-recording-title\"\n        [title]=\"attachment?.title\"\n      >\n        {{ attachment?.title }}\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"isError; else state\">\n      <div\n        class=\"\n          str-chat__message-attachment__voice-recording-widget__error-message\n        \"\n      >\n        <stream-icon-placeholder\n          [size]=\"20\"\n          icon=\"error\"\n        ></stream-icon-placeholder>\n        <span data-testid=\"error-message\">{{\n          \"streamChat.Error playing audio\" | translate\n        }}</span>\n      </div>\n    </ng-container>\n    <ng-template #state>\n      <div\n        class=\"\n          str-chat__message-attachment__voice-recording-widget__audio-state\n        \"\n      >\n        <div\n          class=\"str-chat__message-attachment__voice-recording-widget__timer\"\n        >\n          <span\n            data-testid=\"duration\"\n            *ngIf=\"!!attachment?.duration; else fileSizeTemplate\"\n          >\n            {{\n              secondsElapsed > 0 || !audioElement.paused\n                ? secondsElapsedFormatted\n                : durationFormatted\n            }}</span\n          >\n          <ng-template #fileSizeTemplate>\n            <span\n              class=\"str-chat__message-attachment-file--item-size\"\n              data-testid=\"file-size-indicator\"\n            >\n              {{ fileSize }}\n            </span>\n          </ng-template>\n        </div>\n        <stream-voice-recording-wavebar\n          *ngIf=\"attachment?.waveform_data && attachment?.duration\"\n          [waveFormData]=\"attachment?.waveform_data || []\"\n          [duration]=\"attachment?.duration\"\n          [audioElement]=\"audioElement\"\n        ></stream-voice-recording-wavebar>\n      </div>\n    </ng-template>\n  </div>\n  <div\n    class=\"str-chat__message-attachment__voice-recording-widget__right-section\"\n  >\n    <button\n      *ngIf=\"!audioElement?.paused; else fileIcon\"\n      class=\"str-chat__message_attachment__playback-rate-button\"\n      data-testid=\"playback-rate-button\"\n      (click)=\"setPlaybackRate()\"\n    >\n      {{ audioElement?.playbackRate | number: \"1.1-1\" }}x\n    </button>\n    <ng-template #fileIcon>\n      <stream-icon-placeholder\n        icon=\"audio-file\"\n        [size]=\"40\"\n      ></stream-icon-placeholder>\n    </ng-template>\n  </div>\n</div>\n", components: [{ type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }, { type: VoiceRecordingWavebarComponent, selector: "stream-voice-recording-wavebar", inputs: ["audioElement", "waveFormData", "duration"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "translate": i9__namespace.TranslatePipe, "number": i8__namespace.DecimalPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: VoiceRecordingComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-voice-recording',
                        templateUrl: './voice-recording.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { attachment: [{
                    type: i0.Input
                }], audioElement: [{
                    type: i0.ViewChild,
                    args: ['audioElement']
                }] } });

    /**
     * The `AttachmentList` component displays the attachments of a message
     */
    var AttachmentListComponent = /** @class */ (function () {
        function AttachmentListComponent(customTemplatesService, channelService, attachmentConfigurationService, themeService) {
            this.customTemplatesService = customTemplatesService;
            this.channelService = channelService;
            this.attachmentConfigurationService = attachmentConfigurationService;
            /**
             * The attachments to display
             */
            this.attachments = [];
            /**
             * Emits the state of the image carousel window
             */
            this.imageModalStateChange = new i0.EventEmitter();
            this.class = 'str-chat__attachment-list-angular-host';
            this.orderedAttachments = [];
            this.imagesToView = [];
            this.imagesToViewCurrentIndex = 0;
            this.attachmentConfigurations = new Map();
            this.themeVersion = themeService.themeVersion;
        }
        AttachmentListComponent.prototype.ngOnChanges = function (changes) {
            var _a;
            var _this = this;
            if (changes.attachments) {
                var images = this.attachments.filter(this.isImage);
                var containsGallery = images.length >= 2;
                this.orderedAttachments = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read((containsGallery ? this.createGallery(images) : images))), __read(this.attachments.filter(function (a) { return _this.isVideo(a); }))), __read(this.attachments.filter(function (a) { return _this.isVoiceMessage(a); }))), __read(this.attachments.filter(function (a) { return _this.isFile(a); })));
                this.attachmentConfigurations = new Map();
                // Display link attachments only if there are no other attachments
                // Giphy-s always sent without other attachments
                if (this.orderedAttachments.length === 0) {
                    (_a = this.orderedAttachments).push.apply(_a, __spreadArray([], __read(this.attachments.filter(function (a) { return _this.isCard(a); }))));
                }
            }
        };
        AttachmentListComponent.prototype.trackByUrl = function (_, attachment) {
            return (attachment.image_url ||
                attachment.img_url ||
                attachment.asset_url ||
                attachment.thumb_url);
        };
        AttachmentListComponent.prototype.isImage = function (attachment) {
            return isImageAttachment(attachment);
        };
        AttachmentListComponent.prototype.isSvg = function (attachment) {
            var filename = attachment.fallback || '';
            return !!filename.toLowerCase().endsWith('.svg');
        };
        AttachmentListComponent.prototype.isFile = function (attachment) {
            return attachment.type === 'file';
        };
        AttachmentListComponent.prototype.isGallery = function (attachment) {
            return attachment.type === 'gallery';
        };
        AttachmentListComponent.prototype.isVideo = function (attachment) {
            return (attachment.type === 'video' &&
                attachment.asset_url &&
                !attachment.og_scrape_url // links from video share services (such as YouTube or Facebook) are can't be played
            );
        };
        AttachmentListComponent.prototype.isCard = function (attachment) {
            return (!attachment.type ||
                (attachment.type === 'image' && !this.isImage(attachment)) ||
                attachment.type === 'giphy');
        };
        AttachmentListComponent.prototype.isVoiceMessage = function (attachment) {
            return attachment.type === 'voiceRecording';
        };
        AttachmentListComponent.prototype.hasFileSize = function (attachment) {
            return (attachment.file_size && Number.isFinite(Number(attachment.file_size)));
        };
        AttachmentListComponent.prototype.getFileSize = function (attachment) {
            return prettybytes__default['default'](Number(attachment.file_size));
        };
        AttachmentListComponent.prototype.getModalContext = function () {
            var _this = this;
            return {
                isOpen: this.imagesToView && this.imagesToView.length > 0,
                isOpenChangeHandler: function (isOpen) { return (isOpen ? null : _this.closeImageModal()); },
                content: this.modalContent,
            };
        };
        AttachmentListComponent.prototype.trimUrl = function (url) {
            if (url !== undefined && url !== null) {
                var _a = __read(url
                    .replace(/^(?:https?:\/\/)?(?:www\.)?/i, '')
                    .split('/'), 1), trimmedUrl = _a[0];
                return trimmedUrl;
            }
            return null;
        };
        AttachmentListComponent.prototype.sendAction = function (action) {
            var _a;
            void this.channelService.sendAction(this.messageId, (_a = {},
                _a[action.name] = action.value,
                _a), this.parentMessageId);
        };
        AttachmentListComponent.prototype.trackByActionValue = function (_, item) {
            return item.value;
        };
        AttachmentListComponent.prototype.openImageModal = function (attachments, selectedIndex) {
            if (selectedIndex === void 0) { selectedIndex = 0; }
            this.imageModalStateChange.next('opened');
            this.imagesToView = attachments;
            this.imagesToViewCurrentIndex = selectedIndex;
        };
        AttachmentListComponent.prototype.stepImages = function (dir) {
            this.imagesToViewCurrentIndex += dir * 1;
        };
        AttachmentListComponent.prototype.trackByImageUrl = function (_, item) {
            return item.image_url || item.img_url || item.thumb_url;
        };
        AttachmentListComponent.prototype.getAttachmentContext = function (attachment) {
            return { attachment: attachment };
        };
        AttachmentListComponent.prototype.getImageAttachmentConfiguration = function (attachment, type, element) {
            var existingConfiguration = this.attachmentConfigurations.get(attachment);
            if (existingConfiguration) {
                return existingConfiguration;
            }
            var configuration = this.attachmentConfigurationService.getImageAttachmentConfiguration(attachment, type, element);
            this.attachmentConfigurations.set(attachment, configuration);
            return configuration;
        };
        AttachmentListComponent.prototype.getCarouselImageAttachmentConfiguration = function (attachment, element) {
            return this.attachmentConfigurationService.getImageAttachmentConfiguration(attachment, 'carousel', element);
        };
        AttachmentListComponent.prototype.getVideoAttachmentConfiguration = function (attachment, element) {
            var existingConfiguration = this.attachmentConfigurations.get(attachment);
            if (existingConfiguration) {
                return existingConfiguration;
            }
            var configuration = this.attachmentConfigurationService.getVideoAttachmentConfiguration(attachment, element);
            this.attachmentConfigurations.set(attachment, configuration);
            return configuration;
        };
        AttachmentListComponent.prototype.getCardAttachmentConfiguration = function (attachment) {
            var existingConfiguration = this.attachmentConfigurations.get(attachment);
            if (existingConfiguration) {
                return existingConfiguration;
            }
            if (attachment.type === 'giphy') {
                return this.attachmentConfigurationService.getGiphyAttachmentConfiguration(attachment);
            }
            else {
                var configuration = this.attachmentConfigurationService.getScrapedImageAttachmentConfiguration(attachment);
                this.attachmentConfigurations.set(attachment, configuration);
                return configuration;
            }
        };
        Object.defineProperty(AttachmentListComponent.prototype, "isImageModalPrevButtonVisible", {
            get: function () {
                return this.imagesToViewCurrentIndex !== 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AttachmentListComponent.prototype, "isImageModalNextButtonVisible", {
            get: function () {
                return this.imagesToViewCurrentIndex !== this.imagesToView.length - 1;
            },
            enumerable: false,
            configurable: true
        });
        AttachmentListComponent.prototype.createGallery = function (images) {
            return [
                {
                    type: 'gallery',
                    images: images,
                },
            ];
        };
        AttachmentListComponent.prototype.closeImageModal = function () {
            this.imageModalStateChange.next('closed');
            this.imagesToView = [];
        };
        return AttachmentListComponent;
    }());
    AttachmentListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentListComponent, deps: [{ token: CustomTemplatesService }, { token: ChannelService }, { token: AttachmentConfigurationService }, { token: ThemeService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AttachmentListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: AttachmentListComponent, selector: "stream-attachment-list", inputs: { messageId: "messageId", parentMessageId: "parentMessageId", attachments: "attachments" }, outputs: { imageModalStateChange: "imageModalStateChange" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "modalContent", first: true, predicate: ["modalContent"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<div *ngIf=\"orderedAttachments.length > 0\" class=\"str-chat__attachment-list\">\n  <ng-container\n    *ngFor=\"let attachment of orderedAttachments; trackBy: trackByUrl\"\n  >\n    <div\n      data-testclass=\"attachment-container\"\n      class=\"str-chat__message-attachment str-chat__message-attachment--{{\n        attachment.type\n      }} str-chat__message-attachment-dynamic-size\"\n      [class.str-chat__message-attachment--card]=\"isCard(attachment)\"\n      [class.str-chat-angular__message-attachment-file-single]=\"\n        isFile(attachment)\n      \"\n      [class.str-chat__message-attachment--voice-recording]=\"\n        isVoiceMessage(attachment)\n      \"\n      [class.str-chat__message-attachment-with-actions]=\"\n        attachment.actions && attachment.actions.length > 0\n      \"\n      [class.str-chat__message-attachment--svg-image]=\"isSvg(attachment)\"\n    >\n      <ng-container *ngIf=\"isImage(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.imageAttachmentTemplate$ | async) ||\n              defaultImage;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultImage let-attachmentContext=\"attachment\">\n          <img\n            #imgElement\n            class=\"str-chat__message-attachment--img\"\n            data-testclass=\"image\"\n            [src]=\"\n              getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).url\n            \"\n            [alt]=\"attachmentContext?.fallback\"\n            (click)=\"openImageModal([attachmentContext])\"\n            (keyup.enter)=\"openImageModal([attachmentContext])\"\n            [style.--original-height]=\"\n              getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).originalHeight\n            \"\n            [style.--original-width]=\"\n              getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).originalWidth\n            \"\n            [ngStyle]=\"{\n              height: getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).height,\n              width: getImageAttachmentConfiguration(\n                attachmentContext,\n                'single',\n                imgElement\n              ).width\n            }\"\n          />\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isGallery(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.galleryAttachmentTemplate$ | async) ||\n              defaultGallery;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultGallery let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__gallery\"\n            data-testid=\"image-gallery\"\n            [class.str-chat__gallery--square]=\"\n              (attachmentContext?.images)!.length > 3\n            \"\n            [class.str-chat__gallery-two-rows]=\"\n              (attachmentContext?.images)!.length > 2\n            \"\n          >\n            <ng-container\n              *ngFor=\"\n                let galleryImage of attachmentContext.images;\n                let index = index;\n                let isLast = last;\n                trackBy: trackByImageUrl\n              \"\n            >\n              <button\n                *ngIf=\"index < 3 || (index === 3 && isLast)\"\n                class=\"str-chat__gallery-image\"\n                data-testclass=\"gallery-image\"\n                (click)=\"openImageModal(attachmentContext.images!, index)\"\n                (keyup.enter)=\"openImageModal(attachmentContext.images!, index)\"\n                [class.str-chat__message-attachment--svg-image]=\"\n                  isSvg(galleryImage)\n                \"\n              >\n                <img\n                  fetchpriority=\"low\"\n                  loading=\"lazy\"\n                  #imgElement\n                  [src]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).url\n                  \"\n                  [alt]=\"galleryImage.fallback\"\n                  [style.--original-height]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).originalHeight\n                  \"\n                  [style.--original-width]=\"\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).originalWidth\n                  \"\n                  [ngStyle]=\"{\n                    height: getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).height,\n                    width: getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      imgElement\n                    ).width\n                  }\"\n                />\n              </button>\n              <button\n                #element\n                *ngIf=\"index === 3 && !isLast\"\n                class=\"str-chat__gallery-placeholder\"\n                data-testclass=\"gallery-image\"\n                data-testid=\"more-image-button\"\n                (click)=\"openImageModal(attachmentContext.images!, index)\"\n                (keyup.enter)=\"openImageModal(attachmentContext.images!, index)\"\n                [class.str-chat__message-attachment--svg-image]=\"\n                  isSvg(galleryImage)\n                \"\n                [style.--original-height]=\"\n                  getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).originalHeight\n                \"\n                [style.--original-width]=\"\n                  getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).originalWidth\n                \"\n                [ngStyle]=\"{\n                  'background-image':\n                    'url(' +\n                    getImageAttachmentConfiguration(\n                      galleryImage,\n                      'gallery',\n                      element\n                    ).url +\n                    ')',\n                  height: getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).height,\n                  width: getImageAttachmentConfiguration(\n                    galleryImage,\n                    'gallery',\n                    element\n                  ).width\n                }\"\n              >\n                <p\n                  [innerHTML]=\"\n                    'streamChat.{{ imageCount }} more'\n                      | translate\n                        : { imageCount: attachmentContext!.images!.length - 4 }\n                  \"\n                ></p>\n              </button>\n            </ng-container>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isVideo(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.videoAttachmentTemplate$ | async) ||\n              defaultVideo;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultVideo let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__player-wrapper\"\n            data-testclass=\"video-attachment-parent\"\n            [style.--original-height]=\"\n              getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                .originalHeight\n            \"\n            [style.--original-width]=\"\n              getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                .originalWidth\n            \"\n            [ngStyle]=\"{\n              height: getVideoAttachmentConfiguration(\n                attachmentContext,\n                videoElement\n              ).height,\n              width: getVideoAttachmentConfiguration(\n                attachmentContext,\n                videoElement\n              ).width\n            }\"\n          >\n            <video\n              #videoElement\n              class=\"str-chat__video-angular\"\n              controls\n              data-testclass=\"video-attachment\"\n              [src]=\"\n                getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                  .url\n              \"\n              [poster]=\"\n                getVideoAttachmentConfiguration(attachmentContext, videoElement)\n                  .thumbUrl\n              \"\n            ></video>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isFile(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.fileAttachmentTemplate$ | async) ||\n              defaultFile;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultFile let-attachmentContext=\"attachment\">\n          <div\n            class=\"\n              str-chat__message-attachment-file--item\n              str-chat-angular__message-attachment-file-single\n            \"\n          >\n            <stream-icon-placeholder\n              *ngIf=\"themeVersion === '1'\"\n              icon=\"file\"\n              [size]=\"30\"\n            ></stream-icon-placeholder>\n            <stream-icon-placeholder\n              *ngIf=\"themeVersion === '2'\"\n              icon=\"unspecified-filetype\"\n              [size]=\"30\"\n            ></stream-icon-placeholder>\n            <div class=\"str-chat__message-attachment-file--item-text\">\n              <a\n                class=\"str-chat__message-attachment-file--item-first-row\"\n                data-testclass=\"file-link\"\n                href=\"{{ attachmentContext.asset_url }}\"\n                target=\"_blank\"\n              >\n                <div\n                  data-testclass=\"file-title\"\n                  class=\"str-chat__message-attachment-file--item-name\"\n                >\n                  {{ attachmentContext.title }}\n                </div>\n                <stream-icon-placeholder\n                  class=\"str-chat__message-attachment-download-icon\"\n                  icon=\"download\"\n                ></stream-icon-placeholder>\n              </a>\n              <span\n                class=\"str-chat__message-attachment-file--item-size\"\n                data-testclass=\"size\"\n                *ngIf=\"hasFileSize(attachmentContext)\"\n                >{{ getFileSize(attachmentContext) }}</span\n              >\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"isVoiceMessage(attachment)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.voiceRecordingAttachmentTemplate$\n              | async) || defaultRecording;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultRecording>\n          <stream-voice-recording\n            data-testclass=\"voice-recording\"\n            [attachment]=\"attachment\"\n          ></stream-voice-recording>\n        </ng-template>\n      </ng-container>\n      <ng-container\n        *ngIf=\"\n          isCard(attachment) &&\n          getCardAttachmentConfiguration(attachment) as attachmentConfiguration\n        \"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.cardAttachmentTemplate$ | async) ||\n              defaultCard;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultCard let-attachmentContext=\"attachment\">\n          <div\n            class=\"str-chat__message-attachment-card str-chat__message-attachment-card--{{\n              attachmentContext.type\n            }}\"\n          >\n            <div\n              *ngIf=\"attachmentConfiguration.url\"\n              class=\"str-chat__message-attachment-card--header\"\n            >\n              <img\n                fetchpriority=\"low\"\n                loading=\"lazy\"\n                data-testclass=\"card-img\"\n                alt=\"{{ attachmentConfiguration.url }}\"\n                src=\"{{ attachmentConfiguration.url }}\"\n                [ngStyle]=\"{\n                  height: attachmentConfiguration.height,\n                  width: attachmentConfiguration.width\n                }\"\n              />\n            </div>\n            <div class=\"str-chat__message-attachment-card--content\">\n              <div class=\"str-chat__message-attachment-card--flex\">\n                <div\n                  *ngIf=\"attachmentContext.title\"\n                  data-testclass=\"card-title\"\n                  class=\"str-chat__message-attachment-card--title\"\n                >\n                  {{ attachmentContext.title }}\n                </div>\n                <div\n                  *ngIf=\"attachmentContext.text\"\n                  class=\"str-chat__message-attachment-card--text\"\n                  data-testclass=\"card-text\"\n                >\n                  {{ attachmentContext.text }}\n                </div>\n                <a\n                  class=\"str-chat__message-attachment-card--url\"\n                  *ngIf=\"\n                    attachmentContext.title_link ||\n                    attachmentContext.og_scrape_url\n                  \"\n                  data-testclass=\"url-link\"\n                  noopener\n                  noreferrer\n                  href=\"{{\n                    attachmentContext.title_link ||\n                      attachmentContext.og_scrape_url\n                  }}\"\n                  target=\"_blank\"\n                >\n                  {{\n                    trimUrl(\n                      attachmentContext.title_link ||\n                        attachmentContext.og_scrape_url\n                    )\n                  }}\n                </a>\n              </div>\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n      <ng-container *ngIf=\"attachment.actions && attachment.actions.length > 0\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.attachmentActionsTemplate$ | async) ||\n              defaultActions;\n            context: getAttachmentContext(attachment)\n          \"\n        ></ng-container>\n        <ng-template #defaultActions let-attachmentContext=\"attachment\">\n          <div class=\"str-chat__message-attachment-actions\">\n            <div class=\"str-chat__message-attachment-actions-form\">\n              <button\n                *ngFor=\"\n                  let action of attachmentContext.actions;\n                  trackBy: trackByActionValue\n                \"\n                class=\"str-chat__message-attachment-actions-button str-chat__message-attachment-actions-button--{{\n                  action.style\n                }}\"\n                data-testclass=\"attachment-action\"\n                (click)=\"sendAction(action)\"\n                (keyup.enter)=\"sendAction(action)\"\n              >\n                {{ action.text }}\n              </button>\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"imagesToView && imagesToView.length > 0\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.modalTemplate$ | async) || defaultModal;\n        context: getModalContext()\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    class=\"stream-chat-angular__image-modal-host\"\n    [isOpen]=\"isOpen\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n    [content]=\"content\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div class=\"stream-chat-angular__image-modal str-chat__image-carousel\">\n    <img\n      #imgElement\n      class=\"\n        stream-chat-angular__image-modal-image\n        str-chat__image-carousel-image\n      \"\n      data-testid=\"modal-image\"\n      [src]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).url\n      \"\n      [style.--original-height]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).originalHeight\n      \"\n      [style.--original-width]=\"\n        getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).originalWidth\n      \"\n      [alt]=\"imagesToView[imagesToViewCurrentIndex].fallback\"\n      [ngStyle]=\"{\n        width: getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).width,\n        height: getCarouselImageAttachmentConfiguration(\n          imagesToView[imagesToViewCurrentIndex],\n          imgElement\n        ).height\n      }\"\n    />\n    <div>\n      <button\n        class=\"\n          stream-chat-angular__image-modal-stepper\n          str-chat__image-carousel-stepper str-chat__image-carousel-stepper-prev\n        \"\n        [ngStyle]=\"{\n          visibility: isImageModalPrevButtonVisible ? 'visible' : 'hidden'\n        }\"\n        data-testid=\"image-modal-prev\"\n        type=\"button\"\n        (click)=\"stepImages(-1)\"\n        (keyup.enter)=\"stepImages(-1)\"\n      >\n        <stream-icon-placeholder icon=\"arrow-left\"></stream-icon-placeholder>\n      </button>\n      <button\n        class=\"\n          stream-chat-angular__image-modal-stepper\n          str-chat__image-carousel-stepper str-chat__image-carousel-stepper-next\n        \"\n        type=\"button\"\n        [ngStyle]=\"{\n          visibility: isImageModalNextButtonVisible ? 'visible' : 'hidden'\n        }\"\n        data-testid=\"image-modal-next\"\n        (click)=\"stepImages(1)\"\n        (keyup.enter)=\"stepImages(1)\"\n      >\n        <stream-icon-placeholder icon=\"arrow-right\"></stream-icon-placeholder>\n      </button>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }, { type: VoiceRecordingComponent, selector: "stream-voice-recording", inputs: ["attachment"] }, { type: ModalComponent, selector: "stream-modal", inputs: ["isOpen", "content"], outputs: ["isOpenChange"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i8__namespace.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-attachment-list',
                        templateUrl: './attachment-list.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: ChannelService }, { type: AttachmentConfigurationService }, { type: ThemeService }]; }, propDecorators: { messageId: [{
                    type: i0.Input
                }], parentMessageId: [{
                    type: i0.Input
                }], attachments: [{
                    type: i0.Input
                }], imageModalStateChange: [{
                    type: i0.Output
                }], class: [{
                    type: i0.HostBinding
                }], modalContent: [{
                    type: i0.ViewChild,
                    args: ['modalContent', { static: true }]
                }] } });

    /**
     * The `AttachmentPreviewList` component displays a preview of the attachments uploaded to a message. Users can delete attachments using the preview component, or retry upload if it failed previously.
     */
    var AttachmentPreviewListComponent = /** @class */ (function () {
        function AttachmentPreviewListComponent(themeService) {
            /**
             * An output to notify the parent component if the user tries to retry a failed upload
             */
            this.retryAttachmentUpload = new i0.EventEmitter();
            /**
             * An output to notify the parent component if the user wants to delete a file
             */
            this.deleteAttachment = new i0.EventEmitter();
            this.themeVersion = themeService.themeVersion;
        }
        AttachmentPreviewListComponent.prototype.attachmentUploadRetried = function (file) {
            this.retryAttachmentUpload.emit(file);
        };
        AttachmentPreviewListComponent.prototype.attachmentDeleted = function (upload) {
            this.deleteAttachment.emit(upload);
        };
        AttachmentPreviewListComponent.prototype.trackByFile = function (_, item) {
            return item.file;
        };
        return AttachmentPreviewListComponent;
    }());
    AttachmentPreviewListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentPreviewListComponent, deps: [{ token: ThemeService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AttachmentPreviewListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: AttachmentPreviewListComponent, selector: "stream-attachment-preview-list", inputs: { attachmentUploads$: "attachmentUploads$" }, outputs: { retryAttachmentUpload: "retryAttachmentUpload", deleteAttachment: "deleteAttachment" }, ngImport: i0__namespace, template: "<div\n  class=\"rfu-image-previewer\"\n  *ngIf=\"(attachmentUploads$ | async)?.length && themeVersion === '1'\"\n>\n  <ng-container\n    *ngFor=\"\n      let attachmentUpload of attachmentUploads$ | async;\n      trackBy: trackByFile\n    \"\n  >\n    <div\n      *ngIf=\"attachmentUpload.type === 'image'\"\n      class=\"rfu-image-previewer__image\"\n      [class.rfu-image-previewer__image--loaded]=\"\n        attachmentUpload.state === 'success'\n      \"\n      data-testclass=\"attachment-image-preview\"\n    >\n      <div\n        *ngIf=\"attachmentUpload.state === 'error'\"\n        class=\"rfu-image-previewer__retry\"\n        (click)=\"attachmentUploadRetried(attachmentUpload.file)\"\n        (keyup.enter)=\"attachmentUploadRetried(attachmentUpload.file)\"\n        data-testclass=\"upload-retry\"\n      >\n        <stream-icon-placeholder icon=\"retry\"></stream-icon-placeholder>\n      </div>\n      <div class=\"rfu-thumbnail__wrapper\">\n        <div class=\"rfu-thumbnail__overlay\">\n          <div\n            class=\"rfu-icon-button\"\n            data-testclass=\"file-delete\"\n            role=\"button\"\n            (click)=\"attachmentDeleted(attachmentUpload)\"\n            (keyup.enter)=\"attachmentDeleted(attachmentUpload)\"\n          >\n            <stream-icon-placeholder\n              icon=\"close-no-outline\"\n            ></stream-icon-placeholder>\n          </div>\n        </div>\n        <img\n          *ngIf=\"attachmentUpload.url || attachmentUpload.previewUri\"\n          src=\"{{\n            attachmentUpload.url\n              ? attachmentUpload.url\n              : attachmentUpload.previewUri\n          }}\"\n          alt=\"{{ attachmentUpload.file.name }}\"\n          class=\"rfu-thumbnail__image\"\n          data-testclass=\"attachment-image\"\n        />\n      </div>\n      <stream-loading-indicator-placeholder\n        data-testclass=\"loading-indicator\"\n        color=\"rgba(255,255,255,0.7)\"\n        *ngIf=\"attachmentUpload.state === 'uploading'\"\n      ></stream-loading-indicator-placeholder>\n    </div>\n    <div\n      class=\"rfu-file-previewer\"\n      *ngIf=\"\n        attachmentUpload.type === 'file' || attachmentUpload.type === 'video'\n      \"\n      data-testclass=\"attachment-file-preview\"\n    >\n      <ol>\n        <li\n          class=\"rfu-file-previewer__file\"\n          [class.rfu-file-previewer__file--uploading]=\"\n            attachmentUpload.state === 'uploading'\n          \"\n          [class.rfu-file-previewer__file--failed]=\"\n            attachmentUpload.state === 'error'\n          \"\n        >\n          <stream-icon-placeholder icon=\"file\"></stream-icon-placeholder>\n\n          <a\n            data-testclass=\"file-download-link\"\n            href=\"{{ attachmentUpload.url }}\"\n            (click)=\"attachmentUpload.url ? null : $event.preventDefault()\"\n            (keyup.enter)=\"\n              attachmentUpload.url ? null : $event.preventDefault()\n            \"\n            download\n          >\n            {{ attachmentUpload.file.name }}\n            <ng-container *ngIf=\"attachmentUpload.state === 'error'\">\n              <div\n                data-testclass=\"upload-retry\"\n                class=\"rfu-file-previewer__failed\"\n                (click)=\"attachmentUploadRetried(attachmentUpload.file)\"\n                (keyup.enter)=\"attachmentUploadRetried(attachmentUpload.file)\"\n                translate\n              >\n                streamChat.failed\n              </div>\n              <div\n                class=\"rfu-file-previewer__retry\"\n                (click)=\"attachmentUploadRetried(attachmentUpload.file)\"\n                (keyup.enter)=\"attachmentUploadRetried(attachmentUpload.file)\"\n                translate\n              >\n                streamChat.retry\n              </div>\n            </ng-container>\n          </a>\n\n          <span\n            data-testclass=\"file-delete\"\n            class=\"rfu-file-previewer__close-button\"\n            (click)=\"attachmentDeleted(attachmentUpload)\"\n            (keyup.enter)=\"attachmentDeleted(attachmentUpload)\"\n          >\n            <stream-icon-placeholder\n              icon=\"close-no-outline\"\n            ></stream-icon-placeholder>\n          </span>\n          <div\n            *ngIf=\"attachmentUpload.state === 'uploading'\"\n            class=\"rfu-file-previewer__loading-indicator\"\n          >\n            <stream-loading-indicator-placeholder></stream-loading-indicator-placeholder>\n          </div>\n        </li>\n      </ol>\n    </div>\n  </ng-container>\n</div>\n\n<div\n  class=\"str-chat__attachment-preview-list\"\n  *ngIf=\"(attachmentUploads$ | async)?.length && themeVersion === '2'\"\n>\n  <div class=\"str-chat__attachment-list-scroll-container\">\n    <ng-container\n      *ngFor=\"\n        let attachmentUpload of attachmentUploads$ | async;\n        trackBy: trackByFile\n      \"\n    >\n      <div\n        *ngIf=\"attachmentUpload.type === 'image'\"\n        class=\"str-chat__attachment-preview-image\"\n        data-testclass=\"attachment-image-preview\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            deleteButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <div\n          *ngIf=\"attachmentUpload.state === 'uploading'\"\n          class=\"str-chat__attachment-preview-image-loading\"\n        >\n          <stream-loading-indicator-placeholder\n            data-testclass=\"loading-indicator\"\n            [size]=\"18\"\n          ></stream-loading-indicator-placeholder>\n        </div>\n        <ng-container\n          *ngTemplateOutlet=\"\n            retryButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <img\n          *ngIf=\"attachmentUpload.url || attachmentUpload.previewUri\"\n          src=\"{{\n            attachmentUpload.url\n              ? attachmentUpload.url\n              : attachmentUpload.previewUri\n          }}\"\n          alt=\"{{ attachmentUpload.file.name }}\"\n          class=\"str-chat__attachment-preview-thumbnail\"\n          data-testclass=\"attachment-image\"\n        />\n      </div>\n      <div\n        class=\"str-chat__attachment-preview-file\"\n        *ngIf=\"\n          attachmentUpload.type === 'file' || attachmentUpload.type === 'video'\n        \"\n        data-testclass=\"attachment-file-preview\"\n      >\n        <stream-icon-placeholder\n          icon=\"unspecified-filetype\"\n        ></stream-icon-placeholder>\n\n        <div class=\"str-chat__attachment-preview-file-end\">\n          <div class=\"str-chat__attachment-preview-file-name\">\n            {{ attachmentUpload.file.name }}\n          </div>\n          <a\n            *ngIf=\"attachmentUpload.state === 'success'\"\n            class=\"str-chat__attachment-preview-file-download\"\n            data-testclass=\"file-download-link\"\n            href=\"{{ attachmentUpload.url }}\"\n            (click)=\"attachmentUpload.url ? null : $event.preventDefault()\"\n            (keyup.enter)=\"\n              attachmentUpload.url ? null : $event.preventDefault()\n            \"\n            download\n          >\n            <stream-icon-placeholder icon=\"download\"></stream-icon-placeholder>\n          </a>\n          <stream-loading-indicator-placeholder\n            *ngIf=\"attachmentUpload.state === 'uploading'\"\n            data-testclass=\"loading-indicator\"\n            [size]=\"18\"\n          ></stream-loading-indicator-placeholder>\n        </div>\n        <ng-container\n          *ngTemplateOutlet=\"\n            deleteButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n        <ng-container\n          *ngTemplateOutlet=\"\n            retryButton;\n            context: { attachmentUpload: attachmentUpload }\n          \"\n        ></ng-container>\n      </div>\n    </ng-container>\n  </div>\n</div>\n\n<ng-template #deleteButton let-attachmentUpload=\"attachmentUpload\">\n  <div\n    class=\"str-chat__attachment-preview-delete\"\n    data-testclass=\"file-delete\"\n    role=\"button\"\n    (click)=\"attachmentDeleted(attachmentUpload)\"\n    (keyup.enter)=\"attachmentDeleted(attachmentUpload)\"\n  >\n    <stream-icon-placeholder icon=\"close-no-outline\"></stream-icon-placeholder>\n  </div>\n</ng-template>\n\n<ng-template #retryButton let-attachmentUpload=\"attachmentUpload\">\n  <div\n    *ngIf=\"attachmentUpload.state === 'error'\"\n    class=\"str-chat__attachment-preview-error str-chat__attachment-preview-error-{{\n      attachmentUpload.type === 'image' ? 'image' : 'file'\n    }}\"\n    (click)=\"attachmentUploadRetried(attachmentUpload.file)\"\n    (keyup.enter)=\"attachmentUploadRetried(attachmentUpload.file)\"\n    data-testclass=\"upload-retry\"\n  >\n    <stream-icon-placeholder icon=\"retry\"></stream-icon-placeholder>\n  </div>\n</ng-template>\n", components: [{ type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }, { type: LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder", inputs: ["size", "color"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i9__namespace.TranslateDirective, selector: "[translate],[ngx-translate]", inputs: ["translate", "translateParams"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AttachmentPreviewListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-attachment-preview-list',
                        templateUrl: './attachment-preview-list.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: ThemeService }]; }, propDecorators: { attachmentUploads$: [{
                    type: i0.Input
                }], retryAttachmentUpload: [{
                    type: i0.Output
                }], deleteAttachment: [{
                    type: i0.Output
                }] } });

    /**
     * The `MessageInput` component displays an input where users can type their messages and upload files, and sends the message to the active channel. The component can be used to compose new messages or update existing ones. To send messages, the chat user needs to have the necessary [channel capability](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript).
     */
    var MessageInputComponent = /** @class */ (function () {
        function MessageInputComponent(channelService, notificationService, attachmentService, configService, textareaType, componentFactoryResolver, cdRef, chatClient, emojiInputService, customTemplatesService, themeService) {
            var _this = this;
            this.channelService = channelService;
            this.notificationService = notificationService;
            this.attachmentService = attachmentService;
            this.configService = configService;
            this.textareaType = textareaType;
            this.componentFactoryResolver = componentFactoryResolver;
            this.cdRef = cdRef;
            this.chatClient = chatClient;
            this.emojiInputService = emojiInputService;
            this.customTemplatesService = customTemplatesService;
            /**
             * Determines if the message is being dispalyed in a channel or in a [thread](https://getstream.io/chat/docs/javascript/threads/?language=javascript).
             */
            this.mode = 'main';
            /**
             * Enables or disables auto focus on the textarea element
             */
            this.autoFocus = true;
            /**
             * Emits when a message was successfuly sent or updated
             */
            this.messageUpdate = new i0.EventEmitter();
            this.class = 'str-chat__message-input-angular-host';
            this.textareaValue = '';
            this.mentionedUsers = [];
            this.typingStart$ = new rxjs.Subject();
            this.isCooldownInProgress = false;
            this.fileInputId = uuid.v4();
            this.subscriptions = [];
            this.isViewInited = false;
            this.defaultTextareaPlaceholder = 'streamChat.Type your message';
            this.slowModeTextareaPlaceholder = 'streamChat.Slow Mode ON';
            this.themeVersion = themeService.themeVersion;
            this.textareaPlaceholder = this.defaultTextareaPlaceholder;
            this.subscriptions.push(this.attachmentService.attachmentUploadInProgressCounter$.subscribe(function (counter) {
                if (counter === 0 && _this.hideNotification) {
                    _this.hideNotification();
                    _this.hideNotification = undefined;
                }
            }));
            this.subscriptions.push(this.channelService.activeChannel$.subscribe(function (channel) {
                var _a;
                if (channel && _this.channel && channel.id !== _this.channel.id) {
                    _this.textareaValue = '';
                    _this.attachmentService.resetAttachmentUploads();
                }
                var capabilities = (_a = channel === null || channel === void 0 ? void 0 : channel.data) === null || _a === void 0 ? void 0 : _a.own_capabilities;
                if (capabilities) {
                    _this.isFileUploadAuthorized =
                        capabilities.indexOf('upload-file') !== -1;
                    _this.canSendLinks = capabilities.indexOf('send-links') !== -1;
                    _this.channel = channel;
                    _this.setCanSendMessages();
                }
            }));
            this.subscriptions.push(this.chatClient.appSettings$.subscribe(function (appSettings) { return (_this.appSettings = appSettings); }));
            this.subscriptions.push(this.channelService.messageToQuote$.subscribe(function (m) {
                var isThreadReply = m && m.parent_id;
                if ((_this.mode === 'thread' && isThreadReply) ||
                    (_this.mode === 'thread' && _this.quotedMessage && !m) ||
                    (_this.mode === 'main' && !isThreadReply)) {
                    _this.quotedMessage = m;
                }
            }));
            this.attachmentUploads$ = this.attachmentService.attachmentUploads$;
            this.attachmentUploadInProgressCounter$ =
                this.attachmentService.attachmentUploadInProgressCounter$;
            this.isFileUploadEnabled = this.configService.isFileUploadEnabled;
            this.isMultipleFileUploadEnabled =
                this.configService.isMultipleFileUploadEnabled;
            this.areMentionsEnabled = this.configService.areMentionsEnabled;
            this.mentionScope = this.configService.mentionScope;
            this.inputMode = this.configService.inputMode;
            this.subscriptions.push(this.typingStart$.subscribe(function () { return void _this.channelService.typingStarted(_this.parentMessageId); }));
            this.subscriptions.push(rxjs.combineLatest([
                this.channelService.latestMessageDateByUserByChannels$,
                this.channelService.activeChannel$,
            ])
                .pipe(operators.map(function (_12) {
                var _13 = __read(_12, 2), latestMessages = _13[0], channel = _13[1];
                return [latestMessages[(channel === null || channel === void 0 ? void 0 : channel.cid) || ''], channel];
            }))
                .subscribe(function (_12) {
                var _13 = __read(_12, 2), latestMessageDate = _13[0], channel = _13[1];
                var _a, _b, _c;
                var cooldown = ((_a = channel === null || channel === void 0 ? void 0 : channel.data) === null || _a === void 0 ? void 0 : _a.cooldown) &&
                    latestMessageDate &&
                    Math.round(((_b = channel === null || channel === void 0 ? void 0 : channel.data) === null || _b === void 0 ? void 0 : _b.cooldown) -
                        (new Date().getTime() - latestMessageDate.getTime()) / 1000);
                if (cooldown &&
                    cooldown > 0 &&
                    ((_c = channel === null || channel === void 0 ? void 0 : channel.data) === null || _c === void 0 ? void 0 : _c.own_capabilities).includes('slow-mode')) {
                    _this.startCooldown(cooldown);
                }
                else if (_this.isCooldownInProgress) {
                    _this.stopCooldown();
                }
            }));
        }
        MessageInputComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.customTemplatesService.emojiPickerTemplate$.subscribe(function (template) {
                _this.emojiPickerTemplate = template;
                _this.cdRef.detectChanges();
            }));
            this.subscriptions.push(this.customTemplatesService.attachmentPreviewListTemplate$.subscribe(function (template) {
                _this.attachmentPreviewListTemplate = template;
                _this.cdRef.detectChanges();
            }));
            this.subscriptions.push(this.customTemplatesService.customAttachmentUploadTemplate$.subscribe(function (template) {
                _this.customAttachmentUploadTemplate = template;
                _this.cdRef.detectChanges();
            }));
        };
        MessageInputComponent.prototype.ngAfterViewInit = function () {
            this.isViewInited = true;
            this.initTextarea();
        };
        MessageInputComponent.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (changes.message) {
                this.attachmentService.resetAttachmentUploads();
                if (this.isUpdate) {
                    this.attachmentService.createFromAttachments(this.message.attachments || []);
                    this.textareaValue = this.message.text || '';
                }
            }
            if (changes.isFileUploadEnabled) {
                this.configService.isFileUploadEnabled = this.isFileUploadEnabled;
            }
            if (changes.isMultipleFileUploadEnabled) {
                this.configService.isMultipleFileUploadEnabled =
                    this.isMultipleFileUploadEnabled;
            }
            if (changes.areMentionsEnabled) {
                this.configService.areMentionsEnabled = this.areMentionsEnabled;
            }
            if (changes.mentionScope) {
                this.configService.mentionScope = this.mentionScope;
            }
            if (changes.mode) {
                this.setCanSendMessages();
            }
            if (changes.inputMode) {
                this.configService.inputMode = this.inputMode;
            }
            if (changes.sendMessage$) {
                if (this.sendMessageSubcription) {
                    this.sendMessageSubcription.unsubscribe();
                }
                if (this.sendMessage$) {
                    this.sendMessageSubcription = this.sendMessage$.subscribe(function () { return void _this.messageSent(); });
                }
            }
        };
        MessageInputComponent.prototype.ngOnDestroy = function () {
            if (this.sendMessageSubcription) {
                this.sendMessageSubcription.unsubscribe();
            }
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        MessageInputComponent.prototype.messageSent = function () {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var attachmentUploadInProgressCounter, attachments, text, textContainsOnlySpaceChars, message, error_1;
                return __generator(this, function (_12) {
                    switch (_12.label) {
                        case 0:
                            if (this.isCooldownInProgress) {
                                return [2 /*return*/];
                            }
                            this.attachmentService.attachmentUploadInProgressCounter$
                                .pipe(operators.first())
                                .subscribe(function (counter) { return (attachmentUploadInProgressCounter = counter); });
                            if (attachmentUploadInProgressCounter > 0) {
                                if (!this.hideNotification) {
                                    this.hideNotification =
                                        this.notificationService.addPermanentNotification('streamChat.Wait until all attachments have uploaded');
                                }
                                return [2 /*return*/];
                            }
                            attachments = this.attachmentService.mapToAttachments();
                            text = this.textareaValue;
                            text = text.replace(/^\n+/g, ''); // leading empty lines
                            text = text.replace(/\n+$/g, ''); // ending empty lines
                            textContainsOnlySpaceChars = !text.replace(/ /g, '');
                            if ((!text || textContainsOnlySpaceChars) &&
                                (!attachments || attachments.length === 0)) {
                                return [2 /*return*/];
                            }
                            if (textContainsOnlySpaceChars) {
                                text = '';
                            }
                            if (this.containsLinks && !this.canSendLinks) {
                                this.notificationService.addTemporaryNotification('streamChat.Sending links is not allowed in this conversation');
                                return [2 /*return*/];
                            }
                            if (!this.isUpdate) {
                                this.textareaValue = '';
                            }
                            _12.label = 1;
                        case 1:
                            _12.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, (this.isUpdate
                                    ? this.channelService.updateMessage(Object.assign(Object.assign({}, this.message), { text: text, attachments: attachments }))
                                    : this.channelService.sendMessage(text, attachments, this.mentionedUsers, this.parentMessageId, (_a = this.quotedMessage) === null || _a === void 0 ? void 0 : _a.id))];
                        case 2:
                            message = _12.sent();
                            this.messageUpdate.emit({ message: message });
                            if (!this.isUpdate) {
                                this.attachmentService.resetAttachmentUploads();
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            error_1 = _12.sent();
                            if (this.isUpdate) {
                                this.notificationService.addTemporaryNotification('streamChat.Edit message request failed');
                            }
                            return [3 /*break*/, 4];
                        case 4:
                            void this.channelService.typingStopped(this.parentMessageId);
                            if (this.quotedMessage) {
                                this.deselectMessageToQuote();
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        Object.defineProperty(MessageInputComponent.prototype, "containsLinks", {
            get: function () {
                return /(?:(?:https?|ftp):\/\/)?[\w/\-?=%.]+\.[\w/\-&?=%.]+/.test(this.textareaValue);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MessageInputComponent.prototype, "quotedMessageAttachments", {
            get: function () {
                var _a;
                var originalAttachments = (_a = this.quotedMessage) === null || _a === void 0 ? void 0 : _a.attachments;
                return originalAttachments && originalAttachments.length
                    ? [originalAttachments[0]]
                    : [];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MessageInputComponent.prototype, "disabledTextareaText", {
            get: function () {
                if (!this.canSendMessages) {
                    return this.mode === 'thread'
                        ? "streamChat.You can't send thread replies in this channel"
                        : "streamChat.You can't send messages in this channel";
                }
                return '';
            },
            enumerable: false,
            configurable: true
        });
        MessageInputComponent.prototype.filesSelected = function (fileList) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_12) {
                    switch (_12.label) {
                        case 0: return [4 /*yield*/, this.areAttachemntsValid(fileList)];
                        case 1:
                            if (!(_12.sent())) {
                                return [2 /*return*/];
                            }
                            return [4 /*yield*/, this.attachmentService.filesSelected(fileList)];
                        case 2:
                            _12.sent();
                            this.clearFileInput();
                            return [2 /*return*/];
                    }
                });
            });
        };
        MessageInputComponent.prototype.deselectMessageToQuote = function () {
            this.channelService.selectMessageToQuote(undefined);
        };
        MessageInputComponent.prototype.getEmojiPickerContext = function () {
            return {
                emojiInput$: this.emojiInputService.emojiInput$,
            };
        };
        MessageInputComponent.prototype.getAttachmentPreviewListContext = function () {
            return {
                attachmentUploads$: this.attachmentService.attachmentUploads$,
                deleteUploadHandler: this.deleteUpload.bind(this),
                retryUploadHandler: this.retryUpload.bind(this),
            };
        };
        MessageInputComponent.prototype.getAttachmentUploadContext = function () {
            return {
                isMultipleFileUploadEnabled: this.isMultipleFileUploadEnabled,
                attachmentService: this.attachmentService,
            };
        };
        MessageInputComponent.prototype.deleteUpload = function (upload) {
            var _this = this;
            if (this.isUpdate) {
                // Delay delete to avoid modal detecting this click as outside click
                setTimeout(function () {
                    void _this.attachmentService.deleteAttachment(upload);
                });
            }
            else {
                void this.attachmentService.deleteAttachment(upload);
            }
        };
        MessageInputComponent.prototype.retryUpload = function (file) {
            void this.attachmentService.retryAttachmentUpload(file);
        };
        MessageInputComponent.prototype.clearFileInput = function () {
            this.fileInput.nativeElement.value = '';
        };
        Object.defineProperty(MessageInputComponent.prototype, "isUpdate", {
            get: function () {
                return !!this.message;
            },
            enumerable: false,
            configurable: true
        });
        MessageInputComponent.prototype.initTextarea = function () {
            // cleanup previously built textarea
            if (!this.canSendMessages) {
                this.textareaRef = undefined;
            }
            if (!this.canSendMessages || this.textareaRef || !this.textareaAnchor) {
                return;
            }
            var componentFactory = this.componentFactoryResolver.resolveComponentFactory(this.textareaType);
            this.textareaRef =
                this.textareaAnchor.viewContainerRef.createComponent(componentFactory);
            this.cdRef.detectChanges();
        };
        MessageInputComponent.prototype.areAttachemntsValid = function (fileList) {
            return __awaiter(this, void 0, void 0, function () {
                var isValid;
                var _this = this;
                return __generator(this, function (_12) {
                    switch (_12.label) {
                        case 0:
                            if (!fileList) {
                                return [2 /*return*/, true];
                            }
                            if (!!this.appSettings) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.chatClient.getAppSettings()];
                        case 1:
                            _12.sent();
                            _12.label = 2;
                        case 2:
                            isValid = true;
                            Array.from(fileList).forEach(function (f) {
                                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11;
                                var hasBlockedExtension;
                                var hasBlockedMimeType;
                                var hasNotAllowedExtension;
                                var hasNotAllowedMimeType;
                                if (isImageFile(f)) {
                                    hasBlockedExtension =
                                        !!((_c = (_b = (_a = _this.appSettings) === null || _a === void 0 ? void 0 : _a.image_upload_config) === null || _b === void 0 ? void 0 : _b.blocked_file_extensions) === null || _c === void 0 ? void 0 : _c.find(function (ext) { return f.name.endsWith(ext); }));
                                    hasBlockedMimeType =
                                        !!((_f = (_e = (_d = _this.appSettings) === null || _d === void 0 ? void 0 : _d.image_upload_config) === null || _e === void 0 ? void 0 : _e.blocked_mime_types) === null || _f === void 0 ? void 0 : _f.find(function (type) { return f.type === type; }));
                                    hasNotAllowedExtension =
                                        !!((_j = (_h = (_g = _this.appSettings) === null || _g === void 0 ? void 0 : _g.image_upload_config) === null || _h === void 0 ? void 0 : _h.allowed_file_extensions) === null || _j === void 0 ? void 0 : _j.length) &&
                                            !((_m = (_l = (_k = _this.appSettings) === null || _k === void 0 ? void 0 : _k.image_upload_config) === null || _l === void 0 ? void 0 : _l.allowed_file_extensions) === null || _m === void 0 ? void 0 : _m.find(function (ext) { return f.name.endsWith(ext); }));
                                    hasNotAllowedMimeType =
                                        !!((_q = (_p = (_o = _this.appSettings) === null || _o === void 0 ? void 0 : _o.image_upload_config) === null || _p === void 0 ? void 0 : _p.allowed_mime_types) === null || _q === void 0 ? void 0 : _q.length) &&
                                            !((_t = (_s = (_r = _this.appSettings) === null || _r === void 0 ? void 0 : _r.image_upload_config) === null || _s === void 0 ? void 0 : _s.allowed_mime_types) === null || _t === void 0 ? void 0 : _t.find(function (type) { return f.type === type; }));
                                }
                                else {
                                    hasBlockedExtension =
                                        !!((_w = (_v = (_u = _this.appSettings) === null || _u === void 0 ? void 0 : _u.file_upload_config) === null || _v === void 0 ? void 0 : _v.blocked_file_extensions) === null || _w === void 0 ? void 0 : _w.find(function (ext) { return f.name.endsWith(ext); }));
                                    hasBlockedMimeType =
                                        !!((_z = (_y = (_x = _this.appSettings) === null || _x === void 0 ? void 0 : _x.file_upload_config) === null || _y === void 0 ? void 0 : _y.blocked_mime_types) === null || _z === void 0 ? void 0 : _z.find(function (type) { return f.type === type; }));
                                    hasNotAllowedExtension =
                                        !!((_2 = (_1 = (_0 = _this.appSettings) === null || _0 === void 0 ? void 0 : _0.file_upload_config) === null || _1 === void 0 ? void 0 : _1.allowed_file_extensions) === null || _2 === void 0 ? void 0 : _2.length) &&
                                            !((_5 = (_4 = (_3 = _this.appSettings) === null || _3 === void 0 ? void 0 : _3.file_upload_config) === null || _4 === void 0 ? void 0 : _4.allowed_file_extensions) === null || _5 === void 0 ? void 0 : _5.find(function (ext) { return f.name.endsWith(ext); }));
                                    hasNotAllowedMimeType =
                                        !!((_8 = (_7 = (_6 = _this.appSettings) === null || _6 === void 0 ? void 0 : _6.file_upload_config) === null || _7 === void 0 ? void 0 : _7.allowed_mime_types) === null || _8 === void 0 ? void 0 : _8.length) &&
                                            !((_11 = (_10 = (_9 = _this.appSettings) === null || _9 === void 0 ? void 0 : _9.file_upload_config) === null || _10 === void 0 ? void 0 : _10.allowed_mime_types) === null || _11 === void 0 ? void 0 : _11.find(function (type) { return f.type === type; }));
                                }
                                if (hasBlockedExtension ||
                                    hasBlockedMimeType ||
                                    hasNotAllowedExtension ||
                                    hasNotAllowedMimeType) {
                                    _this.notificationService.addTemporaryNotification('streamChat.Error uploading file, extension not supported', undefined, undefined, { name: f.name, ext: f.type });
                                    isValid = false;
                                }
                            });
                            return [2 /*return*/, isValid];
                    }
                });
            });
        };
        MessageInputComponent.prototype.setCanSendMessages = function () {
            var _a, _b;
            var capabilities = (_b = (_a = this.channel) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.own_capabilities;
            if (!capabilities) {
                this.canSendMessages = false;
            }
            else {
                this.canSendMessages =
                    capabilities.indexOf(this.mode === 'main' ? 'send-message' : 'send-reply') !== -1;
            }
            if (this.isViewInited) {
                this.cdRef.detectChanges();
                this.initTextarea();
            }
        };
        Object.defineProperty(MessageInputComponent.prototype, "parentMessageId", {
            get: function () {
                var parentMessageId = undefined;
                if (this.mode === 'thread') {
                    this.channelService.activeParentMessageId$
                        .pipe(operators.first())
                        .subscribe(function (id) { return (parentMessageId = id); });
                }
                return parentMessageId;
            },
            enumerable: false,
            configurable: true
        });
        MessageInputComponent.prototype.startCooldown = function (cooldown) {
            var _this = this;
            this.textareaPlaceholder = this.slowModeTextareaPlaceholder;
            this.isCooldownInProgress = true;
            this.cooldown$ = rxjs.timer(0, 1000).pipe(operators.take(cooldown + 1), operators.map(function (v) { return cooldown - v; }), operators.tap(function (v) {
                if (v === 0) {
                    _this.stopCooldown();
                }
            }));
        };
        MessageInputComponent.prototype.stopCooldown = function () {
            this.cooldown$ = undefined;
            this.isCooldownInProgress = false;
            this.textareaPlaceholder = this.defaultTextareaPlaceholder;
        };
        return MessageInputComponent;
    }());
    MessageInputComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageInputComponent, deps: [{ token: ChannelService }, { token: NotificationService }, { token: AttachmentService }, { token: MessageInputConfigService }, { token: textareaInjectionToken }, { token: i0__namespace.ComponentFactoryResolver }, { token: i0__namespace.ChangeDetectorRef }, { token: ChatClientService }, { token: EmojiInputService }, { token: CustomTemplatesService }, { token: ThemeService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MessageInputComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: MessageInputComponent, selector: "stream-message-input", inputs: { isFileUploadEnabled: "isFileUploadEnabled", areMentionsEnabled: "areMentionsEnabled", mentionScope: "mentionScope", mode: "mode", isMultipleFileUploadEnabled: "isMultipleFileUploadEnabled", message: "message", sendMessage$: "sendMessage$", inputMode: "inputMode", autoFocus: "autoFocus" }, outputs: { messageUpdate: "messageUpdate" }, host: { properties: { "class": "this.class" } }, providers: [AttachmentService, EmojiInputService], viewQueries: [{ propertyName: "fileInput", first: true, predicate: ["fileInput"], descendants: true }, { propertyName: "textareaAnchor", first: true, predicate: TextareaDirective, descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  *ngIf=\"themeVersion !== '2'\"\n  class=\"{{\n    mode === 'main' ? 'str-chat__input-flat' : 'str-chat__small-message-input'\n  }}\"\n  [class.str-chat__input-flat-has-attachments]=\"\n    (attachmentUploads$ | async)!.length > 0\n  \"\n  [class.str-chat__input-flat-quoted]=\"!!quotedMessage\"\n>\n  <div class=\"quoted-message-preview\" *ngIf=\"quotedMessage\">\n    <div class=\"quoted-message-preview-header\">\n      <div>{{ \"streamChat.Reply to Message\" | translate }}</div>\n      <button\n        class=\"str-chat__square-button\"\n        data-testid=\"remove-quote\"\n        (click)=\"deselectMessageToQuote()\"\n        (keyup.enter)=\"deselectMessageToQuote()\"\n      >\n        <stream-icon-placeholder\n          icon=\"close-no-outline\"\n        ></stream-icon-placeholder>\n      </button>\n    </div>\n    <div class=\"quoted-message-preview-content\">\n      <stream-avatar-placeholder\n        data-testid=\"qouted-message-avatar\"\n        class=\"str-chat-angular__avatar-host\"\n        [imageUrl]=\"quotedMessage?.user?.image\"\n        [name]=\"quotedMessage?.user?.name || quotedMessage?.user?.id\"\n        [size]=\"20\"\n        type=\"user\"\n        location=\"quoted-message-sender\"\n        [user]=\"quotedMessage?.user || undefined\"\n      ></stream-avatar-placeholder>\n      <div class=\"quoted-message-preview-content-inner\">\n        <stream-attachment-list\n          *ngIf=\"\n            quotedMessage?.attachments && quotedMessage?.attachments?.length\n          \"\n          [attachments]=\"quotedMessageAttachments\"\n          [messageId]=\"quotedMessage?.id\"\n        ></stream-attachment-list>\n        <div\n          data-testid=\"quoted-message-text\"\n          [innerHTML]=\"\n            message?.quoted_message?.translation ||\n            quotedMessage?.html ||\n            quotedMessage?.text\n          \"\n        ></div>\n      </div>\n    </div>\n  </div>\n  <div class=\"str-chat__input-flat-wrapper\">\n    <div\n      class=\"{{\n        mode === 'main'\n          ? 'str-chat__input-flat--textarea-wrapper'\n          : 'str-chat__small-message-input--textarea-wrapper'\n      }}\"\n    >\n      <ng-template\n        #defaultAttachmentsPreview\n        let-attachmentUploads$=\"attachmentUploads$\"\n        let-retryUploadHandler=\"retryUploadHandler\"\n        let-deleteUploadHandler=\"deleteUploadHandler\"\n      >\n        <stream-attachment-preview-list\n          [attachmentUploads$]=\"attachmentUploads$\"\n          (retryAttachmentUpload)=\"retryUploadHandler($event)\"\n          (deleteAttachment)=\"deleteUploadHandler($event)\"\n          class=\"rfu-image-previewer-angular-host\"\n        ></stream-attachment-preview-list>\n      </ng-template>\n      <ng-container\n        *ngTemplateOutlet=\"\n          attachmentPreviewListTemplate || defaultAttachmentsPreview;\n          context: getAttachmentPreviewListContext()\n        \"\n      ></ng-container>\n      <div class=\"rta str-chat__textarea str-chat-angular__textarea\">\n        <ng-container *ngIf=\"emojiPickerTemplate\" data-testid=\"emoji-picker\">\n          <div\n            class=\"\n              str-chat__input-flat-emojiselect\n              str-chat-angular__emojiselect\n            \"\n          >\n            <ng-container\n              *ngTemplateOutlet=\"\n                emojiPickerTemplate;\n                context: getEmojiPickerContext()\n              \"\n            ></ng-container>\n          </div>\n        </ng-container>\n        <ng-container *ngIf=\"canSendMessages; else disabledTextarea\">\n          <ng-container\n            streamTextarea\n            [(value)]=\"textareaValue\"\n            (valueChange)=\"typingStart$.next()\"\n            (send)=\"messageSent()\"\n            [componentRef]=\"textareaRef\"\n            (userMentions)=\"mentionedUsers = $event\"\n            [areMentionsEnabled]=\"areMentionsEnabled\"\n            [mentionScope]=\"mentionScope\"\n            [placeholder]=\"textareaPlaceholder\"\n            [inputMode]=\"inputMode\"\n            [autoFocus]=\"autoFocus\"\n          ></ng-container>\n        </ng-container>\n        <ng-template #disabledTextarea>\n          <textarea\n            disabled\n            rows=\"1\"\n            [value]=\"disabledTextareaText | translate\"\n            class=\"rta__textarea str-chat__textarea__textarea\"\n            data-testid=\"disabled-textarea\"\n          ></textarea>\n        </ng-template>\n      </div>\n      <ng-container\n        *ngIf=\"isFileUploadEnabled && isFileUploadAuthorized && canSendMessages\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            customAttachmentUploadTemplate || defaultAttachmentUpload;\n            context: getAttachmentUploadContext()\n          \"\n        ></ng-container>\n        <ng-template #defaultAttachmentUpload>\n          <div\n            class=\"str-chat__fileupload-wrapper\"\n            data-testid=\"file-upload-button\"\n          >\n            <div class=\"str-chat__tooltip\">\n              {{ \"streamChat.Attach files\" | translate }}\n            </div>\n            <div class=\"rfu-file-upload-button\">\n              <label>\n                <input\n                  #fileInput\n                  type=\"file\"\n                  class=\"rfu-file-input\"\n                  data-testid=\"file-input\"\n                  [multiple]=\"isMultipleFileUploadEnabled\"\n                  (change)=\"filesSelected(fileInput.files)\"\n                />\n                <span class=\"str-chat__input-flat-fileupload\">\n                  <stream-icon-placeholder\n                    icon=\"file-upload\"\n                  ></stream-icon-placeholder>\n                </span>\n              </label>\n            </div>\n          </div>\n        </ng-template>\n      </ng-container>\n    </div>\n    <button\n      *ngIf=\"canSendMessages && !isCooldownInProgress\"\n      data-testid=\"send-button\"\n      class=\"str-chat__send-button\"\n      (click)=\"messageSent()\"\n      (keyup.enter)=\"messageSent()\"\n    >\n      <stream-icon-placeholder\n        class=\"str-chat__send-button-angular\"\n        icon=\"send\"\n      ></stream-icon-placeholder>\n    </button>\n    <div\n      class=\"str-chat__input-flat-cooldown\"\n      *ngIf=\"isCooldownInProgress\"\n      data-testid=\"cooldown-timer\"\n    >\n      <div class=\"str-chat__message-input-cooldown-text\">\n        {{ cooldown$ | async }}\n      </div>\n    </div>\n  </div>\n</div>\n\n<div\n  *ngIf=\"themeVersion === '2'\"\n  class=\"str-chat__message-input str-chat-angular__message-input\"\n>\n  <div *ngIf=\"quotedMessage\" class=\"str-chat__quoted-message-preview-header\">\n    <div class=\"str-chat__quoted-message-reply-to-message\">\n      {{ \"streamChat.Reply to Message\" | translate }}\n    </div>\n    <button\n      class=\"str-chat__quoted-message-remove\"\n      data-testid=\"remove-quote\"\n      (click)=\"deselectMessageToQuote()\"\n      (keyup.enter)=\"deselectMessageToQuote()\"\n    >\n      <stream-icon-placeholder\n        icon=\"close-no-outline\"\n      ></stream-icon-placeholder>\n    </button>\n  </div>\n  <ng-container *ngIf=\"canSendMessages; else notAllowed\">\n    <div\n      class=\"\n        str-chat__message-input-inner\n        str-chat-angular__message-input-inner\n      \"\n    >\n      <ng-container\n        *ngIf=\"isFileUploadEnabled && isFileUploadAuthorized && canSendMessages\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            customAttachmentUploadTemplate || defaultAttachmentUpload;\n            context: getAttachmentUploadContext()\n          \"\n        ></ng-container>\n        <ng-template #defaultAttachmentUpload>\n          <div\n            class=\"str-chat__file-input-container\"\n            data-testid=\"file-upload-button\"\n          >\n            <input\n              #fileInput\n              type=\"file\"\n              class=\"str-chat__file-input\"\n              data-testid=\"file-input\"\n              [multiple]=\"isMultipleFileUploadEnabled\"\n              (change)=\"filesSelected(fileInput.files)\"\n              id=\"{{ fileInputId }}\"\n            />\n            <label class=\"str-chat__file-input-label\" for=\"{{ fileInputId }}\">\n              <stream-icon-placeholder icon=\"attach\"></stream-icon-placeholder>\n            </label>\n          </div>\n        </ng-template>\n      </ng-container>\n      <div class=\"str-chat__message-textarea-container\">\n        <div\n          data-testid=\"quoted-message-container\"\n          class=\"str-chat__quoted-message-preview\"\n          *ngIf=\"quotedMessage\"\n        >\n          <stream-avatar-placeholder\n            data-testid=\"qouted-message-avatar\"\n            class=\"\n              str-chat-angular__avatar-host\n              str-chat__message-sender-avatar\n            \"\n            [imageUrl]=\"quotedMessage?.user?.image\"\n            [name]=\"quotedMessage?.user?.name || quotedMessage?.user?.id\"\n            [size]=\"20\"\n            type=\"user\"\n            location=\"quoted-message-sender\"\n            [user]=\"quotedMessage?.user || undefined\"\n          ></stream-avatar-placeholder>\n          <div\n            class=\"\n              quoted-message-preview-content-inner\n              str-chat__quoted-message-bubble\n            \"\n          >\n            <stream-attachment-list\n              *ngIf=\"\n                quotedMessage?.attachments && quotedMessage?.attachments?.length\n              \"\n              [attachments]=\"quotedMessageAttachments\"\n              [messageId]=\"quotedMessage?.id\"\n            ></stream-attachment-list>\n            <div\n              class=\"str-chat__quoted-message-text\"\n              data-testid=\"quoted-message-text\"\n              [innerHTML]=\"\n                quotedMessage?.translation ||\n                quotedMessage?.html ||\n                quotedMessage?.text\n              \"\n            ></div>\n          </div>\n        </div>\n        <ng-template\n          #defaultAttachmentsPreview\n          let-attachmentUploads$=\"attachmentUploads$\"\n          let-retryUploadHandler=\"retryUploadHandler\"\n          let-deleteUploadHandler=\"deleteUploadHandler\"\n        >\n          <stream-attachment-preview-list\n            [attachmentUploads$]=\"attachmentUploads$\"\n            (retryAttachmentUpload)=\"retryUploadHandler($event)\"\n            (deleteAttachment)=\"deleteUploadHandler($event)\"\n            class=\"str-chat__attachment-preview-list-angular-host\"\n          ></stream-attachment-preview-list>\n        </ng-template>\n        <ng-container\n          *ngTemplateOutlet=\"\n            attachmentPreviewListTemplate || defaultAttachmentsPreview;\n            context: getAttachmentPreviewListContext()\n          \"\n        ></ng-container>\n        <div class=\"str-chat__message-textarea-with-emoji-picker\">\n          <ng-container\n            streamTextarea\n            [(value)]=\"textareaValue\"\n            (valueChange)=\"typingStart$.next()\"\n            (send)=\"messageSent()\"\n            [componentRef]=\"textareaRef\"\n            (userMentions)=\"mentionedUsers = $event\"\n            [areMentionsEnabled]=\"areMentionsEnabled\"\n            [mentionScope]=\"mentionScope\"\n            [inputMode]=\"inputMode\"\n            [autoFocus]=\"autoFocus\"\n            [placeholder]=\"textareaPlaceholder\"\n          ></ng-container>\n          <ng-container *ngIf=\"emojiPickerTemplate\" data-testid=\"emoji-picker\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                emojiPickerTemplate;\n                context: getEmojiPickerContext()\n              \"\n            ></ng-container>\n          </ng-container>\n        </div>\n      </div>\n      <button\n        *ngIf=\"canSendMessages && !isCooldownInProgress && !message\"\n        [disabled]=\"\n          (attachmentUploadInProgressCounter$ | async)! > 0 ||\n          (!textareaValue && (attachmentUploads$ | async)!.length === 0)\n        \"\n        data-testid=\"send-button\"\n        class=\"str-chat__send-button\"\n        (click)=\"messageSent()\"\n        (keyup.enter)=\"messageSent()\"\n      >\n        <stream-icon-placeholder icon=\"send\"></stream-icon-placeholder>\n      </button>\n      <div\n        class=\"str-chat__message-input-cooldown\"\n        *ngIf=\"isCooldownInProgress\"\n        data-testid=\"cooldown-timer\"\n      >\n        {{ cooldown$ | async }}\n      </div>\n    </div>\n  </ng-container>\n  <ng-template #notAllowed>\n    <div\n      class=\"str-chat__message-input-not-allowed\"\n      data-testid=\"disabled-textarea\"\n    >\n      {{ disabledTextareaText | translate }}\n    </div>\n  </ng-template>\n</div>\n", components: [{ type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }, { type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "size", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { type: AttachmentListComponent, selector: "stream-attachment-list", inputs: ["messageId", "parentMessageId", "attachments"], outputs: ["imageModalStateChange"] }, { type: AttachmentPreviewListComponent, selector: "stream-attachment-preview-list", inputs: ["attachmentUploads$"], outputs: ["retryAttachmentUpload", "deleteAttachment"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: TextareaDirective, selector: "[streamTextarea]", inputs: ["componentRef", "areMentionsEnabled", "mentionScope", "inputMode", "value", "placeholder", "autoFocus"], outputs: ["valueChange", "send", "userMentions"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageInputComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-message-input',
                        templateUrl: './message-input.component.html',
                        styles: [],
                        providers: [AttachmentService, EmojiInputService],
                    }]
            }], ctorParameters: function () {
            return [{ type: ChannelService }, { type: NotificationService }, { type: AttachmentService }, { type: MessageInputConfigService }, { type: i0__namespace.Type, decorators: [{
                            type: i0.Inject,
                            args: [textareaInjectionToken]
                        }] }, { type: i0__namespace.ComponentFactoryResolver }, { type: i0__namespace.ChangeDetectorRef }, { type: ChatClientService }, { type: EmojiInputService }, { type: CustomTemplatesService }, { type: ThemeService }];
        }, propDecorators: { isFileUploadEnabled: [{
                    type: i0.Input
                }], areMentionsEnabled: [{
                    type: i0.Input
                }], mentionScope: [{
                    type: i0.Input
                }], mode: [{
                    type: i0.Input
                }], isMultipleFileUploadEnabled: [{
                    type: i0.Input
                }], message: [{
                    type: i0.Input
                }], sendMessage$: [{
                    type: i0.Input
                }], inputMode: [{
                    type: i0.Input
                }], autoFocus: [{
                    type: i0.Input
                }], messageUpdate: [{
                    type: i0.Output
                }], class: [{
                    type: i0.HostBinding
                }], fileInput: [{
                    type: i0.ViewChild,
                    args: ['fileInput']
                }], textareaAnchor: [{
                    type: i0.ViewChild,
                    args: [TextareaDirective, { static: false }]
                }] } });

    /**
     * The `Notification` component displays a notification within the [`NotificationList`](./NotificationListComponent.mdx)
     */
    var NotificationComponent = /** @class */ (function () {
        function NotificationComponent() {
        }
        return NotificationComponent;
    }());
    NotificationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: NotificationComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    NotificationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: NotificationComponent, selector: "stream-notification", inputs: { type: "type", content: "content" }, ngImport: i0__namespace, template: "<div\n  class=\"str-chat__custom-notification notification-{{\n    type\n  }} str-chat__notification\"\n  data-testid=\"custom-notification\"\n>\n  <ng-container *ngIf=\"content; else elseContent\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </ng-container>\n  <ng-template #elseContent>\n    <ng-content></ng-content>\n  </ng-template>\n</div>\n", directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: NotificationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-notification',
                        templateUrl: './notification.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { type: [{
                    type: i0.Input
                }], content: [{
                    type: i0.Input
                }] } });

    /**
     * The `NotificationList` component displays the list of active notifications.
     */
    var NotificationListComponent = /** @class */ (function () {
        function NotificationListComponent(customTemplatesService, notificationService, themeService) {
            this.customTemplatesService = customTemplatesService;
            this.notificationService = notificationService;
            this.themeService = themeService;
            this.notifications$ = this.notificationService.notifications$;
            this.theme$ = this.themeService.theme$;
            this.themeVersion = this.themeService.themeVersion;
        }
        NotificationListComponent.prototype.trackById = function (_, item) {
            return item.id;
        };
        NotificationListComponent.prototype.getNotificationContentContext = function (notification) {
            return Object.assign(Object.assign({}, notification.templateContext), { dismissFn: notification.dismissFn });
        };
        return NotificationListComponent;
    }());
    NotificationListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: NotificationListComponent, deps: [{ token: CustomTemplatesService }, { token: NotificationService }, { token: ThemeService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    NotificationListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: NotificationListComponent, selector: "stream-notification-list", ngImport: i0__namespace, template: "<div\n  class=\"str-chat__theme-{{ theme$ | async }} str-chat__list-notifications\"\n  [class.str-chat]=\"themeVersion === '2'\"\n  data-testid=\"notification-list\"\n>\n  <ng-container\n    *ngFor=\"let notification of notifications$ | async; trackBy: trackById\"\n  >\n    <ng-template #notificationContent>\n      <div\n        *ngIf=\"notification.text !== undefined\"\n        data-testclass=\"notification-content\"\n      >\n        {{ notification.text | translate: notification.translateParams }}\n      </div>\n      <ng-container *ngIf=\"notification.template !== undefined\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            notification.template;\n            context: getNotificationContentContext(notification)\n          \"\n        ></ng-container>\n      </ng-container>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.notificationTemplate$ | async) ||\n          defaultNotification;\n        context: { type: notification.type, content: notificationContent }\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n\n<ng-template #defaultNotification let-type=\"type\" let-content=\"content\">\n  <stream-notification [type]=\"type\" [content]=\"content\"></stream-notification>\n</ng-template>\n", components: [{ type: NotificationComponent, selector: "stream-notification", inputs: ["type", "content"] }], directives: [{ type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: NotificationListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-notification-list',
                        templateUrl: './notification-list.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: NotificationService }, { type: ThemeService }]; } });

    /**
     * The edit message form displays a modal that's opened when a user edits a message. The component uses the [`MessageActionsService`](../../services/MessageActionsService) to know which message is being edited.
     *
     * By default this is displayed within the [`stream-channel` component](../../components/ChannelComponent).
     */
    var EditMessageFormComponent = /** @class */ (function () {
        function EditMessageFormComponent(customTemplatesService, messageActionsService) {
            this.customTemplatesService = customTemplatesService;
            this.messageActionsService = messageActionsService;
            this.class = 'str-chat-angular__edit-message-form';
            this.isModalOpen = false;
            this.sendMessageSubject = new rxjs.Subject();
            this.subscriptions = [];
            this.sendMessage$ = this.sendMessageSubject.asObservable();
        }
        EditMessageFormComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.messageActionsService.messageToEdit$.subscribe(function (message) {
                if ((message && !_this.isModalOpen) || (!message && _this.isModalOpen)) {
                    _this.message = message;
                    _this.isModalOpen = !!message;
                }
            });
        };
        EditMessageFormComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        EditMessageFormComponent.prototype.getEditModalContext = function () {
            var _this = this;
            return {
                isOpen: this.isModalOpen,
                isOpenChangeHandler: function (isOpen) {
                    _this.isModalOpen = isOpen;
                    if (!_this.isModalOpen) {
                        _this.dismissed();
                    }
                },
                content: this.modalContent,
            };
        };
        EditMessageFormComponent.prototype.getMessageInputContext = function () {
            var _this = this;
            return {
                message: this.message,
                messageUpdateHandler: function () {
                    _this.dismissed();
                },
                isFileUploadEnabled: undefined,
                areMentionsEnabled: undefined,
                isMultipleFileUploadEnabled: undefined,
                mentionScope: undefined,
                mode: undefined,
                sendMessage$: this.sendMessage$,
            };
        };
        EditMessageFormComponent.prototype.sendClicked = function () {
            this.sendMessageSubject.next();
        };
        EditMessageFormComponent.prototype.dismissed = function () {
            this.isModalOpen = false;
            this.message = undefined;
            this.messageActionsService.messageToEdit$.next(undefined);
        };
        return EditMessageFormComponent;
    }());
    EditMessageFormComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: EditMessageFormComponent, deps: [{ token: CustomTemplatesService }, { token: MessageActionsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    EditMessageFormComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: EditMessageFormComponent, selector: "stream-edit-message-form", host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "modalContent", first: true, predicate: ["editMessageForm"], descendants: true, static: true }], ngImport: i0__namespace, template: "<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.modalTemplate$ | async) || defaultModal;\n    context: getEditModalContext()\n  \"\n></ng-container>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    [isOpen]=\"isOpen\"\n    *ngIf=\"isOpen\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n    [content]=\"content\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #editMessageForm>\n  <div class=\"str-chat__edit-message-form\">\n    <ng-template\n      #defaultInput\n      let-messageInput=\"message\"\n      let-messageUpdateHandler=\"messageUpdateHandler\"\n      let-sendMessage$Input=\"sendMessage$\"\n    >\n      <stream-message-input\n        [message]=\"messageInput\"\n        (messageUpdate)=\"messageUpdateHandler()\"\n        [sendMessage$]=\"sendMessage$Input\"\n      ></stream-message-input>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.messageInputTemplate$ | async) || defaultInput;\n        context: getMessageInputContext()\n      \"\n    >\n    </ng-container>\n\n    <stream-notification-list></stream-notification-list>\n    <div\n      class=\"\n        str-chat__message-team-form-footer\n        str-chat__message-team-form-footer-angular\n      \"\n    >\n      <div class=\"str-chat__edit-message-form-options\">\n        <button\n          class=\"str-chat__edit-message-cancel\"\n          translate\n          data-testid=\"cancel-button\"\n          (click)=\"dismissed()\"\n        >\n          streamChat.Cancel\n        </button>\n        <button\n          type=\"submit\"\n          translate\n          class=\"str-chat__edit-message-send\"\n          data-testid=\"send-button\"\n          (click)=\"sendClicked()\"\n          (keyup.enter)=\"sendClicked()\"\n        >\n          streamChat.Send\n        </button>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: ModalComponent, selector: "stream-modal", inputs: ["isOpen", "content"], outputs: ["isOpenChange"] }, { type: MessageInputComponent, selector: "stream-message-input", inputs: ["isFileUploadEnabled", "areMentionsEnabled", "mentionScope", "mode", "isMultipleFileUploadEnabled", "message", "sendMessage$", "inputMode", "autoFocus"], outputs: ["messageUpdate"] }, { type: NotificationListComponent, selector: "stream-notification-list" }], directives: [{ type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i9__namespace.TranslateDirective, selector: "[translate],[ngx-translate]", inputs: ["translate", "translateParams"] }], pipes: { "async": i8__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: EditMessageFormComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-edit-message-form',
                        templateUrl: './edit-message-form.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: MessageActionsService }]; }, propDecorators: { class: [{
                    type: i0.HostBinding
                }], modalContent: [{
                    type: i0.ViewChild,
                    args: ['editMessageForm', { static: true }]
                }] } });

    /**
     * The component watches for the [`channelService.bouncedMessage$` stream](../../services/ChannelService/#bouncedmessage) and opens the bounce modal if a message is emitted.
     *
     * To bounce messages, you need to set up [semantic filters for moderation](https://getstream.io/automated-moderation/docs/automod_configuration/?q=semantic%20filters).
     */
    var MessageBouncePromptComponent = /** @class */ (function () {
        function MessageBouncePromptComponent(channelService, customTemplatesService, messageActionsService) {
            var _this = this;
            this.channelService = channelService;
            this.customTemplatesService = customTemplatesService;
            this.messageActionsService = messageActionsService;
            this.class = 'str-chat__message-bounce-prompt';
            this.isModalOpen = false;
            this.subscriptions = [];
            this.messageBounceModalOpenChanged = function (isOpen) {
                _this.isModalOpen = isOpen;
                if (!isOpen) {
                    _this.message = undefined;
                    _this.channelService.bouncedMessage$.next(undefined);
                }
            };
            this.subscriptions.push(this.channelService.bouncedMessage$.subscribe(function (m) {
                if (m !== _this.message) {
                    _this.message = m;
                    if (_this.message) {
                        _this.isModalOpen = true;
                    }
                }
            }));
        }
        MessageBouncePromptComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        MessageBouncePromptComponent.prototype.resendMessage = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.isModalOpen = false;
                            return [4 /*yield*/, this.channelService.resendMessage(this.message)];
                        case 1:
                            _a.sent();
                            this.message = undefined;
                            this.channelService.bouncedMessage$.next(undefined);
                            return [2 /*return*/];
                    }
                });
            });
        };
        MessageBouncePromptComponent.prototype.deleteMessage = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.message) {
                                return [2 /*return*/];
                            }
                            this.isModalOpen = false;
                            return [4 /*yield*/, this.channelService.deleteMessage(this.message, true)];
                        case 1:
                            _a.sent();
                            this.message = undefined;
                            this.channelService.bouncedMessage$.next(undefined);
                            return [2 /*return*/];
                    }
                });
            });
        };
        MessageBouncePromptComponent.prototype.editMessage = function () {
            this.isModalOpen = false;
            this.messageActionsService.messageToEdit$.next(this.message);
            this.message = undefined;
            this.channelService.bouncedMessage$.next(undefined);
        };
        return MessageBouncePromptComponent;
    }());
    MessageBouncePromptComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageBouncePromptComponent, deps: [{ token: ChannelService }, { token: CustomTemplatesService }, { token: MessageActionsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MessageBouncePromptComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: MessageBouncePromptComponent, selector: "stream-message-bounce-prompt", host: { properties: { "class": "this.class" } }, ngImport: i0__namespace, template: "<ng-container\n  *ngTemplateOutlet=\"\n    (customTemplatesService.modalTemplate$ | async) || defaultModal;\n    context: {\n      message: message,\n      isOpen: isModalOpen,\n      isOpenChangeHandler: messageBounceModalOpenChanged,\n      content: modalContent\n    }\n  \"\n></ng-container>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    [isOpen]=\"isOpen\"\n    *ngIf=\"isOpen\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n    [content]=\"content\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div\n    class=\"str-chat__message-bounce-prompt\"\n    data-testid=\"message-bounce-prompt\"\n  >\n    <div class=\"str-chat__message-bounce-prompt-header\">\n      {{\n        \"streamChat.This message did not meet our content guidelines\"\n          | translate\n      }}\n    </div>\n    <div class=\"str-chat__message-bounce-actions\">\n      <button\n        class=\"str-chat__message-bounce-edit\"\n        data-testid=\"message-bounce-edit\"\n        (click)=\"editMessage()\"\n        (keyup.enter)=\"editMessage()\"\n        type=\"button\"\n      >\n        {{ \"streamChat.Edit Message\" | translate }}\n      </button>\n      <button\n        class=\"str-chat__message-bounce-send\"\n        data-testid=\"message-bounce-send\"\n        (click)=\"resendMessage()\"\n        (keyup.enter)=\"resendMessage()\"\n      >\n        {{ \"streamChat.Send Anyway\" | translate }}\n      </button>\n      <button\n        class=\"str-chat__message-bounce-delete\"\n        data-testid=\"message-bounce-delete\"\n        (click)=\"deleteMessage()\"\n        (keyup.enter)=\"deleteMessage()\"\n      >\n        {{ \"streamChat.Delete\" | translate }}\n      </button>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: ModalComponent, selector: "stream-modal", inputs: ["isOpen", "content"], outputs: ["isOpenChange"] }], directives: [{ type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageBouncePromptComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-message-bounce-prompt',
                        templateUrl: './message-bounce-prompt.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: ChannelService }, { type: CustomTemplatesService }, { type: MessageActionsService }]; }, propDecorators: { class: [{
                    type: i0.HostBinding
                }] } });

    /**
     * The `Channel` component is a container component that displays the [`ChannelHeader`](./ChannelHeaderComponent.mdx), [`MessageList`](./MessageListComponent.mdx), [`NotificationList`](./NotificationListComponent.mdx) and [`MessageInput`](./MessageInputComponent.mdx) components. You can also provide the [`Thread`](./ThreadComponent.mdx) component to use message [threads](https://getstream.io/chat/docs/javascript/threads/?language=javascript).
     */
    var ChannelComponent = /** @class */ (function () {
        function ChannelComponent(channelService, themeService, customTemplatesService) {
            this.channelService = channelService;
            this.themeService = themeService;
            this.customTemplatesService = customTemplatesService;
            this.subscriptions = [];
            this.isError$ = rxjs.combineLatest([
                this.channelService.channelQueryState$,
                this.channelService.activeChannel$,
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), state = _b[0], activeChannel = _b[1];
                return !activeChannel && (state === null || state === void 0 ? void 0 : state.state) === 'error';
            }));
            this.isInitializing$ = rxjs.combineLatest([
                this.channelService.channelQueryState$,
                this.channelService.activeChannel$,
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), state = _b[0], activeChannel = _b[1];
                return !activeChannel && (state === null || state === void 0 ? void 0 : state.state) === 'in-progress';
            }));
            this.isActiveThread$ = this.channelService.activeParentMessageId$.pipe(operators.map(function (id) { return !!id; }));
            this.theme$ = this.themeService.theme$;
            this.isActiveChannel$ = this.channelService.activeChannel$.pipe(operators.map(function (c) { return !!c; }));
        }
        return ChannelComponent;
    }());
    ChannelComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelComponent, deps: [{ token: ChannelService }, { token: ThemeService }, { token: CustomTemplatesService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ChannelComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: ChannelComponent, selector: "stream-channel", ngImport: i0__namespace, template: "<div\n  class=\"str-chat str-chat-channel messaging str-chat__channel str-chat__theme-{{\n    theme$ | async\n  }}\"\n>\n  <div\n    class=\"str-chat__container\"\n    *ngIf=\"\n      (isError$ | async) === false &&\n        (isInitializing$ | async) === false &&\n        (isActiveChannel$ | async) === true;\n      else noChannel\n    \"\n  >\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.editMessageFormTemplate$ | async) ||\n        defaultEditMessageForm\n      \"\n    ></ng-container>\n    <ng-template #defaultEditMessageForm>\n      <stream-edit-message-form></stream-edit-message-form>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.messageBouncePromptTemplate$ | async) ||\n        defaultMessageBouncePrompt\n      \"\n    ></ng-container>\n    <ng-template #defaultMessageBouncePrompt>\n      <stream-message-bounce-prompt></stream-message-bounce-prompt>\n    </ng-template>\n    <div class=\"str-chat__main-panel\">\n      <ng-content></ng-content>\n    </div>\n    <ng-content\n      *ngIf=\"isActiveThread$ | async\"\n      select='[name=\"thread\"]'\n    ></ng-content>\n  </div>\n  <ng-template #noChannel>\n    <div\n      class=\"str-chat__empty-channel\"\n      *ngIf=\"\n        (isInitializing$ | async) === false &&\n        ((isError$ | async) === true || (isActiveChannel$ | async) === false)\n      \"\n    >\n      <stream-icon icon=\"chat-bubble\"></stream-icon>\n      <p class=\"str-chat__empty-channel-text\">\n        {{ \"streamChat.No chats here yet\u2026\" | translate }}\n      </p>\n      <div class=\"str-chat__empty-channel-notifications\">\n        <stream-notification-list></stream-notification-list>\n      </div>\n    </div>\n    <div\n      *ngIf=\"\n        (isInitializing$ | async) === true &&\n        (isError$ | async) === false &&\n        (isActiveChannel$ | async) === false\n      \"\n      class=\"str-chat__loading-channel\"\n    >\n      <div class=\"str-chat__loading-channel-header\">\n        <div class=\"str-chat__loading-channel-header-avatar\"></div>\n        <div class=\"str-chat__loading-channel-header-end\">\n          <div class=\"str-chat__loading-channel-header-name\"></div>\n          <div class=\"str-chat__loading-channel-header-info\"></div>\n        </div>\n      </div>\n      <div class=\"str-chat__loading-channel-message-list\">\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"str-chat__loading-channel-message\">\n          <div class=\"str-chat__loading-channel-message-avatar\"></div>\n          <div class=\"str-chat__loading-channel-message-end\">\n            <div class=\"str-chat__loading-channel-message-sender\"></div>\n            <div class=\"str-chat__loading-channel-message-last-row\">\n              <div class=\"str-chat__loading-channel-message-text\"></div>\n              <div class=\"str-chat__loading-channel-message-date\"></div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"str-chat__loading-channel-message-input-row\">\n        <div class=\"str-chat__loading-channel-message-input\"></div>\n        <div class=\"str-chat__loading-channel-message-send\"></div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n", components: [{ type: EditMessageFormComponent, selector: "stream-edit-message-form" }, { type: MessageBouncePromptComponent, selector: "stream-message-bounce-prompt" }, { type: IconComponent, selector: "stream-icon", inputs: ["icon", "size"] }, { type: NotificationListComponent, selector: "stream-notification-list" }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-channel',
                        templateUrl: './channel.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: ChannelService }, { type: ThemeService }, { type: CustomTemplatesService }]; } });

    var listUsers = function (users) {
        var outStr = '';
        var slicedArr = users.map(function (item) { return item.name || item.id; }).slice(0, 5);
        var restLength = users.length - slicedArr.length;
        var commaSeparatedUsers = slicedArr.join(', ');
        outStr = commaSeparatedUsers;
        if (restLength > 0) {
            outStr += " +" + restLength;
        }
        return outStr;
    };

    var getChannelDisplayText = function (channel, currentUser) {
        var _a;
        if ((_a = channel.data) === null || _a === void 0 ? void 0 : _a.name) {
            return channel.data.name;
        }
        if (channel.state.members && Object.keys(channel.state.members).length > 0) {
            var members = Object.values(channel.state.members)
                .map(function (m) { return m.user || { id: m.user_id }; })
                .filter(function (m) { return m.id !== (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id); });
            return listUsers(members);
        }
        return channel.id;
    };

    /**
     * The `ChannelListToggleService` can be used to toggle the channel list.
     *
     * @deprecated This service can only be used with [theming-v1](../concepts/theming-and-css.mdx), if you are using [thmeing-v2](../theming/introduction.mdx) please refer to our [responsive layout guide](../code-examples/responsive-layout.mdx)
     */
    var ChannelListToggleService = /** @class */ (function () {
        function ChannelListToggleService() {
            var _this = this;
            this.isOpenSubject = new rxjs.BehaviorSubject(false);
            this.isOpen$ = this.isOpenSubject
                .asObservable()
                .pipe(operators.distinctUntilChanged());
            this.isOpen$.pipe(operators.filter(function (s) { return s; })).subscribe(function () {
                _this.watchForOutsideClicks();
            });
        }
        /**
         * Opens the channel list.
         */
        ChannelListToggleService.prototype.open = function () {
            this.isOpenSubject.next(true);
        };
        /**
         * Closes the channel list.
         */
        ChannelListToggleService.prototype.close = function () {
            this.isOpenSubject.next(false);
        };
        /**
         * Opens the channel list if it was closed, and closes if it was opened.
         */
        ChannelListToggleService.prototype.toggle = function () {
            this.isOpenSubject.getValue() ? this.close() : this.open();
        };
        /**
         * Sets the channel list element, on mobile screen size if the user opens the channel list, and clicks outside, the service automatically closes the channel list if a reference to the HTML element is provided.
         * @param element
         */
        ChannelListToggleService.prototype.setMenuElement = function (element) {
            this.menuElement = element;
        };
        /**
         * This method should be called if a channel was selected, if on mobile, the channel list will be closed.
         */
        ChannelListToggleService.prototype.channelSelected = function () {
            this.close();
        };
        ChannelListToggleService.prototype.watchForOutsideClicks = function () {
            var _this = this;
            if (!this.menuElement) {
                return;
            }
            var eventHandler = function (event) {
                if (!_this.menuElement.contains(event.target)) {
                    _this.close();
                    window.removeEventListener('click', eventHandler);
                }
            };
            window.addEventListener('click', eventHandler);
            this.isOpen$
                .pipe(operators.filter(function (s) { return !s; }), operators.first())
                .subscribe(function () { return window.removeEventListener('click', eventHandler); });
        };
        return ChannelListToggleService;
    }());
    ChannelListToggleService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelListToggleService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ChannelListToggleService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelListToggleService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelListToggleService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return []; } });

    /**
     * The `ChannelHeader` component displays the avatar and name of the currently active channel along with member and watcher information. You can read about [the difference between members and watchers](https://getstream.io/chat/docs/javascript/watch_channel/?language=javascript#watchers-vs-members) in the platform documentation. Please note that number of watchers is only displayed if the user has [`connect-events` capability](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript)
     */
    var ChannelHeaderComponent = /** @class */ (function () {
        function ChannelHeaderComponent(channelService, channelListToggleService, customTemplatesService, cdRef, chatClientService) {
            var _this = this;
            this.channelService = channelService;
            this.channelListToggleService = channelListToggleService;
            this.customTemplatesService = customTemplatesService;
            this.cdRef = cdRef;
            this.chatClientService = chatClientService;
            this.subscriptions = [];
            this.channelService.activeChannel$.subscribe(function (c) {
                var _a, _b;
                _this.activeChannel = c;
                var capabilities = (_b = (_a = _this.activeChannel) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.own_capabilities;
                if (!capabilities) {
                    return;
                }
                _this.canReceiveConnectEvents =
                    capabilities.indexOf('connect-events') !== -1;
            });
        }
        ChannelHeaderComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.customTemplatesService.channelActionsTemplate$.subscribe(function (template) {
                _this.channelActionsTemplate = template;
                _this.cdRef.detectChanges();
            }));
            this.subscriptions.push(this.customTemplatesService.channelHeaderInfoTemplate$.subscribe(function (template) {
                _this.channelHeaderInfoTemplate = template;
                _this.cdRef.detectChanges();
            }));
        };
        ChannelHeaderComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        ChannelHeaderComponent.prototype.toggleMenu = function (event) {
            event.stopPropagation();
            this.channelListToggleService.toggle();
        };
        ChannelHeaderComponent.prototype.getChannelActionsContext = function () {
            return { channel: this.activeChannel };
        };
        ChannelHeaderComponent.prototype.getChannelInfoContext = function () {
            return { channel: this.activeChannel };
        };
        Object.defineProperty(ChannelHeaderComponent.prototype, "memberCountParam", {
            get: function () {
                var _a, _b;
                return { memberCount: ((_b = (_a = this.activeChannel) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.member_count) || 0 };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChannelHeaderComponent.prototype, "watcherCountParam", {
            get: function () {
                var _a, _b;
                return { watcherCount: ((_b = (_a = this.activeChannel) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.watcher_count) || 0 };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChannelHeaderComponent.prototype, "displayText", {
            get: function () {
                if (!this.activeChannel) {
                    return '';
                }
                return getChannelDisplayText(this.activeChannel, this.chatClientService.chatClient.user);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChannelHeaderComponent.prototype, "avatarName", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.activeChannel) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.name;
            },
            enumerable: false,
            configurable: true
        });
        return ChannelHeaderComponent;
    }());
    ChannelHeaderComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelHeaderComponent, deps: [{ token: ChannelService }, { token: ChannelListToggleService }, { token: CustomTemplatesService }, { token: i0__namespace.ChangeDetectorRef }, { token: ChatClientService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ChannelHeaderComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: ChannelHeaderComponent, selector: "stream-channel-header", ngImport: i0__namespace, template: "<div class=\"str-chat__header-livestream str-chat__channel-header\">\n  <div\n    class=\"str-chat__header-hamburger\"\n    (click)=\"toggleMenu($event)\"\n    (keyup.enter)=\"toggleMenu($event)\"\n  >\n    <stream-icon-placeholder icon=\"menu\"></stream-icon-placeholder>\n  </div>\n  <ng-content></ng-content>\n  <stream-avatar-placeholder\n    imageUrl=\"{{ activeChannel?.data?.image }}\"\n    name=\"{{ avatarName }}\"\n    type=\"channel\"\n    location=\"channel-header\"\n    [channel]=\"activeChannel\"\n    [size]=\"40\"\n  ></stream-avatar-placeholder>\n  <div class=\"str-chat__header-livestream-left str-chat__channel-header-end\">\n    <p\n      data-testid=\"name\"\n      class=\"\n        str-chat__header-livestream-left--title str-chat__channel-header-title\n      \"\n    >\n      {{ displayText }}\n    </p>\n    <ng-container\n      *ngTemplateOutlet=\"\n        channelHeaderInfoTemplate || defaultChannelInfo;\n        context: getChannelInfoContext()\n      \"\n    ></ng-container>\n    <ng-template #defaultChannelInfo>\n      <p\n        data-testid=\"info\"\n        class=\"\n          str-chat__header-livestream-left--members\n          str-chat__channel-header-info\n        \"\n      >\n        {{'streamChat.{{ memberCount }} members' | translate:memberCountParam}}\n        {{canReceiveConnectEvents ? ('streamChat.{{ watcherCount }} online' |\n        translate:watcherCountParam) : ''}}\n      </p>\n    </ng-template>\n  </div>\n  <ng-container *ngIf=\"channelActionsTemplate\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        channelActionsTemplate;\n        context: getChannelActionsContext()\n      \"\n    ></ng-container>\n  </ng-container>\n</div>\n", components: [{ type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }, { type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "size", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }], directives: [{ type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelHeaderComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-channel-header',
                        templateUrl: './channel-header.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: ChannelService }, { type: ChannelListToggleService }, { type: CustomTemplatesService }, { type: i0__namespace.ChangeDetectorRef }, { type: ChatClientService }]; } });

    var isOnSeparateDate = function (date1, date2) {
        if (date1.getDate() !== date2.getDate()) {
            return true;
        }
        else if (date1.getFullYear() !== date2.getFullYear() ||
            date1.getMonth() !== date2.getMonth()) {
            return true;
        }
        return false;
    };

    /**
     * The message service contains configuration options related to displaying the message content
     */
    var MessageService = /** @class */ (function () {
        function MessageService() {
            /**
             * Decides if the message content should be formatted as text or HTML
             *
             * If you display messages as text the following parts are still be displayed as HTML:
             * - user mentions -> you can customize this with your own template using the [`customTemplatesService.mentionTemplate$`](https://getstream.io/chat/docs/sdk/angular/services/CustomTemplatesService/#mentiontemplate)
             * - links -> you can customize this by providing you own [`customLinkRenderer`](#customlinkrenderer) method
             */
            this.displayAs = 'text';
        }
        return MessageService;
    }());
    MessageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MessageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    Dayjs__default['default'].extend(calendar__default['default']);
    Dayjs__default['default'].extend(relativeTime__default['default']);
    var parseDate = function (date, format) {
        if (format === void 0) { format = 'date-time'; }
        var parsedTime = Dayjs__default['default'](date);
        switch (format) {
            case 'date': {
                return parsedTime.calendar(null, {
                    sameDay: '[Today]',
                    nextDay: '[Tomorrow]',
                    nextWeek: 'dddd',
                    lastDay: '[Yesterday]',
                    lastWeek: '[Last] dddd',
                    sameElse: 'MM/DD/YYYY', // Everything else ( 10/17/2011 )
                });
            }
            case 'date-time': {
                return parsedTime.calendar();
            }
            case 'time': {
                return parsedTime.format('h:mm A');
            }
        }
    };

    /**
     * The `DateParserService` parses dates into user-friendly string representations.
     */
    var DateParserService = /** @class */ (function () {
        function DateParserService() {
        }
        /**
         * Return a user-friendly string representation of the time
         * @param date
         * @returns The parsed time
         */
        DateParserService.prototype.parseTime = function (date) {
            if (this.customTimeParser) {
                return this.customTimeParser(date);
            }
            return parseDate(date, 'time');
        };
        /**
         * Return a user-friendly string representation of the date (year, month and date)
         * @param date
         * @returns The parsed date
         */
        DateParserService.prototype.parseDate = function (date) {
            if (this.customDateParser) {
                return this.customDateParser(date);
            }
            return parseDate(date, 'date');
        };
        /**
         * Return a user-friendly string representation of the date and time
         * @param date
         * @returns The parsed date
         */
        DateParserService.prototype.parseDateTime = function (date) {
            if (this.customDateTimeParser) {
                return this.customDateTimeParser(date);
            }
            return parseDate(date, 'date-time');
        };
        return DateParserService;
    }());
    DateParserService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DateParserService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DateParserService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DateParserService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: DateParserService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    /**
     * The `ChannelPreview` component displays a channel preview in the channel list, it consists of the image, name and latest message of the channel.
     */
    var ChannelPreviewComponent = /** @class */ (function () {
        function ChannelPreviewComponent(channelService, ngZone, chatClientService, messageService, customTemplatesService, dateParser) {
            this.channelService = channelService;
            this.ngZone = ngZone;
            this.chatClientService = chatClientService;
            this.customTemplatesService = customTemplatesService;
            this.dateParser = dateParser;
            this.isActive = false;
            this.isUnreadMessageWasCalled = false;
            this.isUnread = false;
            this.latestMessageText = 'streamChat.Nothing yet...';
            this.subscriptions = [];
            this.canSendReadEvents = true;
            this.displayAs = messageService.displayAs;
        }
        ChannelPreviewComponent.prototype.ngOnInit = function () {
            var _this = this;
            var _a, _b, _c, _d;
            this.subscriptions.push(this.chatClientService.user$.subscribe(function (user) {
                if ((user === null || user === void 0 ? void 0 : user.id) !== _this.userId) {
                    _this.userId = user === null || user === void 0 ? void 0 : user.id;
                }
            }));
            this.subscriptions.push(this.channelService.activeChannel$.subscribe(function (activeChannel) { var _a; return (_this.isActive = (activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.id) === ((_a = _this.channel) === null || _a === void 0 ? void 0 : _a.id)); }));
            var messages = (_b = (_a = this.channel) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.latestMessages;
            if (messages && messages.length > 0) {
                this.setLatestMessage(messages[messages.length - 1]);
            }
            this.updateUnreadState();
            var capabilities = ((_d = (_c = this.channel) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.own_capabilities) || [];
            this.canSendReadEvents = capabilities.indexOf('read-events') !== -1;
            this.subscriptions.push(this.channel.on('message.new', this.handleMessageEvent.bind(this)));
            this.subscriptions.push(this.channel.on('message.updated', this.handleMessageEvent.bind(this)));
            this.subscriptions.push(this.channel.on('message.deleted', this.handleMessageEvent.bind(this)));
            this.subscriptions.push(this.channel.on('channel.truncated', this.handleMessageEvent.bind(this)));
            this.subscriptions.push(this.channel.on('message.read', function () { return _this.ngZone.run(function () {
                _this.isUnreadMessageWasCalled = false;
                _this.updateUnreadState();
            }); }));
            this.subscriptions.push(this.chatClientService.events$
                .pipe(operators.filter(function (e) {
                var _a;
                return e.eventType === 'notification.mark_unread' &&
                    _this.channel.id === ((_a = e.event) === null || _a === void 0 ? void 0 : _a.channel_id);
            }))
                .subscribe(function () {
                _this.ngZone.run(function () {
                    _this.isUnreadMessageWasCalled = true;
                    _this.updateUnreadState();
                });
            }));
        };
        ChannelPreviewComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        Object.defineProperty(ChannelPreviewComponent.prototype, "avatarImage", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.channel) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChannelPreviewComponent.prototype, "avatarName", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.channel) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.name;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChannelPreviewComponent.prototype, "title", {
            get: function () {
                if (!this.channel) {
                    return '';
                }
                return getChannelDisplayText(this.channel, this.chatClientService.chatClient.user);
            },
            enumerable: false,
            configurable: true
        });
        ChannelPreviewComponent.prototype.setAsActiveChannel = function () {
            void this.channelService.setAsActiveChannel(this.channel);
        };
        ChannelPreviewComponent.prototype.handleMessageEvent = function (event) {
            var _this = this;
            this.ngZone.run(function () {
                var _a, _b, _c;
                if (((_a = _this.channel) === null || _a === void 0 ? void 0 : _a.state.latestMessages.length) === 0) {
                    _this.latestMessage = undefined;
                    _this.latestMessageStatus = undefined;
                    _this.latestMessageText = 'streamChat.Nothing yet...';
                    _this.latestMessageTime = undefined;
                    return;
                }
                var latestMessage = (_b = _this.channel) === null || _b === void 0 ? void 0 : _b.state.latestMessages[((_c = _this.channel) === null || _c === void 0 ? void 0 : _c.state.latestMessages.length) - 1];
                if (!event.message || (latestMessage === null || latestMessage === void 0 ? void 0 : latestMessage.id) !== event.message.id) {
                    return;
                }
                _this.setLatestMessage(latestMessage);
                _this.updateUnreadState();
            });
        };
        ChannelPreviewComponent.prototype.setLatestMessage = function (message) {
            this.latestMessage = message;
            if (message === null || message === void 0 ? void 0 : message.deleted_at) {
                this.latestMessageText = 'streamChat.Message deleted';
            }
            else if (message === null || message === void 0 ? void 0 : message.text) {
                this.latestMessageText =
                    getMessageTranslation(message, this.channel, this.chatClientService.chatClient.user) || message.text;
            }
            else if ((message === null || message === void 0 ? void 0 : message.attachments) && message.attachments.length) {
                this.latestMessageText = 'streamChat.🏙 Attachment...';
            }
            if (this.latestMessage && this.latestMessage.type === 'regular') {
                this.latestMessageTime = isOnSeparateDate(new Date(), this.latestMessage.created_at)
                    ? this.dateParser.parseDate(this.latestMessage.created_at)
                    : this.dateParser.parseTime(this.latestMessage.created_at);
            }
            else {
                this.latestMessageTime = undefined;
            }
        };
        ChannelPreviewComponent.prototype.updateUnreadState = function () {
            var _a;
            if (this.channel &&
                this.latestMessage &&
                ((_a = this.latestMessage.user) === null || _a === void 0 ? void 0 : _a.id) === this.userId &&
                this.latestMessage.status === 'received' &&
                this.latestMessage.type === 'regular') {
                this.latestMessageStatus =
                    getReadBy(this.latestMessage, this.channel).length > 0
                        ? 'read'
                        : 'delivered';
            }
            else {
                this.latestMessageStatus = undefined;
            }
            if ((this.isActive && !this.isUnreadMessageWasCalled) ||
                !this.canSendReadEvents) {
                this.unreadCount = 0;
                this.isUnread = false;
                return;
            }
            this.unreadCount = this.channel.countUnread();
            this.isUnread = !!this.unreadCount;
        };
        return ChannelPreviewComponent;
    }());
    ChannelPreviewComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelPreviewComponent, deps: [{ token: ChannelService }, { token: i0__namespace.NgZone }, { token: ChatClientService }, { token: MessageService }, { token: CustomTemplatesService }, { token: DateParserService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ChannelPreviewComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: ChannelPreviewComponent, selector: "stream-channel-preview", inputs: { channel: "channel" }, ngImport: i0__namespace, template: "<button\n  class=\"str-chat__channel-preview-messenger str-chat__channel-preview\"\n  [class.str-chat__channel-preview-messenger--active]=\"isActive\"\n  [class.str-chat__channel-preview--active]=\"isActive\"\n  [class.str-chat__channel-preview-messenger--unread]=\"isUnread\"\n  (click)=\"setAsActiveChannel()\"\n  data-testid=\"channel-preview-container\"\n>\n  <div class=\"str-chat__channel-preview-messenger--left\">\n    <stream-avatar-placeholder\n      name=\"{{ avatarName }}\"\n      imageUrl=\"{{ avatarImage }}\"\n      type=\"channel\"\n      [channel]=\"channel\"\n      location=\"channel-preview\"\n      [size]=\"49\"\n    ></stream-avatar-placeholder>\n  </div>\n  <div\n    class=\"\n      str-chat__channel-preview-messenger--right str-chat__channel-preview-end\n    \"\n  >\n    <ng-container\n      *ngTemplateOutlet=\"\n        (customTemplatesService.channelPreviewInfoTemplate$ | async) ||\n          defaultChannelInfo;\n        context: {\n          channelDisplayTitle: title,\n          channel: channel,\n          unreadCount: unreadCount,\n          latestMessageText: latestMessageText,\n          latestMessageStatus: latestMessageStatus,\n          latestMessageTime: latestMessageTime,\n          latestMessage: latestMessage\n        }\n      \"\n    ></ng-container>\n    <ng-template\n      #defaultChannelInfo\n      let-channelDisplayTitle=\"channelDisplayTitle\"\n      let-unreadCount=\"unreadCount\"\n      let-latestMessageText=\"latestMessageText\"\n      let-latestMessageStatus=\"latestMessageStatus\"\n      let-latestMessageTime=\"latestMessageTime\"\n    >\n      <div class=\"str-chat__channel-preview-end-first-row\">\n        <div class=\"str-chat__channel-preview-messenger--name\">\n          <span data-testid=\"channel-preview-title\">{{\n            channelDisplayTitle\n          }}</span>\n        </div>\n        <div\n          data-testid=\"unread-badge\"\n          *ngIf=\"unreadCount\"\n          class=\"str-chat__channel-preview-unread-badge\"\n        >\n          {{ unreadCount }}\n        </div>\n      </div>\n      <div class=\"str-chat__channel-preview-end-second-row\">\n        <div\n          data-testid=\"latest-message\"\n          class=\"str-chat__channel-preview-messenger--last-message\"\n        >\n          <ng-container *ngIf=\"displayAs === 'text'; else asHTML\">\n            {{ latestMessageText | translate }}\n          </ng-container>\n          <ng-template #asHTML>\n            <span\n              data-testid=\"html-content\"\n              [innerHTML]=\"latestMessageText | translate\"\n            ></span>\n          </ng-template>\n        </div>\n        <div\n          data-testid=\"latest-message-status\"\n          *ngIf=\"latestMessageStatus\"\n          class=\"str-chat__channel-preview-messenger--status str-chat__channel-preview-messenger--status-{{\n            latestMessageStatus\n          }}\"\n        >\n          <stream-icon-placeholder\n            [icon]=\"\n              latestMessageStatus === 'delivered'\n                ? 'delivered-icon'\n                : 'read-icon'\n            \"\n          ></stream-icon-placeholder>\n        </div>\n        <div\n          data-testid=\"latest-message-time\"\n          class=\"str-chat__channel-preview-messenger--time\"\n          *ngIf=\"latestMessageTime\"\n        >\n          {{ latestMessageTime }}\n        </div>\n      </div>\n    </ng-template>\n  </div>\n</button>\n", components: [{ type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "size", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }], directives: [{ type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelPreviewComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-channel-preview',
                        templateUrl: './channel-preview.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: ChannelService }, { type: i0__namespace.NgZone }, { type: ChatClientService }, { type: MessageService }, { type: CustomTemplatesService }, { type: DateParserService }]; }, propDecorators: { channel: [{
                    type: i0.Input
                }] } });

    /**
     * The `ChannelList` component renders the list of channels.
     */
    var ChannelListComponent = /** @class */ (function () {
        function ChannelListComponent(channelService, channelListToggleService, customTemplatesService, themeService) {
            var _this = this;
            this.channelService = channelService;
            this.channelListToggleService = channelListToggleService;
            this.customTemplatesService = customTemplatesService;
            this.themeService = themeService;
            this.isLoadingMoreChannels = false;
            this.subscriptions = [];
            this.theme$ = this.themeService.theme$;
            this.isOpen$ = this.channelListToggleService.isOpen$;
            this.channels$ = this.channelService.channels$;
            this.hasMoreChannels$ = this.channelService.hasMoreChannels$;
            this.isError$ = this.channelService.channelQueryState$.pipe(operators.map(function (s) { return !_this.isLoadingMoreChannels && (s === null || s === void 0 ? void 0 : s.state) === 'error'; }));
            this.isInitializing$ = this.channelService.channelQueryState$.pipe(operators.map(function (s) { return !_this.isLoadingMoreChannels && (s === null || s === void 0 ? void 0 : s.state) === 'in-progress'; }));
            this.subscriptions.push(this.customTemplatesService.channelPreviewTemplate$.subscribe(function (template) { return (_this.customChannelPreviewTemplate = template); }));
        }
        ChannelListComponent.prototype.ngAfterViewInit = function () {
            this.channelListToggleService.setMenuElement(this.container.nativeElement);
        };
        ChannelListComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        ChannelListComponent.prototype.loadMoreChannels = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.isLoadingMoreChannels = true;
                            return [4 /*yield*/, this.channelService.loadMoreChannels()];
                        case 1:
                            _a.sent();
                            this.isLoadingMoreChannels = false;
                            return [2 /*return*/];
                    }
                });
            });
        };
        ChannelListComponent.prototype.trackByChannelId = function (index, item) {
            return item.cid;
        };
        ChannelListComponent.prototype.channelSelected = function () {
            this.channelListToggleService.channelSelected();
        };
        return ChannelListComponent;
    }());
    ChannelListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelListComponent, deps: [{ token: ChannelService }, { token: ChannelListToggleService }, { token: CustomTemplatesService }, { token: ThemeService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ChannelListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: ChannelListComponent, selector: "stream-channel-list", viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true }], ngImport: i0__namespace, template: "<div\n  #container\n  data-testid=\"channel-list-container\"\n  class=\"str-chat str-chat__channel-list str-chat-channel-list messaging str-chat__theme-{{\n    theme$ | async\n  }}\"\n  [class.str-chat-channel-list--open]=\"(isOpen$ | async) === true\"\n>\n  <div\n    *ngIf=\"\n      (isError$ | async) === false && (isInitializing$ | async) === false;\n      else statusIndicator\n    \"\n    class=\"str-chat__channel-list-messenger\"\n  >\n    <div class=\"str-chat__channel-list-messenger__main\">\n      <ng-content select=\"[channel-list-top]\"></ng-content>\n      <div\n        class=\"str-chat__channel-list-empty\"\n        *ngIf=\"!(channels$ | async)?.length\"\n      >\n        <stream-icon icon=\"chat-bubble\"></stream-icon>\n        <p data-testid=\"empty-channel-list-indicator\">\n          {{ \"streamChat.You have no channels currently\" | translate }}\n        </p>\n      </div>\n      <p\n        *ngIf=\"!(channels$ | async)?.length\"\n        class=\"str-chat__channel-list-empty-v1\"\n        data-testid=\"empty-channel-list-indicator\"\n      >\n        {{ \"streamChat.You have no channels currently\" | translate }}\n      </p>\n      <ng-container\n        *ngFor=\"let channel of channels$ | async; trackBy: trackByChannelId\"\n      >\n        <ng-template #defaultTemplate let-channelInput=\"channel\">\n          <stream-channel-preview\n            data-testclass=\"channel-preview\"\n            [channel]=\"channelInput\"\n          ></stream-channel-preview>\n        </ng-template>\n        <div (click)=\"channelSelected()\" (keyup.enter)=\"channelSelected()\">\n          <ng-container\n            *ngTemplateOutlet=\"\n              customChannelPreviewTemplate || defaultTemplate;\n              context: { channel: channel }\n            \"\n          ></ng-container>\n        </div>\n      </ng-container>\n      <div\n        *ngIf=\"hasMoreChannels$ | async\"\n        class=\"str-chat__load-more-button\"\n        (click)=\"loadMoreChannels()\"\n        (keyup.enter)=\"loadMoreChannels()\"\n        data-testid=\"load-more\"\n      >\n        <button\n          class=\"str-chat__load-more-button__button str-chat__cta-button\"\n          data-testid=\"load-more-button\"\n          [disabled]=\"isLoadingMoreChannels\"\n        >\n          <span *ngIf=\"!isLoadingMoreChannels; else loadingIndicator\">{{\n            \"Load more\" | translate\n          }}</span>\n          <ng-template #loadingIndicator\n            ><stream-loading-indicator-placeholder></stream-loading-indicator-placeholder\n          ></ng-template>\n        </button>\n      </div>\n      <ng-content select=\"[channel-list-bottom]\"></ng-content>\n    </div>\n  </div>\n</div>\n\n<ng-template #statusIndicator>\n  <ng-container *ngIf=\"isError$ | async\">\n    <ng-container *ngTemplateOutlet=\"chatDown\"></ng-container>\n  </ng-container>\n  <ng-container *ngIf=\"isInitializing$ | async\">\n    <ng-container *ngTemplateOutlet=\"loadingChannels\"></ng-container>\n  </ng-container>\n</ng-template>\n\n<ng-template #chatDown>\n  <div data-testid=\"chatdown-container\" class=\"str-chat__down\">\n    <ng-container *ngTemplateOutlet=\"loadingChannels\"></ng-container>\n    <div class=\"str-chat__down-main\">\n      <stream-icon-placeholder\n        icon=\"connection-error\"\n      ></stream-icon-placeholder>\n      <h1>{{ \"streamChat.Connection error\" | translate }}</h1>\n      <h3>\n        {{\n          \"streamChat.Error connecting to chat, refresh the page to try again.\"\n            | translate\n        }}\n      </h3>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #loadingChannels>\n  <div data-testid=\"loading-indicator\" class=\"str-chat__loading-channels\">\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n    <ng-container *ngTemplateOutlet=\"loadingChannel\"></ng-container>\n  </div>\n</ng-template>\n\n<ng-template #loadingChannel>\n  <div\n    class=\"str-chat__loading-channels-item str-chat__channel-preview-loading\"\n  >\n    <div class=\"str-chat__loading-channels-avatar\"></div>\n    <div\n      class=\"\n        str-chat__loading-channels-meta str-chat__channel-preview-end-loading\n      \"\n    >\n      <div class=\"str-chat__loading-channels-username\"></div>\n      <div class=\"str-chat__loading-channels-status\"></div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: IconComponent, selector: "stream-icon", inputs: ["icon", "size"] }, { type: ChannelPreviewComponent, selector: "stream-channel-preview", inputs: ["channel"] }, { type: LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder", inputs: ["size", "color"] }, { type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ChannelListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-channel-list',
                        templateUrl: './channel-list.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: ChannelService }, { type: ChannelListToggleService }, { type: CustomTemplatesService }, { type: ThemeService }]; }, propDecorators: { container: [{
                    type: i0.ViewChild,
                    args: ['container']
                }] } });

    /**
     * The `MessageReactionsService` provides customization options to message [reactions](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript).
     *
     */
    var MessageReactionsService = /** @class */ (function () {
        function MessageReactionsService() {
            /**
             * The enabled [reactions](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript) and the associated emoji
             *
             * You can provide any string as a reaction. The emoji can be provided as a string, if you want to use custom images for reactions you have to provide a [custom reactions UI](../../services/CustomTemplatesService/#messagereactionstemplate)
             */
            this.reactions$ = new rxjs.BehaviorSubject({
                like: '👍',
                angry: '😠',
                love: '❤️',
                haha: '😂',
                wow: '😮',
                sad: '😞',
            });
        }
        Object.defineProperty(MessageReactionsService.prototype, "reactions", {
            /**
             * Get the currently enabled reactions
             */
            get: function () {
                return this.reactions$.getValue();
            },
            /**
             * Sets the enabled reactions
             */
            set: function (reactions) {
                this.reactions$.next(reactions);
            },
            enumerable: false,
            configurable: true
        });
        return MessageReactionsService;
    }());
    MessageReactionsService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageReactionsService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    MessageReactionsService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageReactionsService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageReactionsService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    /**
     * The `MessageReactions` component displays the reactions of a message, the current user can add and remove reactions. You can read more about [message reactions](https://getstream.io/chat/docs/javascript/send_reaction/?language=javascript) in the platform documentation.
     */
    var MessageReactionsComponent = /** @class */ (function () {
        function MessageReactionsComponent(cdRef, channelService, messageReactionsService, customTemplatesService, themeService) {
            var _this = this;
            this.cdRef = cdRef;
            this.channelService = channelService;
            this.messageReactionsService = messageReactionsService;
            this.customTemplatesService = customTemplatesService;
            this.themeService = themeService;
            /**
             * The number of reactions grouped by [reaction types](https://github.com/GetStream/stream-chat-angular/tree/master/projects/stream-chat-angular/src/lib/message-reactions/message-reactions.component.ts)
             */
            this.messageReactionCounts = {};
            /**
             * Indicates if the selector should be opened or closed. Adding a UI element to open and close the selector is the parent's component responsibility.
             */
            this.isSelectorOpen = false;
            /**
             * List of reactions of a [message](../types/stream-message.mdx), used to display the users of a reaction type.
             */
            this.latestReactions = [];
            /**
             * List of the user's own reactions of a [message](../types/stream-message.mdx), used to display the users of a reaction type.
             */
            this.ownReactions = [];
            /**
             * Indicates if the selector should be opened or closed. Adding a UI element to open and close the selector is the parent's component responsibility.
             */
            this.isSelectorOpenChange = new i0.EventEmitter();
            this.popperTriggerHover = i9$1.NgxPopperjsTriggers.hover;
            this.popperPlacementAuto = i9$1.NgxPopperjsPlacements.AUTO;
            this.isLoading = true;
            this.reactions = [];
            this.shouldHandleReactionClick = true;
            this.existingReactions = [];
            this.reactionsCount = 0;
            this.reactionOptions = [];
            this.subscriptions = [];
            this.isViewInited = false;
            this.isOpenChange = function (isOpen) {
                _this.selectedReactionType = isOpen ? _this.selectedReactionType : undefined;
            };
            this.eventHandler = function (event) {
                var _a;
                if (!((_a = _this.selectorContainer) === null || _a === void 0 ? void 0 : _a.nativeElement.contains(event.target))) {
                    _this.isSelectorOpenChange.emit(false);
                }
            };
        }
        MessageReactionsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.messageReactionsService.reactions$.subscribe(function (reactions) {
                _this.reactionOptions = Object.keys(reactions);
                _this.setExistingReactions();
                if (_this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
        };
        MessageReactionsComponent.prototype.ngOnChanges = function (changes) {
            var _this = this;
            if (changes.isSelectorOpen) {
                this.isSelectorOpen
                    ? setTimeout(function () { return _this.watchForOutsideClicks(); }) // setTimeout: wait for current click to bubble up, and only watch for clicks after that
                    : this.stopWatchForOutsideClicks();
            }
            if (changes.messageReactionCounts) {
                this.setExistingReactions();
            }
            if (changes.messageReactionCounts && this.messageReactionCounts) {
                var reactionsCount = Object.keys(this.messageReactionCounts).reduce(function (acc, key) { return acc + (_this.messageReactionCounts[key] || 0); }, 0);
                this.shouldHandleReactionClick =
                    reactionsCount <= ChannelService.MAX_MESSAGE_REACTIONS_TO_FETCH ||
                        !!this.messageReactionsService.customReactionClickHandler;
            }
        };
        MessageReactionsComponent.prototype.ngAfterViewInit = function () {
            this.isViewInited = true;
        };
        MessageReactionsComponent.prototype.ngAfterViewChecked = function () {
            if (this.tooltipText && !this.tooltipPositions) {
                this.setTooltipPosition();
                this.cdRef.detectChanges();
            }
        };
        MessageReactionsComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        MessageReactionsComponent.prototype.getLatestUserByReaction = function (reactionType) {
            var _a;
            return (_a = this.latestReactions.find(function (r) { return r.type === reactionType && r.user; })) === null || _a === void 0 ? void 0 : _a.user;
        };
        MessageReactionsComponent.prototype.getEmojiByReaction = function (reactionType) {
            return this.messageReactionsService.reactions[reactionType];
        };
        MessageReactionsComponent.prototype.reactionSelected = function (reactionType) {
            if (!this.shouldHandleReactionClick) {
                return;
            }
            if (this.themeService.themeVersion === '1') {
                return;
            }
            if (!this.messageId) {
                return;
            }
            if (this.messageReactionsService.customReactionClickHandler) {
                this.messageReactionsService.customReactionClickHandler({
                    messageId: this.messageId,
                    reactionType: reactionType,
                });
            }
            else {
                this.selectedReactionType = reactionType;
                void this.fetchAllReactions();
            }
        };
        MessageReactionsComponent.prototype.getUsersByReaction = function (reactionType) {
            return this.latestReactions
                .filter(function (r) { return r.type === reactionType; })
                .map(function (r) { var _a, _b; return ((_a = r.user) === null || _a === void 0 ? void 0 : _a.name) || ((_b = r.user) === null || _b === void 0 ? void 0 : _b.id); })
                .filter(function (i) { return !!i; })
                .join(', ');
        };
        MessageReactionsComponent.prototype.getAllUsersByReaction = function (reactionType) {
            if (!reactionType) {
                return [];
            }
            var users = this.reactions
                .filter(function (r) { return r.type === reactionType; })
                .map(function (r) { return r.user; })
                .filter(function (i) { return !!i; });
            users.sort(function (u1, u2) {
                var _a, _b;
                var name1 = (_a = u1.name) === null || _a === void 0 ? void 0 : _a.toLowerCase();
                var name2 = (_b = u2.name) === null || _b === void 0 ? void 0 : _b.toLowerCase();
                if (!name1) {
                    return 1;
                }
                if (!name2) {
                    return -1;
                }
                if (name1 === name2) {
                    return 0;
                }
                if (name1 < name2) {
                    return -1;
                }
                else {
                    return 1;
                }
            });
            return users;
        };
        MessageReactionsComponent.prototype.showTooltip = function (event, reactionType) {
            this.currentTooltipTarget = event.target;
            this.tooltipText = this.getUsersByReaction(reactionType);
        };
        MessageReactionsComponent.prototype.hideTooltip = function () {
            this.tooltipText = undefined;
            this.currentTooltipTarget = undefined;
            this.tooltipPositions = undefined;
        };
        MessageReactionsComponent.prototype.trackByMessageReaction = function (index, item) {
            return item;
        };
        MessageReactionsComponent.prototype.trackByUserId = function (index, item) {
            return item.id;
        };
        MessageReactionsComponent.prototype.react = function (type) {
            return __awaiter(this, void 0, void 0, function () {
                var _d;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            if (!this.ownReactions.find(function (r) { return r.type === type; })) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.channelService.removeReaction(this.messageId, type)];
                        case 1:
                            _d = _e.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, this.channelService.addReaction(this.messageId, type)];
                        case 3:
                            _d = _e.sent();
                            _e.label = 4;
                        case 4:
                            _d;
                            this.isSelectorOpenChange.emit(false);
                            return [2 /*return*/];
                    }
                });
            });
        };
        MessageReactionsComponent.prototype.isOwnReaction = function (reactionType) {
            return !!this.ownReactions.find(function (r) { return r.type === reactionType; });
        };
        MessageReactionsComponent.prototype.watchForOutsideClicks = function () {
            window.addEventListener('click', this.eventHandler);
        };
        MessageReactionsComponent.prototype.stopWatchForOutsideClicks = function () {
            window.removeEventListener('click', this.eventHandler);
        };
        MessageReactionsComponent.prototype.setTooltipPosition = function () {
            var _a, _b, _c;
            var tooltip = (_a = this.selectorTooltip) === null || _a === void 0 ? void 0 : _a.nativeElement.getBoundingClientRect();
            var target = (_b = this.currentTooltipTarget) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
            var container = (_c = this.selectorContainer) === null || _c === void 0 ? void 0 : _c.nativeElement.getBoundingClientRect();
            if (!tooltip || !target || !container)
                return;
            var tooltipPosition = tooltip.width === container.width || tooltip.x < container.x
                ? 0
                : target.left + target.width / 2 - container.left - tooltip.width / 2;
            var arrowPosition = target.x - tooltip.x + target.width / 2 - tooltipPosition;
            this.tooltipPositions = {
                tooltip: tooltipPosition,
                arrow: arrowPosition,
            };
        };
        MessageReactionsComponent.prototype.fetchAllReactions = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _d, error_1;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            if (!this.messageId) {
                                return [2 /*return*/];
                            }
                            this.isLoading = true;
                            _e.label = 1;
                        case 1:
                            _e.trys.push([1, 3, 4, 5]);
                            _d = this;
                            return [4 /*yield*/, this.channelService.getMessageReactions(this.messageId)];
                        case 2:
                            _d.reactions = _e.sent();
                            return [3 /*break*/, 5];
                        case 3:
                            error_1 = _e.sent();
                            this.selectedReactionType = undefined;
                            return [3 /*break*/, 5];
                        case 4:
                            this.isLoading = false;
                            this.cdRef.detectChanges();
                            return [7 /*endfinally*/];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        MessageReactionsComponent.prototype.setExistingReactions = function () {
            var _this = this;
            this.existingReactions = Object.keys(this.messageReactionCounts)
                .filter(function (k) { return _this.reactionOptions.indexOf(k) !== -1; })
                .filter(function (k) { return _this.messageReactionCounts[k] > 0; });
            this.reactionsCount = this.existingReactions.reduce(function (total, reaction) { return total + _this.messageReactionCounts[reaction]; }, 0);
        };
        return MessageReactionsComponent;
    }());
    MessageReactionsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageReactionsComponent, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: ChannelService }, { token: MessageReactionsService }, { token: CustomTemplatesService }, { token: ThemeService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MessageReactionsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: MessageReactionsComponent, selector: "stream-message-reactions", inputs: { messageId: "messageId", messageReactionCounts: "messageReactionCounts", isSelectorOpen: "isSelectorOpen", latestReactions: "latestReactions", ownReactions: "ownReactions" }, outputs: { isSelectorOpenChange: "isSelectorOpenChange" }, viewQueries: [{ propertyName: "selectorContainer", first: true, predicate: ["selectorContainer"], descendants: true }, { propertyName: "selectorTooltip", first: true, predicate: ["selectorTooltip"], descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  *ngIf=\"existingReactions.length > 0\"\n  class=\"str-chat__reaction-list str-chat__message-reactions-container\"\n  [class.str-chat__reaction-list--reverse]=\"true\"\n  [class.str-chat__reaction-list-hidden]=\"isSelectorOpen\"\n  data-testid=\"reaction-list\"\n>\n  <ul class=\"str-chat__message-reactions\">\n    <li\n      class=\"str-chat__message-reaction\"\n      *ngFor=\"\n        let reactionType of existingReactions;\n        trackBy: trackByMessageReaction\n      \"\n      [ngStyle]=\"{ cursor: shouldHandleReactionClick ? 'pointer' : 'default' }\"\n      [class.str-chat__message-reaction-own]=\"isOwnReaction(reactionType)\"\n      data-testclass=\"emoji\"\n      (click)=\"reactionSelected(reactionType)\"\n      (keyup.enter)=\"reactionSelected(reactionType)\"\n    >\n      <span class=\"emoji str-chat__message-reaction-emoji\">\n        {{ getEmojiByReaction(reactionType) }}&nbsp;\n      </span>\n      <span\n        data-testclass=\"reaction-list-reaction-count\"\n        class=\"str-chat__message-reaction-count\"\n      >\n        {{ messageReactionCounts[reactionType] }}\n      </span>\n    </li>\n    <li>\n      <span\n        data-testid=\"reactions-count\"\n        class=\"str-chat__reaction-list--counter\"\n        >{{ reactionsCount }}</span\n      >\n    </li>\n  </ul>\n</div>\n\n<div\n  #selectorContainer\n  class=\"str-chat__reaction-selector str-chat__message-reaction-selector\"\n  *ngIf=\"isSelectorOpen\"\n  data-testid=\"reaction-selector\"\n>\n  <div\n    *ngIf=\"tooltipText\"\n    data-testid=\"tooltip\"\n    #selectorTooltip\n    class=\"str-chat__reaction-selector-tooltip\"\n    [ngStyle]=\"{\n      left: tooltipPositions?.tooltip + 'px',\n      visibility: tooltipPositions ? 'visible' : 'hidden'\n    }\"\n  >\n    <div\n      class=\"arrow\"\n      [ngStyle]=\"{ left: tooltipPositions?.arrow + 'px' }\"\n    ></div>\n    <span class=\"latest-user-username\">\n      {{ tooltipText }}\n    </span>\n  </div>\n  <ul\n    class=\"str-chat__message-reactions-list str-chat__message-reactions-options\"\n  >\n    <li\n      class=\"\n        str-chat__message-reactions-option\n        str-chat__message-reactions-list-item\n        str-chat__emoji\n      \"\n      *ngFor=\"\n        let reactionType of reactionOptions;\n        trackBy: trackByMessageReaction\n      \"\n      [class.str-chat__message-reactions-option-selected]=\"\n        isOwnReaction(reactionType)\n      \"\n      data-testclass=\"emoji-option\"\n      (click)=\"react(reactionType)\"\n      (keyup.enter)=\"react(reactionType)\"\n    >\n      <div\n        *ngIf=\"getLatestUserByReaction(reactionType) as user\"\n        class=\"latest-user str-chat__message-reactions-last-user\"\n        (click)=\"hideTooltip()\"\n        (keyup.enter)=\"hideTooltip()\"\n        (mouseenter)=\"showTooltip($event, reactionType)\"\n        (mouseleave)=\"hideTooltip()\"\n        attr.data-testid=\"{{ reactionType }}-last-user\"\n      >\n        <stream-avatar-placeholder\n          attr.data-testid=\"{{ reactionType }}-avatar\"\n          [imageUrl]=\"user.image\"\n          [name]=\"user.name || user.id\"\n          [size]=\"20\"\n          location=\"reaction\"\n        ></stream-avatar-placeholder>\n      </div>\n      <span\n        class=\"\n          emoji\n          str-chat__emoji-selector-emoji-angular\n          str-chat__message-reaction-emoji\n        \"\n      >\n        {{ getEmojiByReaction(reactionType) }}\n      </span>\n      <span\n        *ngIf=\"\n          messageReactionCounts[reactionType] &&\n          messageReactionCounts[reactionType]! > 0\n        \"\n        class=\"str-chat__message-reactions-list-item__count\"\n        attr.data-testid=\"{{ reactionType }}-reaction-count\"\n      >\n        {{ messageReactionCounts[reactionType] }}\n      </span>\n    </li>\n  </ul>\n</div>\n\n<ng-container *ngIf=\"selectedReactionType\">\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.modalTemplate$ | async) || defaultModal;\n      context: {\n        isOpen: !!selectedReactionType,\n        messageId: messageId,\n        reactionType: selectedReactionType,\n        isOpenChangeHandler: isOpenChange,\n        content: modalContent\n      }\n    \"\n  ></ng-container>\n</ng-container>\n\n<ng-template\n  #defaultModal\n  let-isOpen=\"isOpen\"\n  let-messageId=\"messageId\"\n  let-reactionType=\"reactionType\"\n  let-isOpenChangeHandler=\"isOpenChangeHandler\"\n  let-content=\"content\"\n>\n  <stream-modal\n    class=\"str-chat__message-reactions-details-modal\"\n    [isOpen]=\"isOpen\"\n    (isOpenChange)=\"isOpenChangeHandler($event)\"\n    [content]=\"content\"\n  >\n  </stream-modal>\n</ng-template>\n\n<ng-template #modalContent>\n  <div class=\"str-chat__message-reactions-details\">\n    <div class=\"str-chat__message-reactions-details-reaction-types\">\n      <div\n        class=\"str-chat__message-reactions-details-reaction-type\"\n        *ngFor=\"\n          let reactionType of existingReactions;\n          trackBy: trackByMessageReaction\n        \"\n        [ngStyle]=\"{\n          cursor: shouldHandleReactionClick ? 'pointer' : 'default'\n        }\"\n        attr.data-testid=\"reaction-details-selector-{{ reactionType }}\"\n        [class.str-chat__message-reactions-details-reaction-type--selected]=\"\n          reactionType === selectedReactionType\n        \"\n        (click)=\"selectedReactionType = reactionType; allUsers.scrollTop = 0\"\n        (keyup.enter)=\"\n          selectedReactionType = reactionType; allUsers.scrollTop = 0\n        \"\n      >\n        <span class=\"emoji str-chat__message-reaction-emoji\">\n          {{ getEmojiByReaction(reactionType) }}&nbsp;\n        </span>\n        <span class=\"str-chat__message-reaction-count\">\n          {{ messageReactionCounts[reactionType] }}\n        </span>\n      </div>\n    </div>\n    <div\n      class=\"\n        emoji\n        str-chat__message-reaction-emoji str-chat__message-reaction-emoji-big\n      \"\n    >\n      {{ getEmojiByReaction(selectedReactionType!) }}\n    </div>\n    <div\n      #allUsers\n      data-testid=\"all-reacting-users\"\n      class=\"str-chat__message-reactions-details-reacting-users\"\n    >\n      <stream-loading-indicator\n        *ngIf=\"isLoading; else reactions\"\n      ></stream-loading-indicator>\n      <ng-template #reactions>\n        <div\n          class=\"str-chat__message-reactions-details-reacting-user\"\n          *ngFor=\"\n            let user of getAllUsersByReaction(selectedReactionType);\n            trackBy: trackByUserId\n          \"\n        >\n          <stream-avatar-placeholder\n            data-testclass=\"avatar\"\n            class=\"str-chat__avatar str-chat__avatar--circle\"\n            [size]=\"30\"\n            [imageUrl]=\"user.image\"\n            [name]=\"user.name\"\n            type=\"user\"\n            location=\"reaction\"\n            [user]=\"user\"\n          ></stream-avatar-placeholder>\n          <span\n            data-testclass=\"reaction-user-username\"\n            class=\"str-chat__user-item--name\"\n            >{{ user.name }}</span\n          >\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "size", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { type: ModalComponent, selector: "stream-modal", inputs: ["isOpen", "content"], outputs: ["isOpenChange"] }, { type: LoadingIndicatorComponent, selector: "stream-loading-indicator", inputs: ["size", "color"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i8__namespace.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], pipes: { "async": i8__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageReactionsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-message-reactions',
                        templateUrl: './message-reactions.component.html',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: ChannelService }, { type: MessageReactionsService }, { type: CustomTemplatesService }, { type: ThemeService }]; }, propDecorators: { messageId: [{
                    type: i0.Input
                }], messageReactionCounts: [{
                    type: i0.Input
                }], isSelectorOpen: [{
                    type: i0.Input
                }], latestReactions: [{
                    type: i0.Input
                }], ownReactions: [{
                    type: i0.Input
                }], isSelectorOpenChange: [{
                    type: i0.Output
                }], selectorContainer: [{
                    type: i0.ViewChild,
                    args: ['selectorContainer']
                }], selectorTooltip: [{
                    type: i0.ViewChild,
                    args: ['selectorTooltip']
                }] } });

    /**
     * The `Message` component displays a message with additional information such as sender and date, and enables [interaction with the message (i.e. edit or react)](../concepts/message-interactions.mdx).
     */
    var MessageComponent = /** @class */ (function () {
        function MessageComponent(chatClientService, channelService, customTemplatesService, cdRef, themeService, dateParser, ngZone, messageService, messageActionsService) {
            this.chatClientService = chatClientService;
            this.channelService = channelService;
            this.customTemplatesService = customTemplatesService;
            this.cdRef = cdRef;
            this.dateParser = dateParser;
            this.ngZone = ngZone;
            this.messageService = messageService;
            this.messageActionsService = messageActionsService;
            /**
             * The list of [channel capabilities](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript) that are enabled for the current user, the list of [supported interactions](../concepts/message-interactions.mdx) can be found in our message interaction guide. Unathorized actions won't be displayed on the UI. The [`MessageList`](./MessageListComponent.mdx) component automatically sets this based on [channel capabilities](https://getstream.io/chat/docs/javascript/channel_capabilities/?language=javascript).
             */
            this.enabledMessageActions = [];
            /**
             * Determines if the message is being dispalyed in a channel or in a [thread](https://getstream.io/chat/docs/javascript/threads/?language=javascript).
             */
            this.mode = 'main';
            /**
             * Highlighting is used to add visual emphasize to a message when jumping to the message
             */
            this.isHighlighted = false;
            /**
             * A list of custom message actions to be displayed in the action box
             *
             * @deprecated please use the [`MessageActionsService`](https://getstream.io/chat/docs/sdk/angular/services/MessageActionsService) to set this property.
             */
            this.customActions = [];
            this.isActionBoxOpen = false;
            this.isEditedFlagOpened = false;
            this.isReactionSelectorOpen = false;
            this.visibleMessageActionsCount = 0;
            this.messageTextParts = [];
            this.popperTriggerClick = i9$1.NgxPopperjsTriggers.click;
            this.popperTriggerHover = i9$1.NgxPopperjsTriggers.hover;
            this.popperPlacementAuto = i9$1.NgxPopperjsPlacements.AUTO;
            this.popperPlacementTop = i9$1.NgxPopperjsPlacements.TOP;
            this.shouldDisplayTranslationNotice = false;
            this.displayedMessageTextContent = 'original';
            this.imageAttachmentModalState = 'closed';
            this.shouldDisplayThreadLink = false;
            this.isSentByCurrentUser = false;
            this.readByText = '';
            this.lastReadUser = undefined;
            this.isOnlyReadByMe = false;
            this.isReadByMultipleUsers = false;
            this.isMessageDeliveredAndRead = false;
            this.parsedDate = '';
            this.pasedEditedDate = '';
            this.areOptionsVisible = false;
            this.hasAttachment = false;
            this.hasReactions = false;
            this.replyCountParam = {
                replyCount: undefined,
            };
            this.canDisplayReadStatus = false;
            this.subscriptions = [];
            this.isViewInited = false;
            this.urlRegexp = /(?:(?:https?|ftp|file):\/\/|www\.|ftp\.)(?:\([-A-Z0-9+&@#/%=~_|$?!:,.]*\)|[-A-Z0-9+&@#/%=~_|$?!:,.])*(?:\([-A-Z0-9+&@#/%=~_|$?!:,.]*\)|[A-Z0-9+&@#/%=~_|$])/gim;
            this.emojiRegexp = new RegExp(emojiRegex__default['default'](), 'g');
            this.themeVersion = themeService.themeVersion;
            this.displayAs = this.messageService.displayAs;
        }
        MessageComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.chatClientService.user$.subscribe(function (u) {
                if ((u === null || u === void 0 ? void 0 : u.id) !== _this.userId) {
                    _this.userId = u === null || u === void 0 ? void 0 : u.id;
                    _this.setIsSentByCurrentUser();
                    _this.setLastReadUser();
                    if (_this.isViewInited) {
                        _this.cdRef.detectChanges();
                    }
                }
            }));
        };
        MessageComponent.prototype.ngOnChanges = function (changes) {
            var _a, _b, _c, _d, _e, _f, _g;
            if (changes.message) {
                this.shouldDisplayTranslationNotice = false;
                this.displayedMessageTextContent = 'original';
                this.createMessageParts();
                var originalAttachments = (_b = (_a = this.message) === null || _a === void 0 ? void 0 : _a.quoted_message) === null || _b === void 0 ? void 0 : _b.attachments;
                this.quotedMessageAttachments =
                    originalAttachments && originalAttachments.length
                        ? [originalAttachments[0]]
                        : [];
                this.setIsSentByCurrentUser();
                this.setLastReadUser();
                this.readByText = ((_c = this.message) === null || _c === void 0 ? void 0 : _c.readBy)
                    ? listUsers(this.message.readBy)
                    : '';
                this.isOnlyReadByMe = !!(this.message &&
                    this.message.readBy &&
                    this.message.readBy.length === 0);
                this.isReadByMultipleUsers = !!(this.message &&
                    this.message.readBy &&
                    this.message.readBy.length > 1);
                this.isMessageDeliveredAndRead = !!(this.message &&
                    this.message.readBy &&
                    this.message.status === 'received' &&
                    this.message.readBy.length > 0);
                this.parsedDate =
                    (this.message &&
                        this.message.created_at &&
                        this.dateParser.parseDateTime(this.message.created_at)) ||
                        '';
                this.pasedEditedDate =
                    (this.message &&
                        this.message.message_text_updated_at &&
                        this.dateParser.parseDateTime(new Date(this.message.message_text_updated_at))) ||
                        '';
                this.hasAttachment =
                    !!((_d = this.message) === null || _d === void 0 ? void 0 : _d.attachments) && !!this.message.attachments.length;
                this.hasReactions =
                    !!((_e = this.message) === null || _e === void 0 ? void 0 : _e.reaction_counts) &&
                        Object.keys(this.message.reaction_counts).length > 0;
                this.replyCountParam = { replyCount: (_f = this.message) === null || _f === void 0 ? void 0 : _f.reply_count };
            }
            if (changes.enabledMessageActions) {
                this.canReactToMessage =
                    this.enabledMessageActions.indexOf('send-reaction') !== -1;
                this.canReceiveReadEvents =
                    this.enabledMessageActions.indexOf('read-events') !== -1;
                this.canDisplayReadStatus =
                    this.canReceiveReadEvents !== false &&
                        this.enabledMessageActions.indexOf('read-events') !== -1;
            }
            if (changes.message || changes.enabledMessageActions || changes.mode) {
                this.shouldDisplayThreadLink =
                    !!((_g = this.message) === null || _g === void 0 ? void 0 : _g.reply_count) && this.mode !== 'thread';
            }
            if (changes.message || changes.mode) {
                this.areOptionsVisible = this.message
                    ? !(!this.message.type ||
                        this.message.type === 'error' ||
                        this.message.type === 'system' ||
                        this.message.type === 'ephemeral' ||
                        this.message.status === 'failed' ||
                        this.message.status === 'sending' ||
                        (this.mode === 'thread' && !this.message.parent_id))
                    : false;
            }
            if (changes.message ||
                changes.enabledMessageActions ||
                changes.customActions) {
                if (this.message) {
                    this.visibleMessageActionsCount =
                        this.messageActionsService.getAuthorizedMessageActionsCount(this.message, this.enabledMessageActions);
                }
                else {
                    this.visibleMessageActionsCount = 0;
                }
            }
        };
        MessageComponent.prototype.ngAfterViewInit = function () {
            this.isViewInited = true;
        };
        MessageComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        MessageComponent.prototype.messageActionsClicked = function () {
            if (!this.message) {
                return;
            }
            if (this.messageActionsService.customActionClickHandler) {
                this.messageActionsService.customActionClickHandler({
                    message: this.message,
                    enabledActions: this.enabledMessageActions,
                    customActions: this.customActions,
                    isMine: this.isSentByCurrentUser,
                });
            }
            else {
                this.isActionBoxOpen = !this.isActionBoxOpen;
            }
        };
        MessageComponent.prototype.messageActionsBoxClicked = function (popperContent) {
            popperContent.hide();
        };
        MessageComponent.prototype.getAttachmentListContext = function () {
            var _this = this;
            var _a, _b, _c;
            return {
                messageId: ((_a = this.message) === null || _a === void 0 ? void 0 : _a.id) || '',
                attachments: ((_b = this.message) === null || _b === void 0 ? void 0 : _b.attachments) || [],
                parentMessageId: (_c = this.message) === null || _c === void 0 ? void 0 : _c.parent_id,
                imageModalStateChangeHandler: function (state) { return (_this.imageAttachmentModalState = state); },
            };
        };
        MessageComponent.prototype.getMessageContext = function () {
            return {
                message: this.message,
                enabledMessageActions: this.enabledMessageActions,
                isHighlighted: this.isHighlighted,
                isLastSentMessage: this.isLastSentMessage,
                mode: this.mode,
                customActions: this.customActions,
                parsedDate: this.parsedDate,
            };
        };
        MessageComponent.prototype.getQuotedMessageAttachmentListContext = function () {
            var _a, _b, _c, _d;
            return {
                messageId: ((_b = (_a = this.message) === null || _a === void 0 ? void 0 : _a.quoted_message) === null || _b === void 0 ? void 0 : _b.id) || '',
                attachments: this.quotedMessageAttachments,
                parentMessageId: (_d = (_c = this === null || this === void 0 ? void 0 : this.message) === null || _c === void 0 ? void 0 : _c.quoted_message) === null || _d === void 0 ? void 0 : _d.parent_id,
            };
        };
        MessageComponent.prototype.getMessageReactionsContext = function () {
            var _this = this;
            var _a, _b, _c, _d;
            return {
                messageReactionCounts: ((_a = this.message) === null || _a === void 0 ? void 0 : _a.reaction_counts) || {},
                latestReactions: ((_b = this.message) === null || _b === void 0 ? void 0 : _b.latest_reactions) || [],
                isSelectorOpen: this.isReactionSelectorOpen,
                isSelectorOpenChangeHandler: function (isOpen) { return (_this.isReactionSelectorOpen = isOpen); },
                messageId: (_c = this.message) === null || _c === void 0 ? void 0 : _c.id,
                ownReactions: ((_d = this.message) === null || _d === void 0 ? void 0 : _d.own_reactions) || [],
            };
        };
        MessageComponent.prototype.messageClicked = function () {
            var _a, _b, _c, _d;
            if (((_a = this.message) === null || _a === void 0 ? void 0 : _a.status) === 'failed' &&
                ((_b = this.message) === null || _b === void 0 ? void 0 : _b.errorStatusCode) !== 403) {
                this.resendMessage();
            }
            else if (((_c = this.message) === null || _c === void 0 ? void 0 : _c.type) === 'error' &&
                ((_d = this.message) === null || _d === void 0 ? void 0 : _d.moderation_details)) {
                this.openMessageBouncePrompt();
            }
            else {
                this.isEditedFlagOpened = !this.isEditedFlagOpened;
            }
        };
        MessageComponent.prototype.resendMessage = function () {
            void this.channelService.resendMessage(this.message);
        };
        MessageComponent.prototype.setAsActiveParentMessage = function () {
            void this.channelService.setAsActiveParentMessage(this.message);
        };
        MessageComponent.prototype.getMentionContext = function (messagePart) {
            return {
                content: messagePart.content,
                user: messagePart.user,
            };
        };
        MessageComponent.prototype.getMessageActionsBoxContext = function () {
            var _this = this;
            return {
                isOpen: this.isActionBoxOpen,
                isMine: this.isSentByCurrentUser,
                enabledActions: this.enabledMessageActions,
                message: this.message,
                displayedActionsCountChaneHanler: function (count) {
                    _this.visibleMessageActionsCount = count;
                    // message action box changes UI bindings in parent, so we'll have to rerun change detection
                    _this.cdRef.detectChanges();
                },
                displayedActionsCountChangeHandler: function (count) {
                    _this.visibleMessageActionsCount = count;
                    // message action box changes UI bindings in parent, so we'll have to rerun change detection
                    _this.cdRef.detectChanges();
                },
                customActions: this.customActions || [],
            };
        };
        MessageComponent.prototype.getDeliveredStatusContext = function () {
            return {
                message: this.message,
            };
        };
        MessageComponent.prototype.getSendingStatusContext = function () {
            return {
                message: this.message,
            };
        };
        MessageComponent.prototype.getReadStatusContext = function () {
            return {
                message: this.message,
                readByText: this.readByText,
            };
        };
        MessageComponent.prototype.getMessageMetadataContext = function () {
            return {
                message: this.message,
            };
        };
        MessageComponent.prototype.jumpToMessage = function (messageId, parentMessageId) {
            void this.channelService.jumpToMessage(messageId, parentMessageId);
        };
        MessageComponent.prototype.displayTranslatedMessage = function () {
            this.createMessageParts(true);
        };
        MessageComponent.prototype.displayOriginalMessage = function () {
            this.createMessageParts(false);
        };
        MessageComponent.prototype.openMessageBouncePrompt = function () {
            this.channelService.bouncedMessage$.next(this.message);
        };
        MessageComponent.prototype.createMessageParts = function (shouldTranslate) {
            var _this = this;
            if (shouldTranslate === void 0) { shouldTranslate = true; }
            this.messageTextParts = undefined;
            this.messageText = undefined;
            var content = this.getMessageContent(shouldTranslate);
            if ((!this.message.mentioned_users ||
                this.message.mentioned_users.length === 0) &&
                !(content === null || content === void 0 ? void 0 : content.match(this.emojiRegexp)) &&
                !(content === null || content === void 0 ? void 0 : content.match(this.urlRegexp))) {
                this.messageTextParts = undefined;
                this.messageText = content;
                return;
            }
            if (!content) {
                return;
            }
            if (!this.message.mentioned_users ||
                this.message.mentioned_users.length === 0) {
                content = this.fixEmojiDisplay(content);
                content = this.wrapLinksWithAnchorTag(content);
                this.messageTextParts = [{ content: content, type: 'text' }];
            }
            else {
                this.messageTextParts = [];
                var text_1 = content;
                this.message.mentioned_users.forEach(function (user) {
                    var mention = "@" + (user.name || user.id);
                    var precedingText = text_1.substring(0, text_1.indexOf(mention));
                    var formattedPrecedingText = _this.fixEmojiDisplay(precedingText);
                    formattedPrecedingText = _this.wrapLinksWithAnchorTag(formattedPrecedingText);
                    _this.messageTextParts.push({
                        content: formattedPrecedingText,
                        type: 'text',
                    });
                    _this.messageTextParts.push({
                        content: mention,
                        type: 'mention',
                        user: user,
                    });
                    text_1 = text_1.replace(precedingText + mention, '');
                });
                if (text_1) {
                    text_1 = this.fixEmojiDisplay(text_1);
                    text_1 = this.wrapLinksWithAnchorTag(text_1);
                    this.messageTextParts.push({ content: text_1, type: 'text' });
                }
            }
        };
        MessageComponent.prototype.getMessageContent = function (shouldTranslate) {
            var _a, _b;
            var originalContent = (_a = this.message) === null || _a === void 0 ? void 0 : _a.text;
            if (shouldTranslate) {
                var translation = (_b = this.message) === null || _b === void 0 ? void 0 : _b.translation;
                if (translation) {
                    this.shouldDisplayTranslationNotice = true;
                    this.displayedMessageTextContent = 'translation';
                }
                return translation || originalContent;
            }
            else {
                this.displayedMessageTextContent = 'original';
                return originalContent;
            }
        };
        MessageComponent.prototype.fixEmojiDisplay = function (content) {
            // Wrap emojis in span to display emojis correctly in Chrome https://bugs.chromium.org/p/chromium/issues/detail?id=596223
            // Based on this: https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            var isChrome = !!window.chrome && typeof window.opr === 'undefined';
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
            content = content.replace(this.emojiRegexp, function (match) { return "<span " + (isChrome ? 'class="str-chat__emoji-display-fix"' : '') + ">" + match + "</span>"; });
            return content;
        };
        MessageComponent.prototype.wrapLinksWithAnchorTag = function (content) {
            var _this = this;
            if (this.displayAs === 'html') {
                return content;
            }
            content = content.replace(this.urlRegexp, function (match) { return _this.messageService.customLinkRenderer
                ? _this.messageService.customLinkRenderer(match)
                : "<a href=\"" + match + "\" target=\"_blank\" rel=\"nofollow\">" + match + "</a>"; });
            return content;
        };
        MessageComponent.prototype.setIsSentByCurrentUser = function () {
            var _a, _b;
            this.isSentByCurrentUser = ((_b = (_a = this.message) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.id) === this.userId;
        };
        MessageComponent.prototype.setLastReadUser = function () {
            var _this = this;
            var _a, _b;
            this.lastReadUser = (_b = (_a = this.message) === null || _a === void 0 ? void 0 : _a.readBy) === null || _b === void 0 ? void 0 : _b.filter(function (u) { return u.id !== _this.userId; })[0];
        };
        return MessageComponent;
    }());
    MessageComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageComponent, deps: [{ token: ChatClientService }, { token: ChannelService }, { token: CustomTemplatesService }, { token: i0__namespace.ChangeDetectorRef }, { token: ThemeService }, { token: DateParserService }, { token: i0__namespace.NgZone }, { token: MessageService }, { token: MessageActionsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MessageComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: MessageComponent, selector: "stream-message", inputs: { message: "message", enabledMessageActions: "enabledMessageActions", isLastSentMessage: "isLastSentMessage", mode: "mode", isHighlighted: "isHighlighted", customActions: "customActions" }, viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  #container\n  class=\"str-chat__message-simple str-chat__message str-chat__message--{{\n    message?.type\n  }} str-chat__message--{{ message?.status }} {{\n    message?.text ? 'str-chat__message--has-text' : 'has-no-text'\n  }}\"\n  [class.str-chat__message--me]=\"isSentByCurrentUser\"\n  [class.str-chat__message--other]=\"!isSentByCurrentUser\"\n  [class.str-chat__message-simple--me]=\"isSentByCurrentUser\"\n  [class.str-chat__message--has-attachment]=\"hasAttachment\"\n  [class.str-chat__message--with-reactions]=\"hasReactions\"\n  [class.str-chat__message--highlighted]=\"isHighlighted\"\n  [class.str-chat__message-with-thread-link]=\"shouldDisplayThreadLink\"\n  [class.str-chat__message-send-can-be-retried]=\"\n    (message?.status === 'failed' && message?.errorStatusCode !== 403) ||\n    (message?.type === 'error' && message?.moderation_details)\n  \"\n  data-testid=\"message-container\"\n>\n  <ng-container *ngIf=\"!message?.deleted_at; else deletedMessage\">\n    <ng-container *ngIf=\"message?.type !== 'system'; else systemMessage\">\n      <ng-container *ngIf=\"themeVersion === '1'\">\n        <ng-container *ngTemplateOutlet=\"messageStatus\"></ng-container>\n      </ng-container>\n      <stream-avatar-placeholder\n        data-testid=\"avatar\"\n        class=\"str-chat-angular__avatar-host str-chat__message-sender-avatar\"\n        [imageUrl]=\"message?.user?.image\"\n        [name]=\"message?.user?.name || message?.user?.id\"\n        type=\"user\"\n        location=\"message-sender\"\n        [user]=\"message?.user || undefined\"\n      ></stream-avatar-placeholder>\n      <div class=\"str-chat__message-inner\">\n        <div\n          class=\"str-chat__message-simple__actions str-chat__message-options\"\n          data-testid=\"message-options\"\n          [class.str-chat__message-actions-open]=\"isActionBoxOpen\"\n          *ngIf=\"areOptionsVisible\"\n        >\n          <div\n            data-testid=\"message-actions-container\"\n            #messageActionsToggle\n            class=\"\n              str-chat__message-actions-container\n              str-chat__message-simple__actions__action\n              str-chat__message-simple__actions__action--options\n            \"\n            [popper]=\"popperContent\"\n            [popperTrigger]=\"popperTriggerClick\"\n            [popperPlacement]=\"popperPlacementAuto\"\n            [popperHideOnScroll]=\"false\"\n            [popperHideOnClickOutside]=\"true\"\n            [popperHideOnMouseLeave]=\"false\"\n            [popperDisableAnimation]=\"true\"\n            (popperOnHidden)=\"isActionBoxOpen = false\"\n          >\n            <popper-content #popperContent>\n              <ng-template\n                #defaultMessageActionsBox\n                let-isOpen=\"isOpen\"\n                let-isMine=\"isMine\"\n                let-enabledActions=\"enabledActions\"\n                let-messageInput=\"message\"\n                let-customActions=\"customActions\"\n              >\n                <stream-message-actions-box\n                  (click)=\"messageActionsBoxClicked(popperContent)\"\n                  *ngIf=\"isOpen\"\n                  [isOpen]=\"isOpen\"\n                  [isMine]=\"isMine\"\n                  [enabledActions]=\"enabledActions\"\n                  [customActions]=\"customActions\"\n                  [message]=\"messageInput\"\n                ></stream-message-actions-box>\n              </ng-template>\n              <ng-container\n                *ngTemplateOutlet=\"\n                  (customTemplatesService.messageActionsBoxTemplate$ | async) ||\n                    defaultMessageActionsBox;\n                  context: getMessageActionsBoxContext()\n                \"\n              >\n              </ng-container>\n            </popper-content>\n            <div\n              class=\"str-chat__message-actions-box-button\"\n              data-testid=\"action-icon\"\n              (click)=\"messageActionsClicked()\"\n              (keyup.enter)=\"messageActionsClicked()\"\n              *ngIf=\"visibleMessageActionsCount > 0\"\n            >\n              <stream-icon-placeholder\n                icon=\"action-icon\"\n                class=\"str-chat__message-action-icon\"\n              ></stream-icon-placeholder>\n            </div>\n          </div>\n          <div\n            *ngIf=\"\n              enabledMessageActions.indexOf('send-reply') !== -1 &&\n              mode === 'main'\n            \"\n            class=\"\n              str-chat__message-simple__actions__action\n              str-chat__message-simple__actions__action--thread\n              str-chat__message-reply-in-thread-button\n            \"\n            data-testid=\"reply-in-thread\"\n            (click)=\"setAsActiveParentMessage()\"\n            (keyup.enter)=\"setAsActiveParentMessage()\"\n          >\n            <stream-icon-placeholder\n              class=\"str-chat__message-action-icon\"\n              icon=\"reply-in-thread\"\n            ></stream-icon-placeholder>\n          </div>\n          <div\n            *ngIf=\"canReactToMessage\"\n            class=\"\n              str-chat__message-simple__actions__action\n              str-chat__message-simple__actions__action--reactions\n              str-chat__message-reactions-button\n            \"\n            data-testid=\"reaction-icon\"\n            (click)=\"isReactionSelectorOpen = !isReactionSelectorOpen\"\n            (keyup.enter)=\"isReactionSelectorOpen = !isReactionSelectorOpen\"\n          >\n            <stream-icon-placeholder\n              class=\"str-chat__message-action-icon\"\n              icon=\"reaction-icon\"\n            ></stream-icon-placeholder>\n          </div>\n        </div>\n        <div class=\"str-chat__message-reactions-host\">\n          <ng-template\n            #defaultMessageReactions\n            let-messageReactionCounts=\"messageReactionCounts\"\n            let-latestReactions=\"latestReactions\"\n            let-isSelectorOpen=\"isSelectorOpen\"\n            let-isSelectorOpenChangeHandler=\"isSelectorOpenChangeHandler\"\n            let-messageId=\"messageId\"\n            let-ownReactions=\"ownReactions\"\n          >\n            <stream-message-reactions\n              [messageReactionCounts]=\"messageReactionCounts\"\n              [latestReactions]=\"latestReactions\"\n              [isSelectorOpen]=\"isSelectorOpen\"\n              (isSelectorOpenChange)=\"isSelectorOpenChangeHandler($event)\"\n              [messageId]=\"messageId\"\n              [ownReactions]=\"ownReactions\"\n            ></stream-message-reactions>\n          </ng-template>\n          <ng-container\n            *ngTemplateOutlet=\"\n              (customTemplatesService.messageReactionsTemplate$ | async) ||\n                defaultMessageReactions;\n              context: getMessageReactionsContext()\n            \"\n          ></ng-container>\n        </div>\n        <div\n          class=\"str-chat__message-bubble str-chat-angular__message-bubble\"\n          [class.str-chat-angular__message-bubble--attachment-modal-open]=\"\n            imageAttachmentModalState === 'opened'\n          \"\n        >\n          <ng-container *ngIf=\"hasAttachment && !message?.quoted_message\">\n            <ng-container\n              *ngTemplateOutlet=\"attachmentsTemplate\"\n            ></ng-container>\n          </ng-container>\n          <div\n            class=\"str-chat__message-text\"\n            tabindex=\"0\"\n            *ngIf=\"message?.text || (message?.quoted_message && hasAttachment)\"\n            [class.str-chat__message-text--pointer-cursor]=\"\n              (message?.status === 'failed' &&\n                message?.errorStatusCode !== 403) ||\n              (this.message?.type === 'error' &&\n                this.message?.moderation_details) ||\n              message?.message_text_updated_at\n            \"\n            (click)=\"messageClicked()\"\n            (keyup.enter)=\"messageClicked()\"\n          >\n            <div\n              data-testid=\"inner-message\"\n              class=\"\n                str-chat__message-text-inner str-chat__message-simple-text-inner\n              \"\n              [class.str-chat__message-light-text-inner--has-attachment]=\"\n                hasAttachment\n              \"\n            >\n              <ng-container *ngTemplateOutlet=\"quotedMessage\"></ng-container>\n              <ng-container *ngIf=\"hasAttachment && message?.quoted_message\">\n                <ng-container\n                  *ngTemplateOutlet=\"attachmentsTemplate\"\n                ></ng-container>\n              </ng-container>\n              <div\n                data-testid=\"client-error-message\"\n                *ngIf=\"message?.type === 'error'\"\n                class=\"\n                  str-chat__simple-message--error-message\n                  str-chat__message--error-message\n                \"\n              >\n                <ng-container *ngIf=\"!message?.moderation_details\">{{\n                  \"streamChat.Error \u00B7 Unsent\" | translate\n                }}</ng-container>\n              </div>\n              <div\n                data-testid=\"error-message\"\n                *ngIf=\"message?.status === 'failed'\"\n                class=\"\n                  str-chat__simple-message--error-message\n                  str-chat__message--error-message\n                \"\n              >\n                {{\n                  (message?.errorStatusCode === 403\n                    ? \"streamChat.Message Failed \u00B7 Unauthorized\"\n                    : \"streamChat.Message Failed \u00B7 Click to try again\"\n                  ) | translate\n                }}\n              </div>\n              <div data-testid=\"text\">\n                <p>\n                  <ng-container *ngIf=\"messageTextParts; else defaultContent\">\n                    <!-- eslint-disable-next-line @angular-eslint/template/use-track-by-function -->\n                    <ng-container *ngFor=\"let part of messageTextParts\">\n                      <span\n                        *ngIf=\"part.type === 'text'; else mention\"\n                        [innerHTML]=\"part.content\"\n                      ></span>\n                      <ng-template #mention>\n                        <ng-template #defaultMention let-content=\"content\">\n                          <span class=\"str-chat__message-mention\">{{\n                            content\n                          }}</span>\n                        </ng-template>\n                        <ng-container\n                          *ngTemplateOutlet=\"\n                            (customTemplatesService.mentionTemplate$ | async) ||\n                              defaultMention;\n                            context: getMentionContext(part)\n                          \"\n                        ></ng-container>\n                      </ng-template>\n                    </ng-container>\n                  </ng-container>\n                  <ng-template #defaultContent>\n                    <ng-container *ngIf=\"displayAs === 'text'; else asHTML\">\n                      {{ messageText || \"\" }}\n                    </ng-container>\n                    <ng-template #asHTML\n                      ><span\n                        data-testid=\"html-content\"\n                        [innerHTML]=\"messageText\"\n                      ></span\n                    ></ng-template>\n                  </ng-template>\n                </p>\n              </div>\n            </div>\n          </div>\n          <stream-icon-placeholder\n            *ngIf=\"themeVersion === '2'\"\n            class=\"str-chat__message-error-icon\"\n            icon=\"error\"\n          ></stream-icon-placeholder>\n        </div>\n        <ng-container\n          *ngTemplateOutlet=\"\n            replyCountButton;\n            context: { position: 'inside-message-bubble' }\n          \"\n        ></ng-container>\n        <ng-container\n          *ngTemplateOutlet=\"\n            messageDateAndSender;\n            context: { position: 'inside-message-bubble' }\n          \"\n        ></ng-container>\n      </div>\n      <ng-container\n        *ngTemplateOutlet=\"\n          replyCountButton;\n          context: { position: 'outside-message-bubble', message: message }\n        \"\n      ></ng-container>\n\n      <ng-container\n        *ngTemplateOutlet=\"\n          messageDateAndSender;\n          context: { position: 'outside-message-bubble' }\n        \"\n      ></ng-container>\n    </ng-container>\n  </ng-container>\n</div>\n\n<ng-template #deletedMessage>\n  <div data-testid=\"message-deleted-component\">\n    <div class=\"str-chat__message--deleted-inner\" translate>\n      streamChat.This message was deleted...\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #systemMessage>\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.systemMessageTemplate$ | async) ||\n        defaultSystemMessage;\n      context: getMessageContext()\n    \"\n  ></ng-container>\n  <ng-template #defaultSystemMessage let-messageInput=\"message\">\n    <div data-testid=\"system-message\" class=\"str-chat__message--system\">\n      <div class=\"str-chat__message--system__text\">\n        <div class=\"str-chat__message--system__line\"></div>\n        <p>{{ messageInput?.text }}</p>\n        <div class=\"str-chat__message--system__line\"></div>\n      </div>\n      <div class=\"str-chat__message--system__date\">\n        {{ parsedDate }}\n      </div>\n    </div>\n  </ng-template>\n</ng-template>\n\n<ng-template #quotedMessage>\n  <div\n    *ngIf=\"message?.quoted_message\"\n    class=\"quoted-message str-chat__quoted-message-preview\"\n    data-testid=\"quoted-message-container\"\n    [class.mine]=\"isSentByCurrentUser\"\n    (click)=\"\n      jumpToMessage(\n        (message?.quoted_message)!.id,\n        message?.quoted_message?.parent_id\n      )\n    \"\n    (keyup.enter)=\"\n      jumpToMessage(\n        (message?.quoted_message)!.id,\n        message?.quoted_message?.parent_id\n      )\n    \"\n  >\n    <stream-avatar-placeholder\n      data-testid=\"qouted-message-avatar\"\n      class=\"str-chat-angular__avatar-host str-chat__message-sender-avatar\"\n      [imageUrl]=\"message?.quoted_message?.user?.image\"\n      [name]=\"\n        message?.quoted_message?.user?.name || message?.quoted_message?.user?.id\n      \"\n      [size]=\"20\"\n      type=\"user\"\n      location=\"quoted-message-sender\"\n      [user]=\"message?.quoted_message?.user || undefined\"\n    ></stream-avatar-placeholder>\n    <div class=\"quoted-message-inner str-chat__quoted-message-bubble\">\n      <ng-container\n        *ngIf=\"\n          message?.quoted_message?.attachments &&\n          message?.quoted_message?.attachments?.length\n        \"\n      >\n        <ng-template\n          #defaultAttachments\n          let-messageId=\"messageId\"\n          let-attachments=\"attachments\"\n          let-parentMessageId=\"parentMessageId\"\n          let-imageModalStateChangeHandler=\"imageModalStateChangeHandler\"\n        >\n          <stream-attachment-list\n            [messageId]=\"messageId\"\n            [attachments]=\"attachments\"\n            [parentMessageId]=\"parentMessageId\"\n            (imageModalStateChange)=\"imageModalStateChangeHandler($event)\"\n          ></stream-attachment-list>\n        </ng-template>\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.attachmentListTemplate$ | async) ||\n              defaultAttachments;\n            context: getQuotedMessageAttachmentListContext()\n          \"\n        ></ng-container>\n      </ng-container>\n      <div\n        data-testid=\"quoted-message-text\"\n        [innerHTML]=\"\n          message?.quoted_message?.translation ||\n          message?.quoted_message?.html ||\n          message?.quoted_message?.text\n        \"\n      ></div>\n    </div>\n  </div>\n</ng-template>\n\n<!-- We need these markups in slightly different positions in theme-v1 and theme-v2, this soultion makes that possible without duplicating the code -->\n<ng-template #messageDateAndSender let-position=\"position\">\n  <ng-container\n    *ngIf=\"\n      (position === 'inside-message-bubble' && themeVersion === '1') ||\n      (position === 'outside-message-bubble' && themeVersion === '2')\n    \"\n  >\n    <div\n      class=\"str-chat__translation-notice\"\n      *ngIf=\"shouldDisplayTranslationNotice\"\n      data-testid=\"translation-notice\"\n    >\n      <button\n        data-testid=\"see-original\"\n        *ngIf=\"displayedMessageTextContent === 'translation'\"\n        (click)=\"displayOriginalMessage()\"\n        (keyup.enter)=\"displayOriginalMessage()\"\n        translate\n      >\n        streamChat.See original (automatically translated)\n      </button>\n      <button\n        data-testid=\"see-translation\"\n        *ngIf=\"displayedMessageTextContent === 'original'\"\n        (click)=\"displayTranslatedMessage()\"\n        (keyup.enter)=\"displayTranslatedMessage()\"\n        translate\n      >\n        streamChat.See translation\n      </button>\n    </div>\n    <ng-container\n      *ngIf=\"customTemplatesService.customMessageMetadataTemplate$ | async\"\n    >\n      <div class=\"str-chat__custom-message-metadata\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            (customTemplatesService.customMessageMetadataTemplate$ | async)!;\n            context: getMessageMetadataContext()\n          \"\n        ></ng-container>\n      </div>\n    </ng-container>\n    <div\n      class=\"\n        str-chat__message-data\n        str-chat__message-simple-data\n        str-chat__message-metadata\n      \"\n    >\n      <ng-container *ngIf=\"themeVersion === '2'\">\n        <ng-container *ngTemplateOutlet=\"messageStatus\"></ng-container>\n      </ng-container>\n      <span\n        data-testid=\"sender\"\n        *ngIf=\"!isSentByCurrentUser\"\n        class=\"str-chat__message-simple-name str-chat__message-sender-name\"\n      >\n        {{ message?.user?.name ? message?.user?.name : message?.user?.id }}\n      </span>\n      <span\n        data-testid=\"date\"\n        class=\"str-chat__message-simple-timestamp str-chat__message-simple-time\"\n      >\n        {{ parsedDate }}\n      </span>\n      <ng-container *ngIf=\"message?.message_text_updated_at\">\n        <span\n          data-testid=\"edited-flag\"\n          class=\"str-chat__mesage-simple-edited\"\n          translate\n          >streamChat.Edited</span\n        >\n        <div\n          data-testid=\"edited-timestamp\"\n          class=\"str-chat__message-edited-timestamp\"\n          [ngClass]=\"{\n            'str-chat__message-edited-timestamp--open': isEditedFlagOpened,\n            'str-chat__message-edited-timestamp--collapsed': !isEditedFlagOpened\n          }\"\n        >\n          <span translate>streamChat.Edited</span>\n          <time\n            dateTime=\"{{ message?.message_text_updated_at }}\"\n            title=\"{{ message?.message_text_updated_at }}\"\n          >\n            {{ pasedEditedDate }}\n          </time>\n        </div>\n      </ng-container>\n    </div>\n  </ng-container>\n</ng-template>\n\n<ng-template #messageStatus>\n  <ng-container\n    *ngIf=\"\n      isSentByCurrentUser &&\n      ((isLastSentMessage && message?.status === 'received') ||\n        message?.status === 'sending')\n    \"\n  >\n    <ng-container *ngIf=\"message?.status === 'sending'; else sentStatus\">\n      <ng-container *ngTemplateOutlet=\"sendingStatus\"></ng-container>\n    </ng-container>\n    <ng-template #sentStatus>\n      <ng-container\n        *ngIf=\"\n          mode === 'main' && isMessageDeliveredAndRead && canDisplayReadStatus;\n          else deliveredStatus\n        \"\n      >\n        <ng-container *ngTemplateOutlet=\"readStatus\"></ng-container>\n      </ng-container>\n    </ng-template>\n    <ng-template #deliveredStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.deliveredStatusTemplate$ | async) ||\n            defaultDeliveredStatus;\n          context: getDeliveredStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultDeliveredStatus>\n      <span\n        *ngIf=\"mode === 'main'\"\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"delivered-indicator\"\n        tabindex=\"0\"\n        [popper]=\"popperContent\"\n        [popperTrigger]=\"popperTriggerHover\"\n        [popperPlacement]=\"popperPlacementTop\"\n        [popperHideOnScroll]=\"false\"\n        [popperHideOnClickOutside]=\"false\"\n        (hover)=\"$event.stopPropagation()\"\n      >\n        <popper-content #popperContent>\n          <div class=\"str-chat__tooltip str-chat__tooltip-angular\">\n            {{ \"streamChat.Delivered\" | translate }}\n          </div>\n        </popper-content>\n        <stream-icon-placeholder\n          data-testid=\"delivered-icon\"\n          icon=\"delivered-icon\"\n        ></stream-icon-placeholder>\n      </span>\n    </ng-template>\n    <ng-template #sendingStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.sendingStatusTemplate$ | async) ||\n            defaultSendingStatus;\n          context: getSendingStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultSendingStatus>\n      <span\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"sending-indicator\"\n        tabindex=\"0\"\n        [popper]=\"popperContent\"\n        [popperTrigger]=\"popperTriggerHover\"\n        [popperPlacement]=\"popperPlacementTop\"\n        [popperHideOnScroll]=\"false\"\n        [popperHideOnClickOutside]=\"false\"\n        (hover)=\"$event.stopPropagation()\"\n      >\n        <popper-content #popperContent>\n          <div class=\"str-chat__tooltip str-chat__tooltip-angular\">\n            {{ \"streamChat.Sending...\" | translate }}\n          </div>\n        </popper-content>\n        <stream-loading-indicator-placeholder\n          data-testid=\"loading-indicator\"\n        ></stream-loading-indicator-placeholder>\n      </span>\n    </ng-template>\n    <ng-template #readStatus>\n      <ng-container\n        *ngTemplateOutlet=\"\n          (customTemplatesService.readStatusTemplate$ | async) ||\n            defaultReadStatus;\n          context: getReadStatusContext()\n        \"\n      ></ng-container>\n    </ng-template>\n    <ng-template #defaultReadStatus let-readByText=\"readByText\">\n      <span\n        class=\"\n          str-chat__message-simple-status\n          str-chat__message-simple-status-angular\n          str-chat__message-status\n        \"\n        data-testid=\"read-indicator\"\n        tabindex=\"0\"\n        [popper]=\"popperContent\"\n        [popperTrigger]=\"popperTriggerHover\"\n        [popperPlacement]=\"popperPlacementTop\"\n        [popperHideOnScroll]=\"false\"\n        [popperHideOnClickOutside]=\"false\"\n        (hover)=\"$event.stopPropagation()\"\n      >\n        <popper-content #popperContent>\n          <div\n            class=\"str-chat__tooltip str-chat__tooltip-angular\"\n            data-testid=\"read-by-tooltip\"\n          >\n            {{ readByText }}\n          </div>\n        </popper-content>\n        <stream-icon-placeholder icon=\"read-icon\"></stream-icon-placeholder>\n      </span>\n    </ng-template>\n  </ng-container>\n</ng-template>\n\n<ng-template #replyCountButton let-position=\"position\">\n  <div\n    *ngIf=\"\n      (position === 'inside-message-bubble' && themeVersion === '1') ||\n      (position === 'outside-message-bubble' && themeVersion === '2')\n    \"\n    class=\"\n      str-chat__message-simple-reply-button\n      str-chat__message-replies-count-button-wrapper\n    \"\n  >\n    <button\n      *ngIf=\"shouldDisplayThreadLink\"\n      class=\"str-chat__message-replies-count-button\"\n      data-testid=\"reply-count-button\"\n      (click)=\"setAsActiveParentMessage()\"\n    >\n      <stream-icon-placeholder\n        *ngIf=\"themeVersion === '1'\"\n        stream-icon-placeholder\n        icon=\"reply\"\n      ></stream-icon-placeholder>\n      {{message?.reply_count === 1 ? ('streamChat.1 reply' | translate) : ('streamChat.{{ replyCount }}\n      replies' | translate:replyCountParam)}}\n    </button>\n  </div>\n</ng-template>\n\n<ng-template #attachmentsTemplate>\n  <ng-template\n    #defaultAttachments\n    let-messageId=\"messageId\"\n    let-attachments=\"attachments\"\n    let-parentMessageId=\"parentMessageId\"\n    let-imageModalStateChangeHandler=\"imageModalStateChangeHandler\"\n  >\n    <stream-attachment-list\n      [messageId]=\"messageId\"\n      [attachments]=\"attachments\"\n      [parentMessageId]=\"parentMessageId\"\n      (imageModalStateChange)=\"imageModalStateChangeHandler($event)\"\n    ></stream-attachment-list>\n  </ng-template>\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.attachmentListTemplate$ | async) ||\n        defaultAttachments;\n      context: getAttachmentListContext()\n    \"\n  ></ng-container>\n</ng-template>\n", components: [{ type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "size", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }, { type: i9__namespace$1.NgxPopperjsContentComponent, selector: "popper-content", exportAs: ["ngxPopperjsContent"] }, { type: MessageActionsBoxComponent, selector: "stream-message-actions-box", inputs: ["isOpen", "isMine", "message", "enabledActions", "customActions"], outputs: ["displayedActionsCount", "isEditing"] }, { type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }, { type: MessageReactionsComponent, selector: "stream-message-reactions", inputs: ["messageId", "messageReactionCounts", "isSelectorOpen", "latestReactions", "ownReactions"], outputs: ["isSelectorOpenChange"] }, { type: AttachmentListComponent, selector: "stream-attachment-list", inputs: ["messageId", "parentMessageId", "attachments"], outputs: ["imageModalStateChange"] }, { type: LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder", inputs: ["size", "color"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i9__namespace$1.NgxPopperjsDirective, selector: "[popper]", inputs: ["popperTimeout", "popperTimeoutAfterShow", "popperApplyClass", "popper", "popperDisabled", "popperPlacement", "popperApplyArrowClass", "popperPreventOverflow", "popperHideOnClickOutside", "popperTrigger", "popperStyles", "popperAriaDescribeBy", "popperAriaRole", "popperBoundaries", "popperCloseOnClickOutside", "popperDisableAnimation", "popperDisableStyle", "popperHideOnMouseLeave", "popperHideOnScroll", "popperAppendTo", "popperModifiers", "popperPositionFixed", "popperDelay", "popperShowOnStart", "popperTarget"], outputs: ["popperOnHidden", "popperOnShown", "popperOnUpdate"], exportAs: ["popper"] }, { type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i9__namespace.TranslateDirective, selector: "[translate],[ngx-translate]", inputs: ["translate", "translateParams"] }, { type: i8__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i8__namespace.AsyncPipe, "translate": i9__namespace.TranslatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-message',
                        templateUrl: './message.component.html',
                        styles: [],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: ChatClientService }, { type: ChannelService }, { type: CustomTemplatesService }, { type: i0__namespace.ChangeDetectorRef }, { type: ThemeService }, { type: DateParserService }, { type: i0__namespace.NgZone }, { type: MessageService }, { type: MessageActionsService }]; }, propDecorators: { message: [{
                    type: i0.Input
                }], enabledMessageActions: [{
                    type: i0.Input
                }], isLastSentMessage: [{
                    type: i0.Input
                }], mode: [{
                    type: i0.Input
                }], isHighlighted: [{
                    type: i0.Input
                }], customActions: [{
                    type: i0.Input
                }], container: [{
                    type: i0.ViewChild,
                    args: ['container']
                }] } });

    /**
     * The `Textarea` component is used by the [`MessageInput`](./MessageInputComponent.mdx) component to display the input HTML element where users can type their message.
     */
    var TextareaComponent = /** @class */ (function () {
        function TextareaComponent(emojiInputService, themeService) {
            var _this = this;
            this.emojiInputService = emojiInputService;
            this.themeService = themeService;
            this.class = 'str-chat__textarea str-chat__message-textarea-angular-host';
            /**
             * The value of the input HTML element.
             */
            this.value = '';
            /**
             * Placeholder of the textarea
             */
            this.placeholder = '';
            /**
             * Enables or disables auto focus on the textarea element
             */
            this.autoFocus = true;
            /**
             * Emits the current value of the input element when a user types.
             */
            this.valueChange = new i0.EventEmitter();
            /**
             * Emits when a user triggers a message send event (this happens when they hit the `Enter` key).
             */
            this.send = new i0.EventEmitter();
            this.subscriptions = [];
            this.subscriptions.push(this.emojiInputService.emojiInput$.subscribe(function (emoji) {
                _this.messageInput.nativeElement.focus();
                var selectionStart = _this.messageInput.nativeElement.selectionStart;
                _this.messageInput.nativeElement.setRangeText(emoji);
                _this.messageInput.nativeElement.selectionStart =
                    selectionStart + emoji.length;
                _this.messageInput.nativeElement.selectionEnd =
                    selectionStart + emoji.length;
                _this.inputChanged();
            }));
        }
        TextareaComponent.prototype.ngOnChanges = function (changes) {
            if (changes.value && !this.value && this.messageInput) {
                this.messageInput.nativeElement.style.height = 'auto';
            }
        };
        TextareaComponent.prototype.ngAfterViewInit = function () {
            if (this.messageInput.nativeElement.scrollHeight > 0) {
                this.adjustTextareaHeight();
            }
        };
        TextareaComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        TextareaComponent.prototype.inputChanged = function () {
            this.valueChange.emit(this.messageInput.nativeElement.value);
            this.adjustTextareaHeight();
        };
        TextareaComponent.prototype.enterHit = function (event) {
            if (this.inputMode === 'desktop') {
                event.preventDefault();
                this.send.next();
            }
        };
        TextareaComponent.prototype.adjustTextareaHeight = function () {
            if (this.themeService.themeVersion === '2') {
                this.messageInput.nativeElement.style.height = '';
                this.messageInput.nativeElement.style.height = this.messageInput.nativeElement.scrollHeight + "px";
            }
        };
        return TextareaComponent;
    }());
    TextareaComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TextareaComponent, deps: [{ token: EmojiInputService }, { token: ThemeService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TextareaComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: TextareaComponent, selector: "stream-textarea", inputs: { value: "value", placeholder: "placeholder", inputMode: "inputMode", autoFocus: "autoFocus" }, outputs: { valueChange: "valueChange", send: "send" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "messageInput", first: true, predicate: ["input"], descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<textarea\n  [value]=\"value || ''\"\n  [autofocus]=\"autoFocus\"\n  data-testid=\"textarea\"\n  #input\n  placeholder=\"{{ placeholder | translate }}\"\n  class=\"\n    rta__textarea\n    str-chat__textarea__textarea\n    str-chat__angular-textarea\n    str-chat__message-textarea\n  \"\n  rows=\"1\"\n  (input)=\"inputChanged()\"\n  (keydown.enter)=\"enterHit($event)\"\n></textarea>\n", pipes: { "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TextareaComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-textarea',
                        templateUrl: './textarea.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: EmojiInputService }, { type: ThemeService }]; }, propDecorators: { class: [{
                    type: i0.HostBinding
                }], value: [{
                    type: i0.Input
                }], placeholder: [{
                    type: i0.Input
                }], inputMode: [{
                    type: i0.Input
                }], autoFocus: [{
                    type: i0.Input
                }], valueChange: [{
                    type: i0.Output
                }], send: [{
                    type: i0.Output
                }], messageInput: [{
                    type: i0.ViewChild,
                    args: ['input']
                }] } });

    /**
     * The `TransliterationService` wraps the [@sindresorhus/transliterate](https://www.npmjs.com/package/@sindresorhus/transliterate) library
     */
    var TransliterationService = /** @class */ (function () {
        function TransliterationService() {
        }
        /**
         *
         * @param s the string to be transliterated
         * @returns the result of the transliteration
         */
        TransliterationService.prototype.transliterate = function (s) {
            return transliterate__default['default'](s);
        };
        return TransliterationService;
    }());
    TransliterationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TransliterationService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TransliterationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TransliterationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: TransliterationService, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }], ctorParameters: function () { return []; } });

    /**
     * The `AutocompleteTextarea` component is used by the [`MessageInput`](./MessageInputComponent.mdx) component to display the input HTML element where users can type their message.
     */
    var AutocompleteTextareaComponent = /** @class */ (function () {
        function AutocompleteTextareaComponent(channelService, chatClientService, transliterationService, emojiInputService, customTemplatesService, themeService, cdRef) {
            var _this = this;
            this.channelService = channelService;
            this.chatClientService = chatClientService;
            this.transliterationService = transliterationService;
            this.emojiInputService = emojiInputService;
            this.customTemplatesService = customTemplatesService;
            this.themeService = themeService;
            this.cdRef = cdRef;
            this.class = 'str-chat__textarea str-chat__message-textarea-angular-host';
            /**
             * The value of the input HTML element.
             */
            this.value = '';
            /**
             * Placeholder of the textarea
             */
            this.placeholder = '';
            /**
             * If true, users can mention other users in messages. You can also set this input on the [`MessageInput`](./MessageInputComponent.mdx/#inputs-and-outputs) component.
             */
            this.areMentionsEnabled = true;
            /**
             * The scope for user mentions, either members of the current channel of members of the application. You can also set this input on the [`MessageInput`](./MessageInputComponent.mdx/#inputs-and-outputs) component.
             */
            this.mentionScope = 'channel';
            /**
             * Enables or disables auto focus on the textarea element
             */
            this.autoFocus = true;
            /**
             * Emits the current value of the input element when a user types.
             */
            this.valueChange = new i0.EventEmitter();
            /**
             * Emits when a user triggers a message send event (this happens when they hit the `Enter` key).
             */
            this.send = new i0.EventEmitter();
            /**
             * Emits the array of users that are mentioned in the message, it is updated when a user mentions a new user or deletes a mention.
             */
            this.userMentions = new i0.EventEmitter();
            this.autocompleteKey = 'autocompleteLabel';
            this.mentionTriggerChar = '@';
            this.commandTriggerChar = '/';
            this.autocompleteConfig = {
                mentions: [],
            };
            this.subscriptions = [];
            this.mentionedUsers = [];
            this.userMentionConfig = {
                triggerChar: this.mentionTriggerChar,
                dropUp: true,
                labelKey: this.autocompleteKey,
                returnTrigger: true,
                mentionFilter: function (searchString, items) { return _this.filter(searchString, items); },
                mentionSelect: function (item, triggerChar) { return _this.itemSelectedFromAutocompleteList(item, triggerChar); },
            };
            this.slashCommandConfig = {
                triggerChar: this.commandTriggerChar,
                dropUp: true,
                labelKey: 'name',
                returnTrigger: true,
                mentionFilter: function (searchString, items) { return _this.filter(searchString, items); },
                mentionSelect: function (item, triggerChar) { return _this.itemSelectedFromAutocompleteList(item, triggerChar); },
            };
            this.searchTerm$ = new rxjs.BehaviorSubject('');
            this.searchTerm$.pipe(operators.debounceTime(300)).subscribe(function (searchTerm) {
                if (searchTerm.startsWith(_this.mentionTriggerChar)) {
                    void _this.updateMentionOptions(searchTerm);
                }
            });
            this.subscriptions.push(this.channelService.activeChannel$.subscribe(function (channel) {
                var _a;
                var commands = ((_a = channel === null || channel === void 0 ? void 0 : channel.getConfig()) === null || _a === void 0 ? void 0 : _a.commands) || [];
                _this.slashCommandConfig.items = commands.map(function (c) {
                    var _b;
                    return (Object.assign(Object.assign({}, c), (_b = {}, _b[_this.autocompleteKey] = c.name, _b.type = 'command', _b)));
                });
                _this.mentionedUsers = [];
                _this.userMentions.next(__spreadArray([], __read(_this.mentionedUsers)));
                void _this.updateMentionOptions(_this.searchTerm$.getValue());
            }));
            this.subscriptions.push(this.emojiInputService.emojiInput$.subscribe(function (emoji) {
                _this.messageInput.nativeElement.focus();
                var selectionStart = _this.messageInput.nativeElement.selectionStart;
                _this.messageInput.nativeElement.setRangeText(emoji);
                _this.messageInput.nativeElement.selectionStart =
                    selectionStart + emoji.length;
                _this.messageInput.nativeElement.selectionEnd =
                    selectionStart + emoji.length;
                _this.inputChanged();
            }));
            this.subscriptions.push(this.customTemplatesService.mentionAutocompleteItemTemplate$.subscribe(function (template) { return (_this.mentionAutocompleteItemTemplate = template); }));
            this.subscriptions.push(this.customTemplatesService.commandAutocompleteItemTemplate$.subscribe(function (template) { return (_this.commandAutocompleteItemTemplate = template); }));
            this.autocompleteConfig.mentions = [
                this.userMentionConfig,
                this.slashCommandConfig,
            ];
            this.themeVersion = this.themeService.themeVersion;
        }
        AutocompleteTextareaComponent.prototype.ngOnChanges = function (changes) {
            if (changes.areMentionsEnabled) {
                if (this.areMentionsEnabled) {
                    this.autocompleteConfig.mentions = [
                        this.userMentionConfig,
                        this.slashCommandConfig,
                    ];
                    this.autocompleteConfig = Object.assign({}, this.autocompleteConfig);
                }
                else {
                    this.autocompleteConfig.mentions = [this.slashCommandConfig];
                    this.autocompleteConfig = Object.assign({}, this.autocompleteConfig);
                }
            }
            if (changes.mentionScope) {
                void this.updateMentionOptions(this.searchTerm$.getValue());
            }
            if (changes.value && !this.value && this.messageInput) {
                this.messageInput.nativeElement.style.height = 'auto';
                this.updateMentionedUsersFromText();
            }
        };
        AutocompleteTextareaComponent.prototype.ngAfterViewInit = function () {
            if (this.messageInput.nativeElement.scrollHeight > 0) {
                this.adjustTextareaHeight();
            }
        };
        AutocompleteTextareaComponent.prototype.filter = function (searchString, items) {
            var _this = this;
            return items.filter(function (item) { return _this.transliterate(item.autocompleteLabel.toLowerCase()).includes(_this.transliterate(searchString.toLowerCase())); });
        };
        AutocompleteTextareaComponent.prototype.itemSelectedFromAutocompleteList = function (item, triggerChar) {
            if (triggerChar === void 0) { triggerChar = ''; }
            if (triggerChar === this.mentionTriggerChar) {
                this.mentionedUsers.push((item.user ? item.user : item));
                this.userMentions.next(__spreadArray([], __read(this.mentionedUsers)));
            }
            return (triggerChar +
                item.autocompleteLabel +
                (triggerChar === this.commandTriggerChar ? ' ' : ''));
        };
        AutocompleteTextareaComponent.prototype.autcompleteSearchTermChanged = function (searchTerm) {
            if (searchTerm === this.mentionTriggerChar) {
                void this.updateMentionOptions();
            }
            else {
                this.searchTerm$.next(searchTerm);
            }
        };
        AutocompleteTextareaComponent.prototype.inputChanged = function () {
            this.valueChange.emit(this.messageInput.nativeElement.value);
            this.adjustTextareaHeight();
        };
        AutocompleteTextareaComponent.prototype.inputLeft = function () {
            this.updateMentionedUsersFromText();
        };
        AutocompleteTextareaComponent.prototype.enterHit = function (event) {
            if (this.inputMode === 'desktop') {
                event.preventDefault();
                this.updateMentionedUsersFromText();
                this.send.next();
            }
        };
        AutocompleteTextareaComponent.prototype.adjustTextareaHeight = function () {
            if (this.themeVersion === '2') {
                this.messageInput.nativeElement.style.height = '';
                this.messageInput.nativeElement.style.height = this.messageInput.nativeElement.scrollHeight + "px";
            }
        };
        AutocompleteTextareaComponent.prototype.transliterate = function (s) {
            if (this.transliterationService) {
                return this.transliterationService.transliterate(s);
            }
            else {
                return s;
            }
        };
        AutocompleteTextareaComponent.prototype.updateMentionOptions = function (searchTerm) {
            return __awaiter(this, void 0, void 0, function () {
                var request, result, items;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.areMentionsEnabled) {
                                return [2 /*return*/];
                            }
                            searchTerm = searchTerm === null || searchTerm === void 0 ? void 0 : searchTerm.replace(this.mentionTriggerChar, '');
                            request = this.mentionScope === 'application'
                                ? function (s) { return _this.chatClientService.autocompleteUsers(s); }
                                : function (s) { return _this.channelService.autocompleteMembers(s); };
                            return [4 /*yield*/, request(searchTerm || '')];
                        case 1:
                            result = _b.sent();
                            items = this.filter(searchTerm || '', result.map(function (i) {
                                var user = (i.user ? i.user : i);
                                return Object.assign(Object.assign({}, i), { autocompleteLabel: user.name || user.id, type: 'mention' });
                            }));
                            this.userMentionConfig.items = items;
                            this.autocompleteConfig.mentions = [
                                this.userMentionConfig,
                                this.slashCommandConfig,
                            ];
                            this.autocompleteConfig = Object.assign({}, this.autocompleteConfig);
                            this.cdRef.detectChanges();
                            return [2 /*return*/];
                    }
                });
            });
        };
        AutocompleteTextareaComponent.prototype.updateMentionedUsersFromText = function () {
            var _this = this;
            var updatedMentionedUsers = [];
            this.mentionedUsers.forEach(function (u) {
                var key = u.name || u.id;
                if (_this.value.includes("" + _this.mentionTriggerChar + key)) {
                    updatedMentionedUsers.push(u);
                }
            });
            if (updatedMentionedUsers.length !== this.mentionedUsers.length) {
                this.userMentions.next(__spreadArray([], __read(updatedMentionedUsers)));
                this.mentionedUsers = updatedMentionedUsers;
            }
        };
        return AutocompleteTextareaComponent;
    }());
    AutocompleteTextareaComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AutocompleteTextareaComponent, deps: [{ token: ChannelService }, { token: ChatClientService }, { token: TransliterationService }, { token: EmojiInputService }, { token: CustomTemplatesService }, { token: ThemeService }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    AutocompleteTextareaComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: AutocompleteTextareaComponent, selector: "stream-autocomplete-textarea", inputs: { value: "value", placeholder: "placeholder", areMentionsEnabled: "areMentionsEnabled", inputMode: "inputMode", mentionScope: "mentionScope", autoFocus: "autoFocus" }, outputs: { valueChange: "valueChange", send: "send", userMentions: "userMentions" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "messageInput", first: true, predicate: ["input"], descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<textarea\n  [value]=\"value || ''\"\n  [autofocus]=\"autoFocus\"\n  data-testid=\"textarea\"\n  #input\n  placeholder=\"{{ placeholder | translate }}\"\n  class=\"\n    rta__textarea\n    str-chat__textarea__textarea\n    str-chat__angular-textarea\n    str-chat__message-textarea\n  \"\n  rows=\"1\"\n  (input)=\"inputChanged()\"\n  (keydown.enter)=\"enterHit($event)\"\n  [mentionConfig]=\"autocompleteConfig\"\n  (searchTerm)=\"autcompleteSearchTermChanged($event)\"\n  [mentionListTemplate]=\"autocompleteItem\"\n  (blur)=\"inputLeft()\"\n></textarea>\n<ng-template #autocompleteItem let-item=\"item\">\n  <div class=\"rta rta__item str-chat__emojisearch__item\" [ngSwitch]=\"item.type\">\n    <div class=\"rta__entity\" *ngSwitchCase=\"'mention'\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          mentionAutocompleteItemTemplate || defaultMentionTemplate;\n          context: { item: item }\n        \"\n      ></ng-container>\n    </div>\n    <div class=\"rta__entity\" *ngSwitchCase=\"'command'\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          commandAutocompleteItemTemplate || defaultCommandTemplate;\n          context: { item: item }\n        \"\n      ></ng-container>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #defaultCommandTemplate let-item=\"item\">\n  <div class=\"str-chat__slash-command\">\n    <span class=\"str-chat__slash-command-header\">\n      <strong\n        class=\"str-chat__slash-command-name\"\n        data-testclass=\"command-name\"\n        >{{ item.name }}</strong\n      >\n      <span class=\"str-chat__slash-command-args\"\n        >/{{ item.name }} {{ item.args }}</span\n      >\n    </span>\n    <br />\n  </div>\n</ng-template>\n\n<ng-template #defaultMentionTemplate let-item=\"item\">\n  <div class=\"str-chat__user-item\">\n    <stream-avatar-placeholder\n      data-testclass=\"avatar\"\n      class=\"str-chat__avatar str-chat__avatar--circle\"\n      [ngStyle]=\"{ height: themeVersion === '2' ? 30 : 20 + 'px' }\"\n      [size]=\"themeVersion === '2' ? 30 : 20\"\n      [imageUrl]=\"item.image || item.user?.image\"\n      [name]=\"item.autocompleteLabel\"\n      type=\"user\"\n      location=\"autocomplete-item\"\n      [user]=\"item.user || item\"\n    ></stream-avatar-placeholder>\n    <span data-testclass=\"username\" class=\"str-chat__user-item--name\">{{\n      item.autocompleteLabel\n    }}</span>\n  </div>\n</ng-template>\n", components: [{ type: AvatarPlaceholderComponent, selector: "stream-avatar-placeholder", inputs: ["name", "imageUrl", "size", "location", "channel", "user", "type", "initialsType", "showOnlineIndicator"] }], directives: [{ type: i8__namespace$1.MentionDirective, selector: "[mention], [mentionConfig]", inputs: ["mentionConfig", "mention", "mentionListTemplate"], outputs: ["searchTerm", "itemSelected", "opened", "closed"] }, { type: i8__namespace.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i8__namespace.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i8__namespace.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], pipes: { "translate": i9__namespace.TranslatePipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: AutocompleteTextareaComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-autocomplete-textarea',
                        templateUrl: './autocomplete-textarea.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: ChannelService }, { type: ChatClientService }, { type: TransliterationService }, { type: EmojiInputService }, { type: CustomTemplatesService }, { type: ThemeService }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { class: [{
                    type: i0.HostBinding
                }], value: [{
                    type: i0.Input
                }], placeholder: [{
                    type: i0.Input
                }], areMentionsEnabled: [{
                    type: i0.Input
                }], inputMode: [{
                    type: i0.Input
                }], mentionScope: [{
                    type: i0.Input
                }], autoFocus: [{
                    type: i0.Input
                }], valueChange: [{
                    type: i0.Output
                }], send: [{
                    type: i0.Output
                }], userMentions: [{
                    type: i0.Output
                }], messageInput: [{
                    type: i0.ViewChild,
                    args: ['input']
                }] } });

    var getGroupStyles = function (message, previousMessage, nextMessage, options) {
        if (options === void 0) { options = {
            noGroupByUser: false,
            lastReadMessageId: undefined,
            noGroupByReadState: false,
        }; }
        var _a, _b, _c, _d, _e, _f;
        if (options.noGroupByUser ||
            (message.attachments && message.attachments.length !== 0))
            return 'single';
        var isTopMessage = !previousMessage ||
            !isOnSameDay(previousMessage.created_at, message.created_at) ||
            previousMessage.type === 'system' ||
            (previousMessage.attachments &&
                ((_a = previousMessage.attachments) === null || _a === void 0 ? void 0 : _a.length) !== 0) ||
            ((_b = message.user) === null || _b === void 0 ? void 0 : _b.id) !== ((_c = previousMessage.user) === null || _c === void 0 ? void 0 : _c.id) ||
            previousMessage.type === 'error' ||
            previousMessage.deleted_at ||
            (previousMessage.id === options.lastReadMessageId &&
                !options.noGroupByReadState) ||
            previousMessage.message_text_updated_at ||
            (message.reaction_counts &&
                Object.keys(message.reaction_counts).length > 0);
        var isBottomMessage = !nextMessage ||
            !isOnSameDay(message.created_at, nextMessage.created_at) ||
            nextMessage.type === 'system' ||
            (nextMessage.attachments && ((_d = nextMessage.attachments) === null || _d === void 0 ? void 0 : _d.length) !== 0) ||
            ((_e = message.user) === null || _e === void 0 ? void 0 : _e.id) !== ((_f = nextMessage.user) === null || _f === void 0 ? void 0 : _f.id) ||
            nextMessage.type === 'error' ||
            nextMessage.deleted_at ||
            (message.id === options.lastReadMessageId && !options.noGroupByReadState) ||
            message.message_text_updated_at ||
            (nextMessage.reaction_counts &&
                Object.keys(nextMessage.reaction_counts).length > 0);
        if (!isTopMessage && !isBottomMessage) {
            if (message.deleted_at || message.type === 'error')
                return 'single';
            return 'middle';
        }
        if (isBottomMessage) {
            if (isTopMessage || message.deleted_at || message.type === 'error')
                return 'single';
            return 'bottom';
        }
        if (isTopMessage)
            return 'top';
        return '';
    };
    var isOnSameDay = function (date1, date2) {
        return (date1.getFullYear() === date2.getFullYear() &&
            date1.getMonth() === date2.getMonth() &&
            date1.getDate() === date2.getDate());
    };

    /**
     * The `MessageList` component renders a scrollable list of messages.
     */
    var MessageListComponent = /** @class */ (function () {
        function MessageListComponent(channelService, chatClientService, customTemplatesService, dateParser, ngZone, cdRef, messageActionsService) {
            var _this = this;
            this.channelService = channelService;
            this.chatClientService = chatClientService;
            this.customTemplatesService = customTemplatesService;
            this.dateParser = dateParser;
            this.ngZone = ngZone;
            this.cdRef = cdRef;
            this.messageActionsService = messageActionsService;
            /**
             * Determines if the message list should display channel messages or [thread messages](https://getstream.io/chat/docs/javascript/threads/?language=javascript).
             */
            this.mode = 'main';
            /**
             * The direction of the messages in the list, `bottom-to-top` means newest message is at the bottom of the message list and users scroll upwards to load older messages
             */
            this.direction = 'bottom-to-top';
            /**
             * Determines what triggers the appearance of the message options: by default you can hover (click on mobile) anywhere in the row of the message (`message-row` option), or you can set `message-bubble`, in that case only a hover (click on mobile) in the message bubble will trigger the options to appear.
             */
            this.messageOptionsTrigger = 'message-row';
            /**
             * You can hide the "jump to latest" button while scrolling. A potential use-case for this input would be to [workaround a known issue on iOS Safar webview](https://github.com/GetStream/stream-chat-angular/issues/418)
             *
             */
            this.hideJumpToLatestButtonDuringScroll = false;
            /**
             * A list of custom message actions to be displayed in the message action box
             *
             * @deprecated please use the [`MessageActionsService`](https://getstream.io/chat/docs/sdk/angular/services/MessageActionsService) to set this property.
             */
            this.customMessageActions = [];
            /**
             * If `true` date separators will be displayed
             */
            this.displayDateSeparator = true;
            /**
             * If `true` unread indicator will be displayed
             */
            this.displayUnreadSeparator = true;
            /**
             * If date separators are displayed, you can set the horizontal position of the date text.
             */
            this.dateSeparatorTextPos = 'center';
            /**
             * `last-message` option will open the message list at the last message, `last-read-message` will open the list at the last unread message. This option only works if mode is `main`.
             */
            this.openMessageListAt = 'last-message';
            /**
             * If the user has unread messages when they open the channel the UI shows the unread indicator / notification which features the unread count by default. This count will be increased every time a user receives a new message. If you don't want to show the unread count, you can turn that off.
             *
             * This is only applicable for `main` mode, as threads doesn't have read infromation.
             */
            this.hideUnreadCountForNotificationAndIndicator = false;
            /**
             * You can turn on and off the loading indicator that signals to users that more messages are being loaded to the message list
             */
            this.displayLoadingIndicator = true;
            this.emptyMainMessageListTemplate = null;
            this.emptyThreadMessageListTemplate = null;
            this.enabledMessageActions = [];
            this.isEmpty = true;
            this.newMessageCountWhileBeingScrolled = 0;
            this.groupStyles = [];
            this.isNextMessageOnSeparateDate = [];
            this.isLoading = false;
            this.isUnreadNotificationVisible = true;
            this.isJumpingToLatestUnreadMessage = false;
            this.isJumpToLatestButtonVisible = true;
            this.subscriptions = [];
            this.isLatestMessageInList = true;
            this.parsedDates = new Map();
            this.isViewInited = false;
            this.messageNotificationJumpClicked = function () {
                _this.jumpToFirstUnreadMessage();
                _this.isUnreadNotificationVisible = false;
            };
            this.messageNotificationDismissClicked = function () {
                _this.isUnreadNotificationVisible = false;
            };
            this.usersTypingInChannel$ = this.channelService.usersTypingInChannel$;
            this.usersTypingInThread$ = this.channelService.usersTypingInThread$;
        }
        Object.defineProperty(MessageListComponent.prototype, "class", {
            get: function () {
                return "str-chat-angular__main-panel-inner str-chat-angular__message-list-host str-chat__main-panel-inner " + (this.isEmpty ? 'str-chat-angular__message-list-host--empty' : '');
            },
            enumerable: false,
            configurable: true
        });
        MessageListComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriptions.push(this.channelService.activeChannel$.subscribe(function (channel) {
                var _a, _b, _c, _d, _e, _f, _g;
                (_b = (_a = _this.chatClientService.chatClient) === null || _a === void 0 ? void 0 : _a.logger) === null || _b === void 0 ? void 0 : _b.call(_a, 'info', ((channel === null || channel === void 0 ? void 0 : channel.cid) || 'undefined') + " selected", { tags: "message list " + _this.mode });
                var isNewChannel = false;
                if (_this.channelId !== (channel === null || channel === void 0 ? void 0 : channel.id)) {
                    isNewChannel = true;
                    if (_this.checkIfUnreadNotificationIsVisibleTimeout) {
                        clearTimeout(_this.checkIfUnreadNotificationIsVisibleTimeout);
                    }
                    _this.isUnreadNotificationVisible = false;
                    (_e = (_d = (_c = _this.chatClientService) === null || _c === void 0 ? void 0 : _c.chatClient) === null || _d === void 0 ? void 0 : _d.logger) === null || _e === void 0 ? void 0 : _e.call(_d, 'info', "new channel is different from prev channel, reseting scroll state", { tags: "message list " + _this.mode });
                    _this.parsedDates = new Map();
                    _this.resetScrollState();
                    _this.channelId = channel === null || channel === void 0 ? void 0 : channel.id;
                    if (_this.isViewInited) {
                        _this.cdRef.detectChanges();
                    }
                }
                if (_this.mode === 'main') {
                    var lastReadMessageId = _this.channelService.activeChannelLastReadMessageId;
                    var unreadCount = _this.channelService.activeChannelUnreadCount;
                    if (lastReadMessageId !== _this.lastReadMessageId ||
                        unreadCount !== _this.unreadCount) {
                        _this.lastReadMessageId = lastReadMessageId;
                        _this.unreadCount = unreadCount || 0;
                        if (isNewChannel && _this.lastReadMessageId) {
                            if (_this.openMessageListAt === 'last-read-message') {
                                _this.jumpToFirstUnreadMessage();
                            }
                            else {
                                // Wait till messages and the unread banner is rendered
                                // If unread banner isn't visible on the screen, we display the unread notificaion
                                setTimeout(function () {
                                    var _a, _b, _c, _d;
                                    var bannerElement = document.getElementById('stream-chat-new-message-indicator');
                                    if (!bannerElement ||
                                        (bannerElement === null || bannerElement === void 0 ? void 0 : bannerElement.offsetTop) <
                                            ((_b = (_a = _this.scrollContainer) === null || _a === void 0 ? void 0 : _a.nativeElement) === null || _b === void 0 ? void 0 : _b.scrollHeight) -
                                                ((_d = (_c = _this.scrollContainer) === null || _c === void 0 ? void 0 : _c.nativeElement) === null || _d === void 0 ? void 0 : _d.clientHeight)) {
                                        _this.isUnreadNotificationVisible = true;
                                        if (_this.isViewInited) {
                                            _this.cdRef.detectChanges();
                                        }
                                    }
                                }, 100);
                            }
                        }
                        if (_this.isViewInited) {
                            _this.cdRef.detectChanges();
                        }
                    }
                }
                else if (_this.lastReadMessageId) {
                    _this.lastReadMessageId = undefined;
                    _this.unreadCount = 0;
                    if (_this.isViewInited) {
                        _this.cdRef.detectChanges();
                    }
                }
                var capabilites = (_f = channel === null || channel === void 0 ? void 0 : channel.data) === null || _f === void 0 ? void 0 : _f.own_capabilities;
                var capabilitesString = __spreadArray([], __read((capabilites || []))).sort().join('');
                var enabledActionsString = __spreadArray([], __read((_this.enabledMessageActions || []))).sort()
                    .join('');
                if (capabilitesString !== enabledActionsString) {
                    _this.enabledMessageActions = capabilites || [];
                    if (_this.isViewInited) {
                        _this.cdRef.detectChanges();
                    }
                }
                (_g = _this.newMessageSubscription) === null || _g === void 0 ? void 0 : _g.unsubscribe();
                if (channel) {
                    _this.newMessageSubscription = channel.on('message.new', function (event) {
                        // If we display main channel messages and we're switched to an older message set -> use message.new event to update unread count and detect new messages sent by current user
                        if (!event.message ||
                            channel.state.messages === channel.state.latestMessages ||
                            _this.mode === 'thread') {
                            return;
                        }
                        _this.newMessageReceived({
                            id: event.message.id,
                            user: event.message.user,
                            created_at: new Date(event.message.created_at || ''),
                        });
                    });
                }
            }));
            this.subscriptions.push(this.messageActionsService.customActions$.subscribe(function (actions) {
                if (actions !== _this.customMessageActions) {
                    _this.customMessageActions = actions;
                    if (_this.isViewInited) {
                        _this.cdRef.detectChanges();
                    }
                }
            }));
            this.subscriptions.push(this.channelService.activeParentMessage$.subscribe(function (message) {
                if (message &&
                    _this.parentMessage &&
                    message.id !== _this.parentMessage.id &&
                    _this.mode === 'thread') {
                    _this.resetScrollState();
                }
                if (_this.parentMessage === message) {
                    return;
                }
                _this.parentMessage = message;
                if (_this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
            this.subscriptions.push(this.customTemplatesService.messageTemplate$.subscribe(function (template) {
                if (_this.messageTemplate === template) {
                    return;
                }
                _this.messageTemplate = template;
                if (_this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
            this.subscriptions.push(this.customTemplatesService.dateSeparatorTemplate$.subscribe(function (template) {
                if (_this.customDateSeparatorTemplate === template) {
                    return;
                }
                _this.customDateSeparatorTemplate = template;
                if (_this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
            this.subscriptions.push(this.customTemplatesService.newMessagesIndicatorTemplate$.subscribe(function (template) {
                if (_this.customnewMessagesIndicatorTemplate === template) {
                    return;
                }
                _this.customnewMessagesIndicatorTemplate = template;
                if (_this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
            this.subscriptions.push(this.customTemplatesService.newMessagesNotificationTemplate$.subscribe(function (template) {
                if (_this.customnewMessagesNotificationTemplate === template) {
                    return;
                }
                _this.customnewMessagesNotificationTemplate = template;
                if (_this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
            this.subscriptions.push(this.customTemplatesService.typingIndicatorTemplate$.subscribe(function (template) {
                if (_this.typingIndicatorTemplate === template) {
                    return;
                }
                _this.typingIndicatorTemplate = template;
                if (_this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
            this.subscriptions.push(this.channelService.jumpToMessage$
                .pipe(operators.filter(function (config) { return !!config.id; }))
                .subscribe(function (config) {
                var _a, _b;
                var messageId = undefined;
                if (_this.mode === 'main') {
                    messageId = config.parentId || config.id;
                }
                else if (config.parentId) {
                    messageId = config.id;
                }
                (_b = (_a = _this.chatClientService.chatClient) === null || _a === void 0 ? void 0 : _a.logger) === null || _b === void 0 ? void 0 : _b.call(_a, 'info', "Jumping to " + (messageId || ''), { tags: "message list " + _this.mode });
                if (messageId) {
                    if (messageId === 'latest') {
                        _this.scrollToLatestMessage();
                        if (_this.isViewInited) {
                            _this.cdRef.detectChanges();
                        }
                    }
                    else {
                        if (_this.isJumpingToLatestUnreadMessage) {
                            _this.scrollMessageIntoView(_this.firstUnreadMessageId || messageId);
                            _this.highlightedMessageId =
                                _this.firstUnreadMessageId || messageId;
                        }
                        else {
                            _this.scrollMessageIntoView(messageId);
                            _this.highlightedMessageId = messageId;
                        }
                    }
                }
            }));
            this.subscriptions.push(this.customTemplatesService.emptyMainMessageListPlaceholder$.subscribe(function (template) {
                var isChanged = _this.emptyMainMessageListTemplate !== template;
                _this.emptyMainMessageListTemplate = template || null;
                if (isChanged && _this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
            this.subscriptions.push(this.customTemplatesService.emptyThreadMessageListPlaceholder$.subscribe(function (template) {
                var isChanged = _this.emptyThreadMessageListTemplate !== template;
                _this.emptyThreadMessageListTemplate = template || null;
                if (isChanged && _this.isViewInited) {
                    _this.cdRef.detectChanges();
                }
            }));
            this.setMessages$();
        };
        MessageListComponent.prototype.ngOnChanges = function (changes) {
            var _a;
            if (changes.mode || changes.direction) {
                this.setMessages$();
            }
            if (changes.direction) {
                if ((_a = this.scrollContainer) === null || _a === void 0 ? void 0 : _a.nativeElement) {
                    this.jumpToLatestMessage();
                }
            }
            if (changes.customMessageActions) {
                this.messageActionsService.customActions$.next(this.customMessageActions);
            }
        };
        MessageListComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.isViewInited = true;
            this.ngZone.runOutsideAngular(function () {
                _this.scrollContainer.nativeElement.addEventListener('scroll', function () { return _this.scrolled(); });
            });
        };
        MessageListComponent.prototype.ngAfterViewChecked = function () {
            var _a, _b, _c, _d, _e, _f;
            if (this.highlightedMessageId) {
                // Turn off programatic scroll adjustments while jump to message is in progress
                this.hasNewMessages = false;
                this.olderMassagesLoaded = false;
            }
            if (this.direction === 'top-to-bottom') {
                if (this.hasNewMessages &&
                    (this.isNewMessageSentByUser || !this.isUserScrolled)) {
                    this.isLatestMessageInList
                        ? this.scrollToTop()
                        : this.jumpToLatestMessage();
                    this.hasNewMessages = false;
                    this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
                }
            }
            else {
                if (this.hasNewMessages) {
                    if (!this.isUserScrolled || this.isNewMessageSentByUser) {
                        (_b = (_a = this.chatClientService.chatClient) === null || _a === void 0 ? void 0 : _a.logger) === null || _b === void 0 ? void 0 : _b.call(_a, 'info', "User has new messages, and not scrolled or sent new messages, therefore we " + (this.isLatestMessageInList ? 'scroll' : 'jump') + " to latest message", { tags: "message list " + this.mode });
                        this.isLatestMessageInList
                            ? this.scrollToBottom()
                            : this.jumpToLatestMessage();
                    }
                    this.hasNewMessages = false;
                    this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
                }
                else if (this.olderMassagesLoaded) {
                    (_d = (_c = this.chatClientService.chatClient) === null || _c === void 0 ? void 0 : _c.logger) === null || _d === void 0 ? void 0 : _d.call(_c, 'info', "Older messages are loaded, we preserve the scroll position", { tags: "message list " + this.mode });
                    this.preserveScrollbarPosition();
                    this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
                    this.olderMassagesLoaded = false;
                }
                else if (this.getScrollPosition() !== 'bottom' &&
                    !this.isUserScrolled &&
                    !this.highlightedMessageId) {
                    (_f = (_e = this.chatClientService.chatClient) === null || _e === void 0 ? void 0 : _e.logger) === null || _f === void 0 ? void 0 : _f.call(_e, 'info', "Container grew and user didn't scroll therefore we " + (this.isLatestMessageInList ? 'scroll' : 'jump') + " to latest message", { tags: "message list " + this.mode });
                    this.isLatestMessageInList
                        ? this.scrollToBottom()
                        : this.jumpToLatestMessage();
                    this.containerHeight = this.scrollContainer.nativeElement.scrollHeight;
                }
            }
        };
        MessageListComponent.prototype.ngOnDestroy = function () {
            var _a;
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
            (_a = this.newMessageSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            if (this.scrollEndTimeout) {
                clearTimeout(this.scrollEndTimeout);
            }
            if (this.checkIfUnreadNotificationIsVisibleTimeout) {
                clearTimeout(this.checkIfUnreadNotificationIsVisibleTimeout);
            }
            if (this.jumpToLatestButtonVisibilityTimeout) {
                clearTimeout(this.jumpToLatestButtonVisibilityTimeout);
            }
        };
        MessageListComponent.prototype.trackByMessageId = function (index, item) {
            return item.id;
        };
        MessageListComponent.prototype.trackByUserId = function (index, user) {
            return user.id;
        };
        MessageListComponent.prototype.jumpToLatestMessage = function () {
            var _a;
            void this.channelService.jumpToMessage('latest', this.mode === 'thread' ? (_a = this.parentMessage) === null || _a === void 0 ? void 0 : _a.id : undefined);
        };
        MessageListComponent.prototype.scrollToBottom = function () {
            this.scrollContainer.nativeElement.scrollTop =
                this.scrollContainer.nativeElement.scrollHeight + 0.1;
            this.forceRepaint();
        };
        MessageListComponent.prototype.scrollToTop = function () {
            this.scrollContainer.nativeElement.scrollTop = 0;
        };
        MessageListComponent.prototype.scrolled = function () {
            var _this = this;
            var _a, _b;
            if (this.scrollContainer.nativeElement.scrollHeight ===
                this.scrollContainer.nativeElement.clientHeight) {
                return;
            }
            var scrollPosition = this.getScrollPosition();
            (_b = (_a = this.chatClientService.chatClient) === null || _a === void 0 ? void 0 : _a.logger) === null || _b === void 0 ? void 0 : _b.call(_a, 'info', "Scrolled - scroll position: " + scrollPosition + ", container height: " + this.scrollContainer.nativeElement.scrollHeight, { tags: "message list " + this.mode });
            var isUserScrolled = (this.direction === 'bottom-to-top'
                ? scrollPosition !== 'bottom'
                : scrollPosition !== 'top') || !this.isLatestMessageInList;
            if (this.isUserScrolled !== isUserScrolled) {
                this.ngZone.run(function () {
                    _this.isUserScrolled = isUserScrolled;
                    if (!_this.isUserScrolled) {
                        _this.newMessageCountWhileBeingScrolled = 0;
                    }
                    _this.cdRef.detectChanges();
                });
            }
            if (this.hideJumpToLatestButtonDuringScroll) {
                if (this.isJumpToLatestButtonVisible) {
                    this.isJumpToLatestButtonVisible = false;
                    this.cdRef.detectChanges();
                }
                if (this.jumpToLatestButtonVisibilityTimeout) {
                    clearTimeout(this.jumpToLatestButtonVisibilityTimeout);
                }
                this.jumpToLatestButtonVisibilityTimeout = setTimeout(function () {
                    if (_this.isUserScrolled) {
                        _this.isJumpToLatestButtonVisible = true;
                        _this.jumpToLatestButtonVisibilityTimeout = undefined;
                        _this.cdRef.detectChanges();
                    }
                }, 100);
            }
            if (this.shouldLoadMoreMessages(scrollPosition)) {
                this.ngZone.run(function () {
                    var _a, _b;
                    _this.containerHeight = _this.scrollContainer.nativeElement.scrollHeight;
                    var direction;
                    if (_this.direction === 'top-to-bottom') {
                        direction = scrollPosition === 'top' ? 'newer' : 'older';
                    }
                    else {
                        direction = scrollPosition === 'top' ? 'older' : 'newer';
                    }
                    var result = _this.mode === 'main'
                        ? _this.channelService.loadMoreMessages(direction)
                        : _this.channelService.loadMoreThreadReplies(direction);
                    if (result) {
                        (_b = (_a = _this.chatClientService.chatClient) === null || _a === void 0 ? void 0 : _a.logger) === null || _b === void 0 ? void 0 : _b.call(_a, 'info', "Displaying loading indicator", { tags: "message list " + _this.mode });
                        _this.isLoading = true;
                    }
                    _this.cdRef.detectChanges();
                });
            }
            this.prevScrollTop = this.scrollContainer.nativeElement.scrollTop;
        };
        MessageListComponent.prototype.jumpToFirstUnreadMessage = function () {
            if (!this.lastReadMessageId) {
                return;
            }
            this.isJumpingToLatestUnreadMessage = true;
            void this.channelService.jumpToMessage(this.lastReadMessageId);
        };
        MessageListComponent.prototype.getTypingIndicatorContext = function () {
            return {
                usersTyping$: this.usersTyping$,
            };
        };
        MessageListComponent.prototype.getTypingIndicatorText = function (users) {
            var text = listUsers(users);
            return text;
        };
        MessageListComponent.prototype.isSentByCurrentUser = function (message) {
            var _a, _b;
            if (!message) {
                return false;
            }
            return ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) === ((_b = this.chatClientService.chatClient.user) === null || _b === void 0 ? void 0 : _b.id);
        };
        MessageListComponent.prototype.parseDate = function (date) {
            if (this.parsedDates.has(date)) {
                return this.parsedDates.get(date);
            }
            var parsedDate = this.dateParser.parseDate(date);
            this.parsedDates.set(date, parsedDate);
            return parsedDate;
        };
        Object.defineProperty(MessageListComponent.prototype, "replyCountParam", {
            get: function () {
                var _a;
                return { replyCount: (_a = this.parentMessage) === null || _a === void 0 ? void 0 : _a.reply_count };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MessageListComponent.prototype, "emptyListTemplate", {
            get: function () {
                return this.mode === 'main'
                    ? this.emptyMainMessageListTemplate
                    : this.emptyThreadMessageListTemplate;
            },
            enumerable: false,
            configurable: true
        });
        MessageListComponent.prototype.preserveScrollbarPosition = function () {
            this.scrollContainer.nativeElement.scrollTop =
                (this.prevScrollTop || 0) +
                    (this.scrollContainer.nativeElement.scrollHeight - this.containerHeight);
        };
        MessageListComponent.prototype.forceRepaint = function () {
            // Solves the issue of empty screen on Safari when scrolling
            this.scrollContainer.nativeElement.style.display = 'none';
            this.scrollContainer.nativeElement.offsetHeight; // no need to store this anywhere, the reference is enough
            this.scrollContainer.nativeElement.style.display = '';
        };
        MessageListComponent.prototype.getScrollPosition = function () {
            var _a, _b;
            var position = 'middle';
            if (Math.floor(this.scrollContainer.nativeElement.scrollTop) <=
                (((_a = this.parentMessageElement) === null || _a === void 0 ? void 0 : _a.nativeElement.clientHeight) || 0) &&
                (this.prevScrollTop === undefined ||
                    this.prevScrollTop >
                        (((_b = this.parentMessageElement) === null || _b === void 0 ? void 0 : _b.nativeElement.clientHeight) || 0))) {
                position = 'top';
            }
            else if (Math.ceil(this.scrollContainer.nativeElement.scrollTop) +
                this.scrollContainer.nativeElement.clientHeight >=
                this.scrollContainer.nativeElement.scrollHeight) {
                position = 'bottom';
            }
            return position;
        };
        MessageListComponent.prototype.shouldLoadMoreMessages = function (scrollPosition) {
            return scrollPosition !== 'middle' && !this.highlightedMessageId;
        };
        MessageListComponent.prototype.setMessages$ = function () {
            var _this = this;
            this.messages$ = (this.mode === 'main'
                ? this.channelService.activeChannelMessages$
                : this.channelService.activeThreadMessages$).pipe(operators.tap(function (messages) {
                var _a, _b, _c, _d;
                _this.isLoading = false;
                if (messages.length === 0) {
                    (_b = (_a = _this.chatClientService.chatClient) === null || _a === void 0 ? void 0 : _a.logger) === null || _b === void 0 ? void 0 : _b.call(_a, 'info', "Empty messages array, reseting scroll state", {
                        tags: "message list " + _this.mode,
                    });
                    _this.resetScrollState();
                    return;
                }
                if (_this.isEmpty) {
                    // cdRef.detectChanges() isn't enough here, test will fail
                    setTimeout(function () { return (_this.isEmpty = false); }, 0);
                }
                (_d = (_c = _this.chatClientService.chatClient) === null || _c === void 0 ? void 0 : _c.logger) === null || _d === void 0 ? void 0 : _d.call(_c, 'info', "Received one or more messages", {
                    tags: "message list " + _this.mode,
                });
                var currentLatestMessageInState = messages[messages.length - 1];
                _this.newMessageReceived(currentLatestMessageInState);
                var currentOldestMessage = messages[0];
                if (!_this.oldestMessage ||
                    !messages.find(function (m) { return m.id === _this.oldestMessage.id; })) {
                    _this.oldestMessage = currentOldestMessage;
                }
                else if (_this.oldestMessage.created_at.getTime() >
                    currentOldestMessage.created_at.getTime()) {
                    _this.oldestMessage = currentOldestMessage;
                    _this.olderMassagesLoaded = true;
                }
            }), operators.tap(function (messages) {
                var _a;
                if (_this.isJumpingToLatestUnreadMessage &&
                    !_this.firstUnreadMessageId &&
                    _this.lastReadMessageId) {
                    var lastReadIndex = messages.findIndex(function (m) { return m.id === _this.lastReadMessageId; });
                    _this.firstUnreadMessageId =
                        ((_a = messages[lastReadIndex + 1]) === null || _a === void 0 ? void 0 : _a.id) || _this.lastReadMessageId;
                }
            }), operators.tap(function (messages) {
                var _a;
                return (_this.lastSentMessageId = (_a = __spreadArray([], __read(messages)).reverse()
                    .find(function (m) {
                    var _a, _b, _c;
                    return ((_a = m.user) === null || _a === void 0 ? void 0 : _a.id) === ((_c = (_b = _this.chatClientService.chatClient) === null || _b === void 0 ? void 0 : _b.user) === null || _c === void 0 ? void 0 : _c.id) &&
                        m.status !== 'sending';
                })) === null || _a === void 0 ? void 0 : _a.id);
            }), operators.tap(function (messages) {
                _this.isLatestMessageInList =
                    !_this.latestMessage ||
                        messages.length === 0 ||
                        messages[messages.length - 1].id === _this.latestMessage.id ||
                        _this.mode === 'thread';
                if (!_this.isLatestMessageInList) {
                    _this.isUserScrolled = true;
                }
            }), operators.map(function (messages) { return _this.direction === 'bottom-to-top' ? messages : __spreadArray([], __read(messages)).reverse(); }), operators.tap(function (messages) {
                _this.groupStyles = messages.map(function (m, i) { return getGroupStyles(m, messages[i - 1], messages[i + 1], {
                    lastReadMessageId: _this.lastReadMessageId,
                }); });
                _this.isNextMessageOnSeparateDate = messages.map(function (m, i) { return _this.checkIfOnSeparateDates(m, messages[i + 1]); });
            }));
        };
        MessageListComponent.prototype.resetScrollState = function () {
            this.isEmpty = true;
            this.latestMessage = undefined;
            this.hasNewMessages = true;
            this.isUserScrolled = false;
            this.containerHeight = undefined;
            this.olderMassagesLoaded = false;
            this.oldestMessage = undefined;
            this.newMessageCountWhileBeingScrolled = 0;
            this.prevScrollTop = undefined;
            this.isNewMessageSentByUser = undefined;
            this.isLatestMessageInList = true;
        };
        Object.defineProperty(MessageListComponent.prototype, "usersTyping$", {
            get: function () {
                return this.mode === 'thread'
                    ? this.usersTypingInThread$
                    : this.usersTypingInChannel$;
            },
            enumerable: false,
            configurable: true
        });
        MessageListComponent.prototype.scrollMessageIntoView = function (messageId, withRetry) {
            var _this = this;
            if (withRetry === void 0) { withRetry = true; }
            var element = document.getElementById(messageId);
            if (!element && withRetry) {
                // If the message was newly inserted into activeChannelMessages$, the message will be rendered after the current change detection cycle -> wait for this cycle to complete
                setTimeout(function () { return _this.scrollMessageIntoView(messageId, false); });
            }
            else if (element) {
                element.scrollIntoView({
                    block: 'center',
                });
                setTimeout(function () {
                    _this.highlightedMessageId = undefined;
                    _this.firstUnreadMessageId = undefined;
                    _this.isJumpingToLatestUnreadMessage = false;
                    _this.cdRef.detectChanges();
                }, 1000);
            }
        };
        MessageListComponent.prototype.scrollToLatestMessage = function (withRetry) {
            var _this = this;
            if (withRetry === void 0) { withRetry = true; }
            if (document.getElementById(this.latestMessage.id)) {
                this.direction === 'bottom-to-top'
                    ? this.scrollToBottom()
                    : this.scrollToTop();
            }
            else if (withRetry) {
                // If the message was newly inserted into activeChannelMessages$, the message will be rendered after the current change detection cycle -> wait for this cycle to complete
                setTimeout(function () { return _this.scrollToLatestMessage(false); }, 0);
            }
        };
        MessageListComponent.prototype.newMessageReceived = function (message) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            var latestMessages = (_b = (_a = this.channelService.activeChannel) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.latestMessages;
            if (!this.latestMessage ||
                ((_c = this.latestMessage.created_at) === null || _c === void 0 ? void 0 : _c.getTime()) < message.created_at.getTime() ||
                (this.mode === 'main' &&
                    latestMessages &&
                    this.latestMessage &&
                    ((_d = latestMessages[latestMessages.length - 1]) === null || _d === void 0 ? void 0 : _d.id) !== this.latestMessage.id)) {
                (_f = (_e = this.chatClientService.chatClient) === null || _e === void 0 ? void 0 : _e.logger) === null || _f === void 0 ? void 0 : _f.call(_e, 'info', "Received new message", { tags: "message list " + this.mode });
                var isNewChannel = !this.latestMessage;
                this.latestMessage = message;
                this.hasNewMessages = true;
                this.isNewMessageSentByUser =
                    ((_g = message.user) === null || _g === void 0 ? void 0 : _g.id) === ((_j = (_h = this.chatClientService.chatClient) === null || _h === void 0 ? void 0 : _h.user) === null || _j === void 0 ? void 0 : _j.id);
                if (this.isUserScrolled) {
                    this.newMessageCountWhileBeingScrolled++;
                }
                if (!this.isNewMessageSentByUser &&
                    this.unreadCount !== undefined &&
                    !isNewChannel) {
                    this.unreadCount++;
                }
                this.cdRef.detectChanges();
            }
        };
        MessageListComponent.prototype.checkIfOnSeparateDates = function (message, nextMessage) {
            if (!message || !nextMessage) {
                return false;
            }
            return isOnSeparateDate(message.created_at, nextMessage.created_at);
        };
        return MessageListComponent;
    }());
    MessageListComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageListComponent, deps: [{ token: ChannelService }, { token: ChatClientService }, { token: CustomTemplatesService }, { token: DateParserService }, { token: i0__namespace.NgZone }, { token: i0__namespace.ChangeDetectorRef }, { token: MessageActionsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    MessageListComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: MessageListComponent, selector: "stream-message-list", inputs: { mode: "mode", direction: "direction", messageOptionsTrigger: "messageOptionsTrigger", hideJumpToLatestButtonDuringScroll: "hideJumpToLatestButtonDuringScroll", customMessageActions: "customMessageActions", displayDateSeparator: "displayDateSeparator", displayUnreadSeparator: "displayUnreadSeparator", dateSeparatorTextPos: "dateSeparatorTextPos", openMessageListAt: "openMessageListAt", hideUnreadCountForNotificationAndIndicator: "hideUnreadCountForNotificationAndIndicator", displayLoadingIndicator: "displayLoadingIndicator" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "scrollContainer", first: true, predicate: ["scrollContainer"], descendants: true }, { propertyName: "parentMessageElement", first: true, predicate: ["parentMessageElement"], descendants: true }], usesOnChanges: true, ngImport: i0__namespace, template: "<ng-container\n  *ngIf=\"\n    lastReadMessageId &&\n    isUnreadNotificationVisible &&\n    openMessageListAt === 'last-message' &&\n    displayUnreadSeparator\n  \"\n>\n  <ng-container\n    *ngTemplateOutlet=\"\n      customnewMessagesNotificationTemplate ||\n        defaultUnreadMessagesNotification;\n      context: {\n        unreadCount: unreadCount,\n        onDismiss: messageNotificationDismissClicked,\n        onJump: messageNotificationJumpClicked\n      }\n    \"\n  ></ng-container>\n</ng-container>\n<ng-template\n  #defaultUnreadMessagesNotification\n  let-unreadCount=\"unreadCount\"\n  let-onDismiss=\"onDismiss\"\n  let-onJump=\"onJump\"\n>\n  <div\n    class=\"str-chat__unread-messages-notification\"\n    data-testid=\"unread-messages-notification\"\n  >\n    <button\n      data-testid=\"unread-messages-notification-jump-to-message\"\n      (click)=\"onJump()\"\n    >\n      <ng-container\n        *ngIf=\"\n          unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n          else noUnreadCount\n        \"\n      >\n        {{\n          (unreadCount === 1\n            ? \"streamChat.\\{\\{count\\}\\} unread message\"\n            : \"streamChat.\\{\\{count\\}\\} unread messages\"\n          ) | translate: { count: unreadCount }\n        }}\n      </ng-container>\n      <ng-template #noUnreadCount>\n        {{ \"streamChat.Unread messages\" | translate }}\n      </ng-template>\n    </button>\n    <button\n      data-testid=\"unread-messages-notification-dismiss\"\n      (click)=\"onDismiss()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n</ng-template>\n<div #scrollContainer data-testid=\"scroll-container\" class=\"str-chat__list\">\n  <ng-container *ngIf=\"mode === 'main' && isEmpty && emptyListTemplate\">\n    <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n  </ng-container>\n  <div class=\"str-chat__reverse-infinite-scroll str-chat__message-list-scroll\">\n    <ul\n      class=\"str-chat__ul\"\n      [class.str-chat__message-options-in-bubble]=\"\n        messageOptionsTrigger === 'message-bubble'\n      \"\n    >\n      <li\n        #parentMessageElement\n        *ngIf=\"mode === 'thread' && parentMessage\"\n        data-testid=\"parent-message\"\n        class=\"str-chat__parent-message-li\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            messageTemplateContainer;\n            context: { message: parentMessage, index: 'parent' }\n          \"\n        ></ng-container>\n        <div data-testid=\"reply-count\" class=\"str-chat__thread-start\">\n          {{parentMessage?.reply_count === 1 ? ('streamChat.1 reply' | translate) : ('streamChat.{{ replyCount }}\n          replies' | translate:replyCountParam)}}\n        </div>\n      </li>\n      <ng-container *ngIf=\"mode === 'thread' && isEmpty && emptyListTemplate\">\n        <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n      </ng-container>\n      <stream-loading-indicator\n        data-testid=\"top-loading-indicator\"\n        *ngIf=\"\n          isLoading && direction === 'bottom-to-top' && displayLoadingIndicator\n        \"\n      ></stream-loading-indicator>\n      <ng-container *ngIf=\"messages$ | async as messages\">\n        <ng-container\n          *ngFor=\"\n            let message of messages;\n            let i = index;\n            let isFirst = first;\n            let isLast = last;\n            trackBy: trackByMessageId\n          \"\n        >\n          <ng-container *ngIf=\"isFirst\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: message.created_at,\n                  parsedDate: parseDate(message.created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n          <li\n            tabindex=\"0\"\n            data-testclass=\"message\"\n            class=\"str-chat__li str-chat__li--{{ groupStyles[i] }}\"\n            id=\"{{ message.id }}\"\n          >\n            <ng-container\n              *ngTemplateOutlet=\"\n                messageTemplateContainer;\n                context: { message: message, index: i }\n              \"\n            ></ng-container>\n          </li>\n          <ng-container\n            *ngIf=\"\n              (lastReadMessageId === message?.id &&\n                direction === 'bottom-to-top') ||\n              (direction === 'top-to-bottom' &&\n                lastReadMessageId === messages[i + 1]?.id)\n            \"\n          >\n            <li\n              *ngIf=\"displayUnreadSeparator\"\n              id=\"stream-chat-new-message-indicator\"\n              data-testid=\"new-messages-indicator\"\n              class=\"str-chat__li str-chat__unread-messages-separator-wrapper\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"\n                  customnewMessagesIndicatorTemplate ||\n                    defaultNewMessagesIndicator;\n                  context: { unreadCount: unreadCount }\n                \"\n              ></ng-container>\n            </li>\n          </ng-container>\n          <ng-container *ngIf=\"isNextMessageOnSeparateDate[i]\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: messages[i + 1].created_at,\n                  parsedDate: parseDate(messages[i + 1].created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n      <stream-loading-indicator\n        data-testid=\"bottom-loading-indicator\"\n        *ngIf=\"\n          isLoading && direction === 'top-to-bottom' && displayLoadingIndicator\n        \"\n      ></stream-loading-indicator>\n    </ul>\n    <ng-template #defaultTypingIndicator let-usersTyping$=\"usersTyping$\">\n      <!-- eslint-disable-next-line @angular-eslint/template/no-any -->\n      <ng-container *ngIf=\"$any(usersTyping$ | async) as users\">\n        <div\n          *ngIf=\"users.length > 0\"\n          data-testid=\"typing-indicator\"\n          class=\"str-chat__typing-indicator str-chat__typing-indicator--typing\"\n        >\n          <div class=\"str-chat__typing-indicator__dots\">\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n          </div>\n          <div\n            data-testid=\"typing-users\"\n            class=\"str-chat__typing-indicator__users\"\n          >\n            {{\n              users.length === 1\n                ? (\"streamChat.user is typing\"\n                  | translate: { user: getTypingIndicatorText(users) })\n                : (\"streamChat.users are typing\"\n                  | translate: { users: getTypingIndicatorText(users) })\n            }}\n          </div>\n        </div>\n      </ng-container>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        typingIndicatorTemplate || defaultTypingIndicator;\n        context: getTypingIndicatorContext()\n      \"\n    ></ng-container>\n  </div>\n</div>\n<div class=\"str-chat__jump-to-latest-message\">\n  <button\n    data-testid=\"scroll-to-latest\"\n    *ngIf=\"isUserScrolled && isJumpToLatestButtonVisible\"\n    class=\"\n      str-chat__message-notification-scroll-to-latest\n      str-chat__message-notification-scroll-to-latest-right\n      str-chat__circle-fab\n    \"\n    (keyup.enter)=\"jumpToLatestMessage()\"\n    (click)=\"jumpToLatestMessage()\"\n  >\n    <stream-icon\n      class=\"str-chat__jump-to-latest-icon str-chat__circle-fab-icon\"\n      [icon]=\"direction === 'bottom-to-top' ? 'arrow-down' : 'arrow-up'\"\n    ></stream-icon>\n    <div\n      *ngIf=\"newMessageCountWhileBeingScrolled > 0\"\n      class=\"\n        str-chat__message-notification\n        str-chat__message-notification-scroll-to-latest-unread-count\n        str-chat__jump-to-latest-unread-count\n      \"\n    >\n      {{ newMessageCountWhileBeingScrolled }}\n    </div>\n  </button>\n</div>\n\n<ng-template #messageTemplateContainer let-message=\"message\" let-index=\"index\">\n  <ng-template\n    #defaultMessageTemplate\n    let-messageInput=\"message\"\n    let-isLastSentMessage=\"isLastSentMessage\"\n    let-enabledMessageActions=\"enabledMessageActions\"\n    let-mode=\"mode\"\n    let-isHighlighted=\"isHighlighted\"\n    let-customActions=\"customActions\"\n  >\n    <stream-message\n      [message]=\"messageInput\"\n      [isLastSentMessage]=\"isLastSentMessage\"\n      [enabledMessageActions]=\"enabledMessageActions\"\n      [mode]=\"mode\"\n      [isHighlighted]=\"isHighlighted\"\n      [customActions]=\"customActions\"\n    ></stream-message>\n  </ng-template>\n  <ng-container\n    *ngTemplateOutlet=\"\n      messageTemplate || defaultMessageTemplate;\n      context: {\n        message: message,\n        isLastSentMessage: !!(\n          lastSentMessageId && message?.id === lastSentMessageId\n        ),\n        enabledMessageActions: enabledMessageActions,\n        mode: mode,\n        isHighlighted: message?.id === highlightedMessageId,\n        customActions: customMessageActions\n      }\n    \"\n  ></ng-container>\n</ng-template>\n\n<ng-template #dateSeparator let-date=\"date\" let-parsedDate=\"parsedDate\">\n  <ng-container *ngIf=\"displayDateSeparator\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        customDateSeparatorTemplate || defaultDateSeparator;\n        context: {\n          date: date,\n          parsedDate: parsedDate\n        }\n      \"\n    ></ng-container>\n  </ng-container>\n\n  <ng-template\n    #defaultDateSeparator\n    let-date=\"date\"\n    let-parsedDate=\"parsedDate\"\n  >\n    <div data-testid=\"date-separator\" class=\"str-chat__date-separator\">\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'right' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n      <div class=\"str-chat__date-separator-date\">\n        {{ parsedDate }}\n      </div>\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'left' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n    </div>\n  </ng-template>\n</ng-template>\n\n<ng-template #defaultNewMessagesIndicator let-unreadCount=\"unreadCount\">\n  <div class=\"str-chat__unread-messages-separator\">\n    <ng-container\n      *ngIf=\"\n        unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n        else noUnreadCount\n      \"\n    >\n      {{\n        (unreadCount === 1\n          ? \"streamChat.\\{\\{count\\}\\} unread message\"\n          : \"streamChat.\\{\\{count\\}\\} unread messages\"\n        ) | translate: { count: unreadCount }\n      }}\n    </ng-container>\n    <ng-template #noUnreadCount>\n      {{ \"streamChat.Unread messages\" | translate }}\n    </ng-template>\n  </div>\n</ng-template>\n", components: [{ type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }, { type: LoadingIndicatorComponent, selector: "stream-loading-indicator", inputs: ["size", "color"] }, { type: IconComponent, selector: "stream-icon", inputs: ["icon", "size"] }, { type: MessageComponent, selector: "stream-message", inputs: ["message", "enabledMessageActions", "isLastSentMessage", "mode", "isHighlighted", "customActions"] }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "translate": i9__namespace.TranslatePipe, "async": i8__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: MessageListComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-message-list',
                        templateUrl: './message-list.component.html',
                        styles: [],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: ChannelService }, { type: ChatClientService }, { type: CustomTemplatesService }, { type: DateParserService }, { type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }, { type: MessageActionsService }]; }, propDecorators: { mode: [{
                    type: i0.Input
                }], direction: [{
                    type: i0.Input
                }], messageOptionsTrigger: [{
                    type: i0.Input
                }], hideJumpToLatestButtonDuringScroll: [{
                    type: i0.Input
                }], customMessageActions: [{
                    type: i0.Input
                }], displayDateSeparator: [{
                    type: i0.Input
                }], displayUnreadSeparator: [{
                    type: i0.Input
                }], dateSeparatorTextPos: [{
                    type: i0.Input
                }], openMessageListAt: [{
                    type: i0.Input
                }], hideUnreadCountForNotificationAndIndicator: [{
                    type: i0.Input
                }], displayLoadingIndicator: [{
                    type: i0.Input
                }], scrollContainer: [{
                    type: i0.ViewChild,
                    args: ['scrollContainer']
                }], parentMessageElement: [{
                    type: i0.ViewChild,
                    args: ['parentMessageElement']
                }], class: [{
                    type: i0.HostBinding,
                    args: ['class']
                }] } });

    /**
     * The `ImageLoadService` is used to position the scrollbar in the message list
     * @deprecated - This class is no longer used by SDK components as image sizes are fixed
     */
    var ImageLoadService = /** @class */ (function () {
        function ImageLoadService() {
            /**
             * A subject that can be used to notify the message list if an image attachment finished loading
             */
            this.imageLoad$ = new rxjs.Subject();
        }
        return ImageLoadService;
    }());
    ImageLoadService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ImageLoadService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    ImageLoadService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ImageLoadService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ImageLoadService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return []; } });

    /**
     * The `Thread` component represents a [message thread](https://getstream.io/chat/docs/javascript/threads/?language=javascript), it is a container component that displays a thread with a header, [`MessageList`](./MessageListComponent.mdx) and [`MessageInput`](./MessageInputComponent.mdx) components.
     */
    var ThreadComponent = /** @class */ (function () {
        function ThreadComponent(customTemplatesService, channelService, chatClientService) {
            var _this = this;
            this.customTemplatesService = customTemplatesService;
            this.channelService = channelService;
            this.chatClientService = chatClientService;
            this.class = 'str-chat__thread';
            this.subscriptions = [];
            this.subscriptions.push(this.channelService.activeParentMessage$.subscribe(function (parentMessage) { return (_this.parentMessage = parentMessage); }));
            this.subscriptions.push(this.channelService.activeChannel$.subscribe(function (channel) { return (_this.channel = channel); }));
        }
        ThreadComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        ThreadComponent.prototype.getThreadHeaderContext = function () {
            var _this = this;
            return {
                parentMessage: this.parentMessage,
                closeThreadHandler: function () { return _this.closeThread(); },
            };
        };
        ThreadComponent.prototype.closeThread = function () {
            void this.channelService.setAsActiveParentMessage(undefined);
        };
        Object.defineProperty(ThreadComponent.prototype, "channelName", {
            get: function () {
                if (!this.channel || !this.chatClientService.chatClient.user) {
                    return '';
                }
                return getChannelDisplayText(this.channel, this.chatClientService.chatClient.user);
            },
            enumerable: false,
            configurable: true
        });
        return ThreadComponent;
    }());
    ThreadComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ThreadComponent, deps: [{ token: CustomTemplatesService }, { token: ChannelService }, { token: ChatClientService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    ThreadComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.5", type: ThreadComponent, selector: "stream-thread", host: { properties: { "class": "this.class" } }, ngImport: i0__namespace, template: "<div class=\"str-chat__thread-container\">\n  <ng-container\n    *ngTemplateOutlet=\"\n      (customTemplatesService.threadHeaderTemplate$ | async) ||\n        defaultThreadHeader;\n      context: getThreadHeaderContext()\n    \"\n  ></ng-container>\n  <ng-content></ng-content>\n</div>\n\n<ng-template\n  #defaultThreadHeader\n  let-parentMessage=\"parentMessage\"\n  let-closeThreadHandler=\"closeThreadHandler\"\n>\n  <div class=\"str-chat__thread-header\">\n    <div class=\"str-chat__thread-header-details\">\n      <div class=\"str-chat__thread-header-name\" translate>\n        streamChat.Thread\n      </div>\n      <div\n        class=\"str-chat__thread-header-channel-name\"\n        data-testid=\"channel-name\"\n      >\n        {{ channelName }}\n      </div>\n    </div>\n    <button\n      class=\"str-chat__square-button str-chat__close-thread-button\"\n      data-testid=\"close-button\"\n      (click)=\"closeThreadHandler()\"\n    >\n      <stream-icon-placeholder\n        icon=\"close-no-outline\"\n      ></stream-icon-placeholder>\n    </button>\n  </div>\n</ng-template>\n", components: [{ type: IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon", "size"] }], directives: [{ type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i9__namespace.TranslateDirective, selector: "[translate],[ngx-translate]", inputs: ["translate", "translateParams"] }], pipes: { "async": i8__namespace.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: ThreadComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'stream-thread',
                        templateUrl: './thread.component.html',
                        styles: [],
                    }]
            }], ctorParameters: function () { return [{ type: CustomTemplatesService }, { type: ChannelService }, { type: ChatClientService }]; }, propDecorators: { class: [{
                    type: i0.HostBinding,
                    args: ['class']
                }] } });

    var StreamAvatarModule = /** @class */ (function () {
        function StreamAvatarModule() {
        }
        return StreamAvatarModule;
    }());
    StreamAvatarModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamAvatarModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StreamAvatarModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamAvatarModule, declarations: [AvatarComponent, AvatarPlaceholderComponent], imports: [i8.CommonModule, i9.TranslateModule], exports: [AvatarComponent, AvatarPlaceholderComponent] });
    StreamAvatarModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamAvatarModule, imports: [[i8.CommonModule, i9.TranslateModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamAvatarModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [AvatarComponent, AvatarPlaceholderComponent],
                        imports: [i8.CommonModule, i9.TranslateModule],
                        exports: [AvatarComponent, AvatarPlaceholderComponent],
                    }]
            }] });

    var StreamChatModule = /** @class */ (function () {
        function StreamChatModule() {
        }
        return StreamChatModule;
    }());
    StreamChatModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamChatModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StreamChatModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamChatModule, declarations: [ChannelComponent,
            ChannelHeaderComponent,
            ChannelListComponent,
            ChannelPreviewComponent,
            MessageComponent,
            MessageInputComponent,
            MessageListComponent,
            LoadingIndicatorComponent,
            IconComponent,
            MessageActionsBoxComponent,
            AttachmentListComponent,
            MessageReactionsComponent,
            NotificationComponent,
            NotificationListComponent,
            AttachmentPreviewListComponent,
            ModalComponent,
            TextareaDirective,
            ThreadComponent,
            IconPlaceholderComponent,
            LoadingIndicatorPlaceholderComponent,
            EditMessageFormComponent,
            MessageBouncePromptComponent,
            VoiceRecordingComponent,
            VoiceRecordingWavebarComponent], imports: [i8.CommonModule,
            i9.TranslateModule,
            StreamAvatarModule,
            i9$1.NgxPopperjsModule], exports: [ChannelComponent,
            ChannelHeaderComponent,
            ChannelListComponent,
            ChannelPreviewComponent,
            MessageComponent,
            MessageInputComponent,
            MessageListComponent,
            LoadingIndicatorComponent,
            IconComponent,
            MessageActionsBoxComponent,
            AttachmentListComponent,
            MessageReactionsComponent,
            NotificationComponent,
            NotificationListComponent,
            AttachmentPreviewListComponent,
            ModalComponent,
            StreamAvatarModule,
            ThreadComponent,
            IconPlaceholderComponent,
            LoadingIndicatorPlaceholderComponent,
            EditMessageFormComponent,
            MessageBouncePromptComponent,
            VoiceRecordingComponent,
            VoiceRecordingWavebarComponent] });
    StreamChatModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamChatModule, imports: [[
                i8.CommonModule,
                i9.TranslateModule,
                StreamAvatarModule,
                i9$1.NgxPopperjsModule,
            ], StreamAvatarModule] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamChatModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [
                            ChannelComponent,
                            ChannelHeaderComponent,
                            ChannelListComponent,
                            ChannelPreviewComponent,
                            MessageComponent,
                            MessageInputComponent,
                            MessageListComponent,
                            LoadingIndicatorComponent,
                            IconComponent,
                            MessageActionsBoxComponent,
                            AttachmentListComponent,
                            MessageReactionsComponent,
                            NotificationComponent,
                            NotificationListComponent,
                            AttachmentPreviewListComponent,
                            ModalComponent,
                            TextareaDirective,
                            ThreadComponent,
                            IconPlaceholderComponent,
                            LoadingIndicatorPlaceholderComponent,
                            EditMessageFormComponent,
                            MessageBouncePromptComponent,
                            VoiceRecordingComponent,
                            VoiceRecordingWavebarComponent,
                        ],
                        imports: [
                            i8.CommonModule,
                            i9.TranslateModule,
                            StreamAvatarModule,
                            i9$1.NgxPopperjsModule,
                        ],
                        exports: [
                            ChannelComponent,
                            ChannelHeaderComponent,
                            ChannelListComponent,
                            ChannelPreviewComponent,
                            MessageComponent,
                            MessageInputComponent,
                            MessageListComponent,
                            LoadingIndicatorComponent,
                            IconComponent,
                            MessageActionsBoxComponent,
                            AttachmentListComponent,
                            MessageReactionsComponent,
                            NotificationComponent,
                            NotificationListComponent,
                            AttachmentPreviewListComponent,
                            ModalComponent,
                            StreamAvatarModule,
                            ThreadComponent,
                            IconPlaceholderComponent,
                            LoadingIndicatorPlaceholderComponent,
                            EditMessageFormComponent,
                            MessageBouncePromptComponent,
                            VoiceRecordingComponent,
                            VoiceRecordingWavebarComponent,
                        ],
                    }]
            }] });

    var StreamAutocompleteTextareaModule = /** @class */ (function () {
        function StreamAutocompleteTextareaModule() {
        }
        return StreamAutocompleteTextareaModule;
    }());
    StreamAutocompleteTextareaModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamAutocompleteTextareaModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StreamAutocompleteTextareaModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamAutocompleteTextareaModule, declarations: [AutocompleteTextareaComponent], imports: [i8.CommonModule, i9.TranslateModule, i8$1.MentionModule, StreamAvatarModule], exports: [AutocompleteTextareaComponent] });
    StreamAutocompleteTextareaModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamAutocompleteTextareaModule, providers: [
            {
                provide: textareaInjectionToken,
                useValue: AutocompleteTextareaComponent,
            },
        ], imports: [[i8.CommonModule, i9.TranslateModule, i8$1.MentionModule, StreamAvatarModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamAutocompleteTextareaModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [AutocompleteTextareaComponent],
                        imports: [i8.CommonModule, i9.TranslateModule, i8$1.MentionModule, StreamAvatarModule],
                        exports: [AutocompleteTextareaComponent],
                        providers: [
                            {
                                provide: textareaInjectionToken,
                                useValue: AutocompleteTextareaComponent,
                            },
                        ],
                    }]
            }] });

    var StreamTextareaModule = /** @class */ (function () {
        function StreamTextareaModule() {
        }
        return StreamTextareaModule;
    }());
    StreamTextareaModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamTextareaModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    StreamTextareaModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamTextareaModule, declarations: [TextareaComponent], imports: [i8.CommonModule, i9.TranslateModule], exports: [TextareaComponent] });
    StreamTextareaModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamTextareaModule, providers: [
            {
                provide: textareaInjectionToken,
                useValue: TextareaComponent,
            },
        ], imports: [[i8.CommonModule, i9.TranslateModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0__namespace, type: StreamTextareaModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: [TextareaComponent],
                        imports: [i8.CommonModule, i9.TranslateModule],
                        exports: [TextareaComponent],
                        providers: [
                            {
                                provide: textareaInjectionToken,
                                useValue: TextareaComponent,
                            },
                        ],
                    }]
            }] });

    /*
     * Public API Surface of stream-chat-angular
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AttachmentConfigurationService = AttachmentConfigurationService;
    exports.AttachmentListComponent = AttachmentListComponent;
    exports.AttachmentPreviewListComponent = AttachmentPreviewListComponent;
    exports.AttachmentService = AttachmentService;
    exports.AutocompleteTextareaComponent = AutocompleteTextareaComponent;
    exports.AvatarComponent = AvatarComponent;
    exports.AvatarPlaceholderComponent = AvatarPlaceholderComponent;
    exports.ChannelComponent = ChannelComponent;
    exports.ChannelHeaderComponent = ChannelHeaderComponent;
    exports.ChannelListComponent = ChannelListComponent;
    exports.ChannelListToggleService = ChannelListToggleService;
    exports.ChannelPreviewComponent = ChannelPreviewComponent;
    exports.ChannelService = ChannelService;
    exports.ChatClientService = ChatClientService;
    exports.CustomTemplatesService = CustomTemplatesService;
    exports.DateParserService = DateParserService;
    exports.EditMessageFormComponent = EditMessageFormComponent;
    exports.EmojiInputService = EmojiInputService;
    exports.IconComponent = IconComponent;
    exports.IconPlaceholderComponent = IconPlaceholderComponent;
    exports.ImageLoadService = ImageLoadService;
    exports.LoadingIndicatorComponent = LoadingIndicatorComponent;
    exports.LoadingIndicatorPlaceholderComponent = LoadingIndicatorPlaceholderComponent;
    exports.MessageActionsBoxComponent = MessageActionsBoxComponent;
    exports.MessageActionsService = MessageActionsService;
    exports.MessageBouncePromptComponent = MessageBouncePromptComponent;
    exports.MessageComponent = MessageComponent;
    exports.MessageInputComponent = MessageInputComponent;
    exports.MessageInputConfigService = MessageInputConfigService;
    exports.MessageListComponent = MessageListComponent;
    exports.MessageReactionsComponent = MessageReactionsComponent;
    exports.MessageReactionsService = MessageReactionsService;
    exports.MessageService = MessageService;
    exports.ModalComponent = ModalComponent;
    exports.NotificationComponent = NotificationComponent;
    exports.NotificationListComponent = NotificationListComponent;
    exports.NotificationService = NotificationService;
    exports.StreamAutocompleteTextareaModule = StreamAutocompleteTextareaModule;
    exports.StreamAvatarModule = StreamAvatarModule;
    exports.StreamChatModule = StreamChatModule;
    exports.StreamI18nService = StreamI18nService;
    exports.StreamTextareaModule = StreamTextareaModule;
    exports.TextareaComponent = TextareaComponent;
    exports.TextareaDirective = TextareaDirective;
    exports.ThemeService = ThemeService;
    exports.ThreadComponent = ThreadComponent;
    exports.TransliterationService = TransliterationService;
    exports.VoiceRecordingComponent = VoiceRecordingComponent;
    exports.VoiceRecordingWavebarComponent = VoiceRecordingWavebarComponent;
    exports.createMessagePreview = createMessagePreview;
    exports.getChannelDisplayText = getChannelDisplayText;
    exports.getGroupStyles = getGroupStyles;
    exports.getMessageTranslation = getMessageTranslation;
    exports.getReadBy = getReadBy;
    exports.isImageAttachment = isImageAttachment;
    exports.isImageFile = isImageFile;
    exports.isOnSeparateDate = isOnSeparateDate;
    exports.listUsers = listUsers;
    exports.parseDate = parseDate;
    exports.textareaInjectionToken = textareaInjectionToken;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=stream-chat-angular.umd.js.map
