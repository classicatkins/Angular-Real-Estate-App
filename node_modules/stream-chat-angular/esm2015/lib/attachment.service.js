import { __awaiter } from "tslib";
import { Injectable } from '@angular/core';
import { isImageFile } from './is-image-file';
import { BehaviorSubject } from 'rxjs';
import { isImageAttachment } from './is-image-attachment';
import * as i0 from "@angular/core";
import * as i1 from "./channel.service";
import * as i2 from "./notification.service";
/**
 * The `AttachmentService` manages the uploads of a message input.
 */
export class AttachmentService {
    constructor(channelService, notificationService) {
        this.channelService = channelService;
        this.notificationService = notificationService;
        this.attachmentUploadInProgressCounterSubject = new BehaviorSubject(0);
        this.attachmentUploadsSubject = new BehaviorSubject([]);
        this.attachmentUploadInProgressCounter$ =
            this.attachmentUploadInProgressCounterSubject.asObservable();
        this.attachmentUploads$ = this.attachmentUploadsSubject.asObservable();
    }
    /**
     * Resets the attachments uploads (for example after the message with the attachments sent successfully)
     */
    resetAttachmentUploads() {
        this.attachmentUploadsSubject.next([]);
    }
    /**
     * Uploads the selected files, and creates preview for image files. The result is propagated throught the `attachmentUploads$` stream.
     * @param fileList The files selected by the user
     * @returns A promise with the result
     */
    filesSelected(fileList) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fileList) {
                return;
            }
            const imageFiles = [];
            const dataFiles = [];
            const videoFiles = [];
            Array.from(fileList).forEach((file) => {
                if (isImageFile(file)) {
                    imageFiles.push(file);
                }
                else if (file.type.startsWith('video/')) {
                    videoFiles.push(file);
                }
                else {
                    dataFiles.push(file);
                }
            });
            imageFiles.forEach((f) => this.createPreview(f));
            const newUploads = [
                ...imageFiles.map((file) => ({
                    file,
                    state: 'uploading',
                    type: 'image',
                })),
                ...videoFiles.map((file) => ({
                    file,
                    state: 'uploading',
                    type: 'video',
                })),
                ...dataFiles.map((file) => ({
                    file,
                    state: 'uploading',
                    type: 'file',
                })),
            ];
            this.attachmentUploadsSubject.next([
                ...this.attachmentUploadsSubject.getValue(),
                ...newUploads,
            ]);
            yield this.uploadAttachments(newUploads);
        });
    }
    /**
     * You can add custom `image`, `video` and `file` attachments using this method.
     *
     * Note: If you just want to use your own CDN for file uploads, you don't necessary need this method, you can just specify you own upload function in the [`ChannelService`](./ChannelService.mdx)
     *
     * @param attachment
     */
    addAttachment(attachment) {
        attachment.isCustomAttachment = true;
        this.createFromAttachments([attachment]);
    }
    /**
     * Retries to upload an attachment.
     * @param file
     * @returns A promise with the result
     */
    retryAttachmentUpload(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const attachmentUploads = this.attachmentUploadsSubject.getValue();
            const upload = attachmentUploads.find((u) => u.file === file);
            if (!upload) {
                return;
            }
            upload.state = 'uploading';
            this.attachmentUploadsSubject.next([...attachmentUploads]);
            yield this.uploadAttachments([upload]);
        });
    }
    /**
     * Deletes an attachment, the attachment can have any state (`error`, `uploading` or `success`).
     * @param upload
     */
    deleteAttachment(upload) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const attachmentUploads = this.attachmentUploadsSubject.getValue();
            let result;
            if (upload.state === 'success' &&
                !((_a = upload.fromAttachment) === null || _a === void 0 ? void 0 : _a.isCustomAttachment)) {
                try {
                    yield this.channelService.deleteAttachment(upload);
                    result = [...attachmentUploads];
                    const index = attachmentUploads.indexOf(upload);
                    result.splice(index, 1);
                }
                catch (error) {
                    result = attachmentUploads;
                    this.notificationService.addTemporaryNotification('streamChat.Error deleting attachment');
                }
            }
            else {
                result = [...attachmentUploads];
                const index = attachmentUploads.indexOf(upload);
                result.splice(index, 1);
            }
            this.attachmentUploadsSubject.next([...result]);
        });
    }
    /**
     * Maps the current uploads to a format that can be sent along with the message to the Stream API.
     * @returns the attachments
     */
    mapToAttachments() {
        const attachmentUploads = this.attachmentUploadsSubject.getValue();
        return attachmentUploads
            .filter((r) => r.state === 'success')
            .map((r) => {
            var _a, _b, _c, _d;
            const attachment = {
                type: r.type,
            };
            if (r.fromAttachment) {
                return r.fromAttachment;
            }
            else {
                attachment.mime_type = (_a = r.file) === null || _a === void 0 ? void 0 : _a.type;
                if (r.type === 'image') {
                    attachment.fallback = (_b = r.file) === null || _b === void 0 ? void 0 : _b.name;
                    attachment.image_url = r.url;
                }
                else {
                    attachment.asset_url = r.url;
                    attachment.title = (_c = r.file) === null || _c === void 0 ? void 0 : _c.name;
                    attachment.file_size = (_d = r.file) === null || _d === void 0 ? void 0 : _d.size;
                    attachment.thumb_url = r.thumb_url;
                }
            }
            return attachment;
        });
    }
    /**
     * Maps attachments received from the Stream API to uploads. This is useful when editing a message.
     * @param attachments Attachemnts received with the message
     */
    createFromAttachments(attachments) {
        const attachmentUploads = [];
        attachments.forEach((attachment) => {
            if (isImageAttachment(attachment)) {
                attachmentUploads.push({
                    url: (attachment.img_url ||
                        attachment.thumb_url ||
                        attachment.image_url),
                    state: 'success',
                    type: 'image',
                    file: {
                        name: attachment.fallback,
                        type: attachment.mime_type,
                    },
                    fromAttachment: attachment,
                });
            }
            else if (attachment.type === 'file' || attachment.type === 'video') {
                attachmentUploads.push({
                    url: attachment.asset_url,
                    state: 'success',
                    file: {
                        name: attachment.title,
                        size: attachment.file_size,
                        type: attachment.mime_type,
                    },
                    type: attachment.type,
                    thumb_url: attachment.thumb_url,
                    fromAttachment: attachment,
                });
            }
        });
        if (attachmentUploads.length > 0) {
            this.attachmentUploadsSubject.next([
                ...this.attachmentUploadsSubject.getValue(),
                ...attachmentUploads,
            ]);
        }
    }
    createPreview(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            var _a;
            const attachmentUploads = this.attachmentUploadsSubject.getValue();
            const upload = attachmentUploads.find((upload) => upload.file === file);
            if (!upload) {
                return;
            }
            upload.previewUri = ((_a = event.target) === null || _a === void 0 ? void 0 : _a.result) || undefined;
            this.attachmentUploadsSubject.next([...attachmentUploads]);
        };
        reader.readAsDataURL(file);
    }
    uploadAttachments(uploads) {
        return __awaiter(this, void 0, void 0, function* () {
            this.attachmentUploadInProgressCounterSubject.next(this.attachmentUploadInProgressCounterSubject.getValue() + 1);
            const result = yield this.channelService.uploadAttachments(uploads);
            const attachmentUploads = this.attachmentUploadsSubject.getValue();
            result.forEach((r) => {
                var _a, _b, _c, _d;
                const upload = attachmentUploads.find((upload) => upload.file === r.file);
                if (!upload) {
                    if (r.url) {
                        void this.channelService.deleteAttachment(r);
                    }
                    return;
                }
                upload.state = r.state;
                upload.url = r.url;
                upload.thumb_url = r.thumb_url;
                if (upload.state === 'error') {
                    upload.errorReason = r.errorReason;
                    upload.errorExtraInfo = r.errorExtraInfo;
                    let errorKey;
                    const translateParams = { name: upload.file.name };
                    switch (upload.errorReason) {
                        case 'file-extension':
                            errorKey =
                                'streamChat.Error uploading file, extension not supported';
                            translateParams.ext = (_b = (_a = upload.errorExtraInfo) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.param;
                            break;
                        case 'file-size':
                            errorKey =
                                'streamChat.Error uploading file, maximum file size exceeded';
                            translateParams.limit = (_d = (_c = upload.errorExtraInfo) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.param;
                            break;
                        default:
                            errorKey = 'streamChat.Error uploading file';
                    }
                    this.notificationService.addTemporaryNotification(errorKey, 'error', undefined, translateParams);
                }
            });
            this.attachmentUploadInProgressCounterSubject.next(this.attachmentUploadInProgressCounterSubject.getValue() - 1);
            this.attachmentUploadsSubject.next([...attachmentUploads]);
        });
    }
}
AttachmentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: AttachmentService, deps: [{ token: i1.ChannelService }, { token: i2.NotificationService }], target: i0.ɵɵFactoryTarget.Injectable });
AttachmentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: AttachmentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: AttachmentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ChannelService }, { type: i2.NotificationService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXR0YWNobWVudC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvc3RyZWFtLWNoYXQtYW5ndWxhci9zcmMvbGliL2F0dGFjaG1lbnQuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUMsT0FBTyxFQUFFLGVBQWUsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUduRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7OztBQUkxRDs7R0FFRztBQUlILE1BQU0sT0FBTyxpQkFBaUI7SUFpQjVCLFlBQ1UsY0FBOEIsRUFDOUIsbUJBQXdDO1FBRHhDLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5Qix3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBUjFDLDZDQUF3QyxHQUM5QyxJQUFJLGVBQWUsQ0FBUyxDQUFDLENBQUMsQ0FBQztRQUN6Qiw2QkFBd0IsR0FBRyxJQUFJLGVBQWUsQ0FDcEQsRUFBRSxDQUNILENBQUM7UUFNQSxJQUFJLENBQUMsa0NBQWtDO1lBQ3JDLElBQUksQ0FBQyx3Q0FBd0MsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMvRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7T0FFRztJQUNILHNCQUFzQjtRQUNwQixJQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0csYUFBYSxDQUFDLFFBQXlCOztZQUMzQyxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNiLE9BQU87YUFDUjtZQUNELE1BQU0sVUFBVSxHQUFXLEVBQUUsQ0FBQztZ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Q0FBd0MsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQzdELENBQUM7WUFDRixJQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7UUFDN0QsQ0FBQztLQUFBOzs4R0FwUlUsaUJBQWlCO2tIQUFqQixpQkFBaUIsY0FGaEIsTUFBTTsyRkFFUCxpQkFBaUI7a0JBSDdCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNJbWFnZUZpbGUgfSBmcm9tICcuL2lzLWltYWdlLWZpbGUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBBdHRhY2htZW50IH0gZnJvbSAnc3RyZWFtLWNoYXQnO1xuaW1wb3J0IHsgQ2hhbm5lbFNlcnZpY2UgfSBmcm9tICcuL2NoYW5uZWwuc2VydmljZSc7XG5pbXBvcnQgeyBpc0ltYWdlQXR0YWNobWVudCB9IGZyb20gJy4vaXMtaW1hZ2UtYXR0YWNobWVudCc7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9ub3RpZmljYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBBdHRhY2htZW50VXBsb2FkLCBEZWZhdWx0U3RyZWFtQ2hhdEdlbmVyaWNzIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogVGhlIGBBdHRhY2htZW50U2VydmljZWAgbWFuYWdlcyB0aGUgdXBsb2FkcyBvZiBhIG1lc3NhZ2UgaW5wdXQuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBdHRhY2htZW50U2VydmljZTxcbiAgVCBleHRlbmRzIERlZmF1bHRTdHJlYW1DaGF0R2VuZXJpY3MgPSBEZWZhdWx0U3RyZWFtQ2hhdEdlbmVyaWNzXG4+IHtcbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBudW1iZXIgb2YgdXBsb2FkcyBpbiBwcm9ncmVzcy5cbiAgICovXG4gIGF0dGFjaG1lbnRVcGxvYWRJblByb2dyZXNzQ291bnRlciQ6IE9ic2VydmFibGU8bnVtYmVyPjtcbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBzdGF0ZSBvZiB0aGUgdXBsb2FkcyAoW2BBdHRhY2htZW50VXBsb2FkW11gXShodHRwczovL2dpdGh1Yi5jb20vR2V0U3RyZWFtL3N0cmVhbS1jaGF0LWFuZ3VsYXIvYmxvYi9tYXN0ZXIvcHJvamVjdHMvc3RyZWFtLWNoYXQtYW5ndWxhci9zcmMvbGliL3R5cGVzLnRzKSksIGl0IGFkZHMgYSBzdGF0ZSAoYHN1Y2Nlc3NgLCBgZXJyb3JgIG9yIGB1cGxvYWRpbmdgKSB0byBlYWNoIGZpbGUgdGhlIHVzZXIgc2VsZWN0cyBmb3IgdXBsb2FkLiBJdCBpcyB1c2VkIGJ5IHRoZSBbYEF0dGFjaG1lbnRQcmV2aWV3TGlzdGBdKC4uL2NvbXBvbmVudHMvQXR0YWNobWVudFByZXZpZXdMaXN0Q29tcG9uZW50Lm1keCkgdG8gZGlzcGxheSB0aGUgYXR0YWNobWVudCBwcmV2aWV3cy5cbiAgICovXG4gIGF0dGFjaG1lbnRVcGxvYWRzJDogT2JzZXJ2YWJsZTxBdHRhY2htZW50VXBsb2FkW10+O1xuICBwcml2YXRlIGF0dGFjaG1lbnRVcGxvYWRJblByb2dyZXNzQ291bnRlclN1YmplY3QgPVxuICAgIG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPigwKTtcbiAgcHJpdmF0ZSBhdHRhY2htZW50VXBsb2Fkc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEF0dGFjaG1lbnRVcGxvYWRbXT4oXG4gICAgW11cbiAgKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNoYW5uZWxTZXJ2aWNlOiBDaGFubmVsU2VydmljZSxcbiAgICBwcml2YXRlIG5vdGlmaWNhdGlvblNlcnZpY2U6IE5vdGlmaWNhdGlvblNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5hdHRhY2htZW50VXBsb2FkSW5Qcm9ncmVzc0NvdW50ZXIkID1cbiAgICAgIHRoaXMuYXR0YWNobWVudFVwbG9hZEluUHJvZ3Jlc3NDb3VudGVyU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB0aGlzLmF0dGFjaG1lbnRVcGxvYWRzJCA9IHRoaXMuYXR0YWNobWVudFVwbG9hZHNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgYXR0YWNobWVudHMgdXBsb2FkcyAoZm9yIGV4YW1wbGUgYWZ0ZXIgdGhlIG1lc3NhZ2Ugd2l0aCB0aGUgYXR0YWNobWVudHMgc2VudCBzdWNjZXNzZnVsbHkpXG4gICAqL1xuICByZXNldEF0dGFjaG1lbnRVcGxvYWRzKCkge1xuICAgIHRoaXMuYXR0YWNobWVudFVwbG9hZHNTdWJqZWN0Lm5leHQoW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIHNlbGVjdGVkIGZpbGVzLCBhbmQgY3JlYXRlcyBwcmV2aWV3IGZvciBpbWFnZSBmaWxlcy4gVGhlIHJlc3VsdCBpcyBwcm9wYWdhdGVkIHRocm91Z2h0IHRoZSBgYXR0YWNobWVudFVwbG9hZHMkYCBzdHJlYW0uXG4gICAqIEBwYXJhbSBmaWxlTGlzdCBUaGUgZmlsZXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXJcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdFxuICAgKi9cbiAgYXN5bmMgZmlsZXNTZWxlY3RlZChmaWxlTGlzdDogRmlsZUxpc3QgfCBudWxsKSB7XG4gICAgaWYgKCFmaWxlTGlzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZUZpbGVzOiBGaWxlW10gPSBbXTtcbiAgICBjb25zdCBkYXRhRmlsZXM6IEZpbGVbXSA9IFtdO1xuICAgIGNvbnN0IHZpZGVvRmlsZXM6IEZpbGVbXSA9IFtdO1xuXG4gICAgQXJyYXkuZnJvbShmaWxlTGlzdCkuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgaWYgKGlzSW1hZ2VGaWxlKGZpbGUpKSB7XG4gICAgICAgIGltYWdlRmlsZXMucHVzaChmaWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ3ZpZGVvLycpKSB7XG4gICAgICAgIHZpZGVvRmlsZXMucHVzaChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGltYWdlRmlsZXMuZm9yRWFjaCgoZikgPT4gdGhpcy5jcmVhdGVQcmV2aWV3KGYpKTtcbiAgICBjb25zdCBuZXdVcGxvYWRzID0gW1xuICAgICAgLi4uaW1hZ2VGaWxlcy5tYXAoKGZpbGUpID0+ICh7XG4gICAgICAgIGZpbGUsXG4gICAgICAgIHN0YXRlOiAndXBsb2FkaW5nJyBhcyAndXBsb2FkaW5nJyxcbiAgICAgICAgdHlwZTogJ2ltYWdlJyBhcyAnaW1hZ2UnLFxuICAgICAgfSkpLFxuICAgICAgLi4udmlkZW9GaWxlcy5tYXAoKGZpbGUpID0+ICh7XG4gICAgICAgIGZpbGUsXG4gICAgICAgIHN0YXRlOiAndXBsb2FkaW5nJyBhcyAndXBsb2FkaW5nJyxcbiAgICAgICAgdHlwZTogJ3ZpZGVvJyBhcyAndmlkZW8nLFxuICAgICAgfSkpLFxuICAgICAgLi4uZGF0YUZpbGVzLm1hcCgoZmlsZSkgPT4gKHtcbiAgICAgICAgZmlsZSxcbiAgICAgICAgc3RhdGU6ICd1cGxvYWRpbmcnIGFzICd1cGxvYWRpbmcnLFxuICAgICAgICB0eXBlOiAnZmlsZScgYXMgJ2ZpbGUnLFxuICAgICAgfSkpLFxuICAgIF07XG4gICAgdGhpcy5hdHRhY2htZW50VXBsb2Fkc1N1YmplY3QubmV4dChbXG4gICAgICAuLi50aGlzLmF0dGFjaG1lbnRVcGxvYWRzU3ViamVjdC5nZXRWYWx1ZSgpLFxuICAgICAgLi4ubmV3VXBsb2FkcyxcbiAgICBdKTtcbiAgICBhd2FpdCB0aGlzLnVwbG9hZEF0dGFjaG1lbnRzKG5ld1VwbG9hZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFlvdSBjYW4gYWRkIGN1c3RvbSBgaW1hZ2VgLCBgdmlkZW9gIGFuZCBgZmlsZWAgYXR0YWNobWVudHMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIE5vdGU6IElmIHlvdSBqdXN0IHdhbnQgdG8gdXNlIHlvdXIgb3duIENETiBmb3IgZmlsZSB1cGxvYWRzLCB5b3UgZG9uJ3QgbmVjZXNzYXJ5IG5lZWQgdGhpcyBtZXRob2QsIHlvdSBjYW4ganVzdCBzcGVjaWZ5IHlvdSBvd24gdXBsb2FkIGZ1bmN0aW9uIGluIHRoZSBbYENoYW5uZWxTZXJ2aWNlYF0oLi9DaGFubmVsU2VydmljZS5tZHgpXG4gICAqXG4gICAqIEBwYXJhbSBhdHRhY2htZW50XG4gICAqL1xuICBhZGRBdHRhY2htZW50KGF0dGFjaG1lbnQ6IEF0dGFjaG1lbnQ8VD4pIHtcbiAgICBhdHRhY2htZW50LmlzQ3VzdG9tQXR0YWNobWVudCA9IHRydWU7XG4gICAgdGhpcy5jcmVhdGVGcm9tQXR0YWNobWVudHMoW2F0dGFjaG1lbnRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWVzIHRvIHVwbG9hZCBhbiBhdHRhY2htZW50LlxuICAgKiBAcGFyYW0gZmlsZVxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0XG4gICAqL1xuICBhc3luYyByZXRyeUF0dGFjaG1lbnRVcGxvYWQoZmlsZTogRmlsZSkge1xuICAgIGNvbnN0IGF0dGFjaG1lbnRVcGxvYWRzID0gdGhpcy5hdHRhY2htZW50VXBsb2Fkc1N1YmplY3QuZ2V0VmFsdWUoKTtcbiAgICBjb25zdCB1cGxvYWQgPSBhdHRhY2htZW50VXBsb2Fkcy5maW5kKCh1KSA9PiB1LmZpbGUgPT09IGZpbGUpO1xuICAgIGlmICghdXBsb2FkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVwbG9hZC5zdGF0ZSA9ICd1cGxvYWRpbmcnO1xuICAgIHRoaXMuYXR0YWNobWVudFVwbG9hZHNTdWJqZWN0Lm5leHQoWy4uLmF0dGFjaG1lbnRVcGxvYWRzXSk7XG4gICAgYXdhaXQgdGhpcy51cGxvYWRBdHRhY2htZW50cyhbdXBsb2FkXSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRhY2htZW50LCB0aGUgYXR0YWNobWVudCBjYW4gaGF2ZSBhbnkgc3RhdGUgKGBlcnJvcmAsIGB1cGxvYWRpbmdgIG9yIGBzdWNjZXNzYCkuXG4gICAqIEBwYXJhbSB1cGxvYWRcbiAgICovXG4gIGFzeW5jIGRlbGV0ZUF0dGFjaG1lbnQodXBsb2FkOiBBdHRhY2htZW50VXBsb2FkKSB7XG4gICAgY29uc3QgYXR0YWNobWVudFVwbG9hZHMgPSB0aGlzLmF0dGFjaG1lbnRVcGxvYWRzU3ViamVjdC5nZXRWYWx1ZSgpO1xuICAgIGxldCByZXN1bHQhOiBBdHRhY2htZW50VXBsb2FkW107XG4gICAgaWYgKFxuICAgICAgdXBsb2FkLnN0YXRlID09PSAnc3VjY2VzcycgJiZcbiAgICAgICF1cGxvYWQuZnJvbUF0dGFjaG1lbnQ/LmlzQ3VzdG9tQXR0YWNobWVudFxuICAgICkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jaGFubmVsU2VydmljZS5kZWxldGVBdHRhY2htZW50KHVwbG9hZCk7XG4gICAgICAgIHJlc3VsdCA9IFsuLi5hdHRhY2htZW50VXBsb2Fkc107XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYXR0YWNobWVudFVwbG9hZHMuaW5kZXhPZih1cGxvYWQpO1xuICAgICAgICByZXN1bHQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlc3VsdCA9IGF0dGFjaG1lbnRVcGxvYWRzO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblNlcnZpY2UuYWRkVGVtcG9yYXJ5Tm90aWZpY2F0aW9uKFxuICAgICAgICAgICdzdHJlYW1DaGF0LkVycm9yIGRlbGV0aW5nIGF0dGFjaG1lbnQnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFsuLi5hdHRhY2htZW50VXBsb2Fkc107XG4gICAgICBjb25zdCBpbmRleCA9IGF0dGFjaG1lbnRVcGxvYWRzLmluZGV4T2YodXBsb2FkKTtcbiAgICAgIHJlc3VsdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0aGlzLmF0dGFjaG1lbnRVcGxvYWRzU3ViamVjdC5uZXh0KFsuLi5yZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIHRoZSBjdXJyZW50IHVwbG9hZHMgdG8gYSBmb3JtYXQgdGhhdCBjYW4gYmUgc2VudCBhbG9uZyB3aXRoIHRoZSBtZXNzYWdlIHRvIHRoZSBTdHJlYW0gQVBJLlxuICAgKiBAcmV0dXJucyB0aGUgYXR0YWNobWVudHNcbiAgICovXG4gIG1hcFRvQXR0YWNobWVudHMoKSB7XG4gICAgY29uc3QgYXR0YWNobWVudFVwbG9hZHMgPSB0aGlzLmF0dGFjaG1lbnRVcGxvYWRzU3ViamVjdC5nZXRWYWx1ZSgpO1xuICAgIHJldHVybiBhdHRhY2htZW50VXBsb2Fkc1xuICAgICAgLmZpbHRlcigocikgPT4gci5zdGF0ZSA9PT0gJ3N1Y2Nlc3MnKVxuICAgICAgLm1hcCgocikgPT4ge1xuICAgICAgICBjb25zdCBhdHRhY2htZW50OiBBdHRhY2htZW50ID0ge1xuICAgICAgICAgIHR5cGU6IHIudHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHIuZnJvbUF0dGFjaG1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gci5mcm9tQXR0YWNobWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRhY2htZW50Lm1pbWVfdHlwZSA9IHIuZmlsZT8udHlwZTtcbiAgICAgICAgICBpZiAoci50eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgICBhdHRhY2htZW50LmZhbGxiYWNrID0gci5maWxlPy5uYW1lO1xuICAgICAgICAgICAgYXR0YWNobWVudC5pbWFnZV91cmwgPSByLnVybDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0YWNobWVudC5hc3NldF91cmwgPSByLnVybDtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQudGl0bGUgPSByLmZpbGU/Lm5hbWU7XG4gICAgICAgICAgICBhdHRhY2htZW50LmZpbGVfc2l6ZSA9IHIuZmlsZT8uc2l6ZTtcbiAgICAgICAgICAgIGF0dGFjaG1lbnQudGh1bWJfdXJsID0gci50aHVtYl91cmw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dGFjaG1lbnQ7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIGF0dGFjaG1lbnRzIHJlY2VpdmVkIGZyb20gdGhlIFN0cmVhbSBBUEkgdG8gdXBsb2Fkcy4gVGhpcyBpcyB1c2VmdWwgd2hlbiBlZGl0aW5nIGEgbWVzc2FnZS5cbiAgICogQHBhcmFtIGF0dGFjaG1lbnRzIEF0dGFjaGVtbnRzIHJlY2VpdmVkIHdpdGggdGhlIG1lc3NhZ2VcbiAgICovXG4gIGNyZWF0ZUZyb21BdHRhY2htZW50cyhhdHRhY2htZW50czogQXR0YWNobWVudDxUPltdKSB7XG4gICAgY29uc3QgYXR0YWNobWVudFVwbG9hZHM6IEF0dGFjaG1lbnRVcGxvYWRbXSA9IFtdO1xuICAgIGF0dGFjaG1lbnRzLmZvckVhY2goKGF0dGFjaG1lbnQpID0+IHtcbiAgICAgIGlmIChpc0ltYWdlQXR0YWNobWVudChhdHRhY2htZW50KSkge1xuICAgICAgICBhdHRhY2htZW50VXBsb2Fkcy5wdXNoKHtcbiAgICAgICAgICB1cmw6IChhdHRhY2htZW50LmltZ191cmwgfHxcbiAgICAgICAgICAgIGF0dGFjaG1lbnQudGh1bWJfdXJsIHx8XG4gICAgICAgICAgICBhdHRhY2htZW50LmltYWdlX3VybCkgYXMgc3RyaW5nLFxuICAgICAgICAgIHN0YXRlOiAnc3VjY2VzcycsXG4gICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICBuYW1lOiBhdHRhY2htZW50LmZhbGxiYWNrLFxuICAgICAgICAgICAgdHlwZTogYXR0YWNobWVudC5taW1lX3R5cGUsXG4gICAgICAgICAgfSBhcyBGaWxlLFxuICAgICAgICAgIGZyb21BdHRhY2htZW50OiBhdHRhY2htZW50LFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0YWNobWVudC50eXBlID09PSAnZmlsZScgfHwgYXR0YWNobWVudC50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIGF0dGFjaG1lbnRVcGxvYWRzLnB1c2goe1xuICAgICAgICAgIHVybDogYXR0YWNobWVudC5hc3NldF91cmwsXG4gICAgICAgICAgc3RhdGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICBuYW1lOiBhdHRhY2htZW50LnRpdGxlLFxuICAgICAgICAgICAgc2l6ZTogYXR0YWNobWVudC5maWxlX3NpemUsXG4gICAgICAgICAgICB0eXBlOiBhdHRhY2htZW50Lm1pbWVfdHlwZSxcbiAgICAgICAgICB9IGFzIEZpbGUsXG4gICAgICAgICAgdHlwZTogYXR0YWNobWVudC50eXBlLFxuICAgICAgICAgIHRodW1iX3VybDogYXR0YWNobWVudC50aHVtYl91cmwsXG4gICAgICAgICAgZnJvbUF0dGFjaG1lbnQ6IGF0dGFjaG1lbnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGF0dGFjaG1lbnRVcGxvYWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYXR0YWNobWVudFVwbG9hZHNTdWJqZWN0Lm5leHQoW1xuICAgICAgICAuLi50aGlzLmF0dGFjaG1lbnRVcGxvYWRzU3ViamVjdC5nZXRWYWx1ZSgpLFxuICAgICAgICAuLi5hdHRhY2htZW50VXBsb2FkcyxcbiAgICAgIF0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUHJldmlldyhmaWxlOiBGaWxlKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBhdHRhY2htZW50VXBsb2FkcyA9IHRoaXMuYXR0YWNobWVudFVwbG9hZHNTdWJqZWN0LmdldFZhbHVlKCk7XG4gICAgICBjb25zdCB1cGxvYWQgPSBhdHRhY2htZW50VXBsb2Fkcy5maW5kKCh1cGxvYWQpID0+IHVwbG9hZC5maWxlID09PSBmaWxlKTtcbiAgICAgIGlmICghdXBsb2FkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVwbG9hZC5wcmV2aWV3VXJpID0gZXZlbnQudGFyZ2V0Py5yZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgdGhpcy5hdHRhY2htZW50VXBsb2Fkc1N1YmplY3QubmV4dChbLi4uYXR0YWNobWVudFVwbG9hZHNdKTtcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUgYXMgQmxvYik7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHVwbG9hZEF0dGFjaG1lbnRzKHVwbG9hZHM6IEF0dGFjaG1lbnRVcGxvYWRbXSkge1xuICAgIHRoaXMuYXR0YWNobWVudFVwbG9hZEluUHJvZ3Jlc3NDb3VudGVyU3ViamVjdC5uZXh0KFxuICAgICAgdGhpcy5hdHRhY2htZW50VXBsb2FkSW5Qcm9ncmVzc0NvdW50ZXJTdWJqZWN0LmdldFZhbHVlKCkgKyAxXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNoYW5uZWxTZXJ2aWNlLnVwbG9hZEF0dGFjaG1lbnRzKHVwbG9hZHMpO1xuICAgIGNvbnN0IGF0dGFjaG1lbnRVcGxvYWRzID0gdGhpcy5hdHRhY2htZW50VXBsb2Fkc1N1YmplY3QuZ2V0VmFsdWUoKTtcbiAgICByZXN1bHQuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgdXBsb2FkID0gYXR0YWNobWVudFVwbG9hZHMuZmluZCgodXBsb2FkKSA9PiB1cGxvYWQuZmlsZSA9PT0gci5maWxlKTtcbiAgICAgIGlmICghdXBsb2FkKSB7XG4gICAgICAgIGlmIChyLnVybCkge1xuICAgICAgICAgIHZvaWQgdGhpcy5jaGFubmVsU2VydmljZS5kZWxldGVBdHRhY2htZW50KHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVwbG9hZC5zdGF0ZSA9IHIuc3RhdGU7XG4gICAgICB1cGxvYWQudXJsID0gci51cmw7XG4gICAgICB1cGxvYWQudGh1bWJfdXJsID0gci50aHVtYl91cmw7XG4gICAgICBpZiAodXBsb2FkLnN0YXRlID09PSAnZXJyb3InKSB7XG4gICAgICAgIHVwbG9hZC5lcnJvclJlYXNvbiA9IHIuZXJyb3JSZWFzb247XG4gICAgICAgIHVwbG9hZC5lcnJvckV4dHJhSW5mbyA9IHIuZXJyb3JFeHRyYUluZm87XG4gICAgICAgIGxldCBlcnJvcktleTtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlUGFyYW1zOiB7IG5hbWU6IHN0cmluZzsgZXh0Pzogc3RyaW5nOyBsaW1pdD86IHN0cmluZyB9ID1cbiAgICAgICAgICB7IG5hbWU6IHVwbG9hZC5maWxlLm5hbWUgfTtcbiAgICAgICAgc3dpdGNoICh1cGxvYWQuZXJyb3JSZWFzb24pIHtcbiAgICAgICAgICBjYXNlICdmaWxlLWV4dGVuc2lvbic6XG4gICAgICAgICAgICBlcnJvcktleSA9XG4gICAgICAgICAgICAgICdzdHJlYW1DaGF0LkVycm9yIHVwbG9hZGluZyBmaWxlLCBleHRlbnNpb24gbm90IHN1cHBvcnRlZCc7XG4gICAgICAgICAgICB0cmFuc2xhdGVQYXJhbXMuZXh0ID0gdXBsb2FkLmVycm9yRXh0cmFJbmZvPy5bMF0/LnBhcmFtO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZmlsZS1zaXplJzpcbiAgICAgICAgICAgIGVycm9yS2V5ID1cbiAgICAgICAgICAgICAgJ3N0cmVhbUNoYXQuRXJyb3IgdXBsb2FkaW5nIGZpbGUsIG1heGltdW0gZmlsZSBzaXplIGV4Y2VlZGVkJztcbiAgICAgICAgICAgIHRyYW5zbGF0ZVBhcmFtcy5saW1pdCA9IHVwbG9hZC5lcnJvckV4dHJhSW5mbz8uWzBdPy5wYXJhbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcktleSA9ICdzdHJlYW1DaGF0LkVycm9yIHVwbG9hZGluZyBmaWxlJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvblNlcnZpY2UuYWRkVGVtcG9yYXJ5Tm90aWZpY2F0aW9uKFxuICAgICAgICAgIGVycm9yS2V5LFxuICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHRyYW5zbGF0ZVBhcmFtc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXR0YWNobWVudFVwbG9hZEluUHJvZ3Jlc3NDb3VudGVyU3ViamVjdC5uZXh0KFxuICAgICAgdGhpcy5hdHRhY2htZW50VXBsb2FkSW5Qcm9ncmVzc0NvdW50ZXJTdWJqZWN0LmdldFZhbHVlKCkgLSAxXG4gICAgKTtcbiAgICB0aGlzLmF0dGFjaG1lbnRVcGxvYWRzU3ViamVjdC5uZXh0KFsuLi5hdHRhY2htZW50VXBsb2Fkc10pO1xuICB9XG59XG4iXX0=